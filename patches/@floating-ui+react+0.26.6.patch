diff --git a/node_modules/@floating-ui/react/dist/floating-ui.react.d.mts b/node_modules/@floating-ui/react/dist/floating-ui.react.d.mts
index b43cdac..3d0e149 100644
--- a/node_modules/@floating-ui/react/dist/floating-ui.react.d.mts
+++ b/node_modules/@floating-ui/react/dist/floating-ui.react.d.mts
@@ -41,7 +41,7 @@ import { Padding } from '@floating-ui/react-dom';
 import { Placement } from '@floating-ui/react-dom';
 import { Platform } from '@floating-ui/react-dom';
 import { platform } from '@floating-ui/react-dom';
-import * as React from 'react';
+import * as React_2 from 'react';
 import { Rect } from '@floating-ui/react-dom';
 import { ReferenceElement } from '@floating-ui/react-dom';
 import { RootBoundary } from '@floating-ui/react-dom';
@@ -84,72 +84,19 @@ export { ClientRectObject }
 
 declare type ComponentRole = 'select' | 'label' | 'combobox';
 
-/**
- * Creates a single tab stop whose items are navigated by arrow keys, which
- * provides list navigation outside of floating element contexts.
- *
- * This is useful to enable navigation of a list of items that aren’t part of a
- * floating element. A menubar is an example of a composite, with each reference
- * element being an item.
- * @see https://floating-ui.com/docs/Composite
- */
-export declare const Composite: React.ForwardRefExoticComponent<Omit<React.HTMLProps<HTMLElement> & CompositeProps, "ref"> & React.RefAttributes<HTMLElement>>;
+export declare const Composite: React_2.ForwardRefExoticComponent<Omit<React_2.HTMLProps<HTMLElement> & CompositeProps, "ref"> & React_2.RefAttributes<HTMLElement>>;
 
-/**
- * @see https://floating-ui.com/docs/Composite
- */
-export declare const CompositeItem: React.ForwardRefExoticComponent<Omit<React.HTMLProps<HTMLElement> & CompositeItemProps, "ref"> & React.RefAttributes<HTMLElement>>;
-
-declare interface CompositeItemProps {
-    /**
-     * Determines the element to render.
-     * @example
-     * ```jsx
-     * <CompositeItem render={<li />} />
-     * <CompositeItem render={(htmlProps) => <li {...htmlProps} />} />
-     * ```
-     */
-    render?: RenderProp;
-}
+export declare const CompositeItem: React_2.ForwardRefExoticComponent<Omit<React_2.HTMLProps<HTMLElement> & {
+    render?: RenderProp | undefined;
+}, "ref"> & React_2.RefAttributes<HTMLElement>>;
 
 declare interface CompositeProps {
-    /**
-     * Determines the element to render.
-     * @example
-     * ```jsx
-     * <Composite render={<ul />} />
-     * <Composite render={(htmlProps) => <ul {...htmlProps} />} />
-     * ```
-     */
     render?: RenderProp;
-    /**
-     * Determines the orientation of the composite.
-     */
     orientation?: 'horizontal' | 'vertical' | 'both';
-    /**
-     * Determines whether focus should loop around when navigating past the first
-     * or last item.
-     */
     loop?: boolean;
-    /**
-     * Determines the number of columns there are in the composite
-     * (i.e. it’s a grid).
-     */
     cols?: number;
-    /**
-     * Determines which items are disabled. The `disabled` or `aria-disabled`
-     * attributes are used by default.
-     */
     disabledIndices?: number[];
-    /**
-     * Determines which item is active. Used to externally control the active
-     * item.
-     */
     activeIndex?: number;
-    /**
-     * Called when the user navigates to a new item. Used to externally control
-     * the active item.
-     */
     onNavigate?(index: number): void;
     /**
      * Only for `cols > 1`, specify sizes for grid items.
@@ -171,7 +118,6 @@ export { ComputePositionReturn }
 
 export declare interface ContextData {
     openEvent?: Event;
-    floatingContext?: FloatingContext;
     /** @deprecated use `onTypingChange` prop in `useTypeahead` */
     typing?: boolean;
     [key: string]: any;
@@ -179,10 +125,10 @@ export declare interface ContextData {
 
 export { Coords }
 
-declare type CSSStylesProperty = React.CSSProperties | ((params: {
+declare type CSSStylesProperty = React_2.CSSProperties | ((params: {
     side: Side;
     placement: Placement;
-}) => React.CSSProperties);
+}) => React_2.CSSProperties);
 
 declare type Delay = number | Partial<{
     open: number;
@@ -198,9 +144,9 @@ export { Dimensions }
 export { ElementContext }
 
 export declare interface ElementProps {
-    reference?: React.HTMLProps<Element>;
-    floating?: React.HTMLProps<HTMLElement>;
-    item?: React.HTMLProps<HTMLElement> | ((props: ExtendedUserProps) => React.HTMLProps<HTMLElement>);
+    reference?: React_2.HTMLProps<Element>;
+    floating?: React_2.HTMLProps<HTMLElement>;
+    item?: React_2.HTMLProps<HTMLElement> | ((props: ExtendedUserProps) => React_2.HTMLProps<HTMLElement>);
 }
 
 export { ElementRects }
@@ -214,9 +160,9 @@ export declare interface ExtendedElements<RT> {
 }
 
 export declare interface ExtendedRefs<RT> {
-    reference: React.MutableRefObject<ReferenceType | null>;
-    floating: React.MutableRefObject<HTMLElement | null>;
-    domReference: React.MutableRefObject<NarrowedElement<RT> | null>;
+    reference: React_2.MutableRefObject<ReferenceType | null>;
+    floating: React_2.MutableRefObject<HTMLElement | null>;
+    domReference: React_2.MutableRefObject<NarrowedElement<RT> | null>;
     setReference(node: RT | null): void;
     setFloating(node: HTMLElement | null): void;
     setPositionReference(node: ReferenceType | null): void;
@@ -235,9 +181,9 @@ export { FlipOptions }
  * Renders a pointing arrow triangle.
  * @see https://floating-ui.com/docs/FloatingArrow
  */
-export declare const FloatingArrow: React.ForwardRefExoticComponent<Omit<FloatingArrowProps, "ref"> & React.RefAttributes<SVGSVGElement>>;
+export declare const FloatingArrow: React_2.ForwardRefExoticComponent<FloatingArrowProps & React_2.RefAttributes<SVGSVGElement>>;
 
-export declare interface FloatingArrowProps extends React.ComponentPropsWithRef<'svg'> {
+export declare interface FloatingArrowProps extends React_2.SVGAttributes<SVGSVGElement> {
     /**
      * The floating context.
      */
@@ -281,7 +227,7 @@ export declare type FloatingContext<RT extends ReferenceType = ReferenceType> =
     open: boolean;
     onOpenChange(open: boolean, event?: Event, reason?: OpenChangeReason): void;
     events: FloatingEvents;
-    dataRef: React.MutableRefObject<ContextData>;
+    dataRef: React_2.MutableRefObject<ContextData>;
     nodeId: string | undefined;
     floatingId: string;
     refs: ExtendedRefs<RT>;
@@ -293,20 +239,11 @@ export declare type FloatingContext<RT extends ReferenceType = ReferenceType> =
  * `delay`.
  * @see https://floating-ui.com/docs/FloatingDelayGroup
  */
-export declare function FloatingDelayGroup(props: FloatingDelayGroupProps): JSX.Element;
+export declare const FloatingDelayGroup: ({ children, delay, timeoutMs, }: FloatingDelayGroupProps) => JSX.Element;
 
 declare interface FloatingDelayGroupProps {
-    children?: React.ReactNode;
-    /**
-     * The delay to use for the group.
-     */
+    children?: React_2.ReactNode;
     delay: Delay;
-    /**
-     * An optional explicit timeout to use for the group, which represents when
-     * grouping logic will no longer be active after the close delay completes.
-     * This is useful if you want grouping to “last” longer than the close delay,
-     * for example if there is no close delay at all.
-     */
     timeoutMs?: number;
 }
 
@@ -322,69 +259,18 @@ export declare interface FloatingEvents {
  * Provides focus management for the floating element.
  * @see https://floating-ui.com/docs/FloatingFocusManager
  */
-export declare function FloatingFocusManager(props: FloatingFocusManagerProps): JSX.Element;
+export declare function FloatingFocusManager<RT extends ReferenceType = ReferenceType>(props: FloatingFocusManagerProps<RT>): JSX.Element;
 
-export declare interface FloatingFocusManagerProps {
+export declare interface FloatingFocusManagerProps<RT extends ReferenceType = ReferenceType> {
+    context: FloatingContext<RT>;
     children: JSX.Element;
-    /**
-     * The floating context returned from `useFloating`.
-     */
-    context: FloatingContext;
-    /**
-     * Whether or not the focus manager should be disabled. Useful to delay focus
-     * management until after a transition completes or some other conditional
-     * state.
-     * @default false
-     */
     disabled?: boolean;
-    /**
-     * The order in which focus cycles.
-     * @default ['content']
-     */
     order?: Array<'reference' | 'floating' | 'content'>;
-    /**
-     * Which element to initially focus. Can be either a number (tabbable index as
-     * specified by the `order`) or a ref.
-     * @default 0
-     */
-    initialFocus?: number | React.MutableRefObject<HTMLElement | null>;
-    /**
-     * Determines if the focus guards are rendered. If not, focus can escape into
-     * the address bar/console/browser UI, like in native dialogs.
-     * @default true
-     */
+    initialFocus?: number | React_2.MutableRefObject<HTMLElement | null>;
     guards?: boolean;
-    /**
-     * Determines if focus should be returned to the reference element once the
-     * floating element closes/unmounts (or if that is not available, the
-     * previously focused element). This prop is ignored if the floating element
-     * lost focus.
-     * @default true
-     */
     returnFocus?: boolean;
-    /**
-     * Determines if focus is “modal”, meaning focus is fully trapped inside the
-     * floating element and outside content cannot be accessed. This includes
-     * screen reader virtual cursors.
-     * @default true
-     */
     modal?: boolean;
-    /**
-     * If your focus management is modal and there is no explicit close button
-     * available, you can use this prop to render a visually-hidden dismiss
-     * button at the start and end of the floating element. This allows
-     * touch-based screen readers to escape the floating element due to lack of
-     * an `esc` key.
-     * @default undefined
-     */
     visuallyHiddenDismiss?: boolean | string;
-    /**
-     * Determines whether `focusout` event listeners that control whether the
-     * floating element should be closed if the focus moves outside of it are
-     * attached to the reference and floating elements. This affects non-modal
-     * focus management.
-     * @default true
-     */
     closeOnFocusOut?: boolean;
 }
 
@@ -392,28 +278,20 @@ export declare interface FloatingFocusManagerProps {
  * Provides context for a list of items within the floating element.
  * @see https://floating-ui.com/docs/FloatingList
  */
-export declare function FloatingList(props: FloatingListProps): JSX.Element;
+export declare function FloatingList({ children, elementsRef, labelsRef, }: FloatingListProps): JSX.Element;
 
 declare interface FloatingListProps {
-    children: React.ReactNode;
-    /**
-     * A ref to the list of HTML elements, ordered by their index.
-     * `useListNavigation`'s `listRef` prop.
-     */
-    elementsRef: React.MutableRefObject<Array<HTMLElement | null>>;
-    /**
-     * A ref to the list of element labels, ordered by their index.
-     * `useTypeahead`'s `listRef` prop.
-     */
-    labelsRef?: React.MutableRefObject<Array<string | null>>;
+    children: React_2.ReactNode;
+    elementsRef: React_2.MutableRefObject<Array<HTMLElement | null>>;
+    labelsRef?: React_2.MutableRefObject<Array<string | null>>;
 }
 
 /**
  * Provides parent node context for nested floating elements.
  * @see https://floating-ui.com/docs/FloatingTree
  */
-export declare function FloatingNode(props: {
-    children?: React.ReactNode;
+export declare function FloatingNode({ children, id, }: {
+    children?: React_2.ReactNode;
     id: string;
 }): JSX.Element;
 
@@ -429,77 +307,36 @@ export declare interface FloatingNodeType<RT extends ReferenceType = ReferenceTy
  * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.
  * @see https://floating-ui.com/docs/FloatingOverlay
  */
-export declare const FloatingOverlay: React.ForwardRefExoticComponent<Omit<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & FloatingOverlayProps & React.RefAttributes<HTMLDivElement>>;
-
-export declare interface FloatingOverlayProps {
-    /**
-     * Whether the overlay should lock scrolling on the document body.
-     * @default false
-     */
-    lockScroll?: boolean;
-}
+export declare const FloatingOverlay: React_2.ForwardRefExoticComponent<Omit<React_2.HTMLProps<HTMLDivElement> & {
+    lockScroll?: boolean | undefined;
+}, "ref"> & React_2.RefAttributes<HTMLDivElement>>;
 
 /**
  * Portals the floating element into a given container element — by default,
  * outside of the app root and into the body.
- * This is necessary to ensure the floating element can appear outside any
- * potential parent containers that cause clipping (such as `overflow: hidden`),
- * while retaining its location in the React tree.
  * @see https://floating-ui.com/docs/FloatingPortal
  */
-export declare function FloatingPortal(props: FloatingPortalProps): JSX.Element;
+export declare function FloatingPortal({ children, id, root, preserveTabOrder, }: FloatingPortalProps): JSX.Element;
 
 declare interface FloatingPortalProps {
-    children?: React.ReactNode;
-    /**
-     * Optionally selects the node with the id if it exists, or create it and
-     * append it to the specified `root` (by default `document.body`).
-     */
+    children?: React_2.ReactNode;
     id?: string;
-    /**
-     * Specifies the root node the portal container will be appended to.
-     */
-    root?: HTMLElement | null | React.MutableRefObject<HTMLElement | null>;
-    /**
-     * When using non-modal focus management using `FloatingFocusManager`, this
-     * will preserve the tab order context based on the React tree instead of the
-     * DOM tree.
-     */
+    root?: HTMLElement | null | React_2.MutableRefObject<HTMLElement | null>;
     preserveTabOrder?: boolean;
 }
 
-export declare interface FloatingRootContext<RT extends ReferenceType = ReferenceType> {
-    dataRef: React.MutableRefObject<ContextData>;
-    open: boolean;
-    onOpenChange: (open: boolean, event?: Event, reason?: OpenChangeReason) => void;
-    elements: {
-        domReference: Element | null;
-        reference: RT | null;
-        floating: HTMLElement | null;
-    };
-    events: FloatingEvents;
-    floatingId: string;
-    refs: {
-        setPositionReference(node: ReferenceType | null): void;
-    };
-}
-
 /**
  * Provides context for nested floating elements when they are not children of
- * each other on the DOM.
- * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:
- * - The `bubbles` option in the `useDismiss()` Hook
- * - Nested virtual list navigation
- * - Nested floating elements that each open on hover
- * - Custom communication between parent and child floating elements
+ * each other on the DOM (i.e. portalled to a common node, rather than their
+ * respective parent).
  * @see https://floating-ui.com/docs/FloatingTree
  */
-export declare function FloatingTree(props: {
-    children?: React.ReactNode;
+export declare function FloatingTree({ children, }: {
+    children?: React_2.ReactNode;
 }): JSX.Element;
 
 export declare interface FloatingTreeType<RT extends ReferenceType = ReferenceType> {
-    nodesRef: React.MutableRefObject<Array<FloatingNodeType<RT>>>;
+    nodesRef: React_2.MutableRefObject<Array<FloatingNodeType<RT>>>;
     events: FloatingEvents;
     addNode(node: FloatingNodeType): void;
     removeNode(node: FloatingNodeType): void;
@@ -508,8 +345,8 @@ export declare interface FloatingTreeType<RT extends ReferenceType = ReferenceTy
 export { getOverflowAncestors }
 
 declare interface GroupContext extends GroupState {
-    setCurrentId: React.Dispatch<React.SetStateAction<any>>;
-    setState: React.Dispatch<Partial<GroupState>>;
+    setCurrentId: React_2.Dispatch<React_2.SetStateAction<any>>;
+    setState: React_2.Dispatch<Partial<GroupState>>;
 }
 
 declare interface GroupState {
@@ -520,10 +357,10 @@ declare interface GroupState {
     isInstantPhase: boolean;
 }
 
-declare interface HandleCloseFn {
-    (context: FloatingContext & {
+declare interface HandleCloseFn<RT extends ReferenceType = ReferenceType> {
+    (context: FloatingContext<RT> & {
         onClose: () => void;
-        tree?: FloatingTreeType | null;
+        tree?: FloatingTreeType<RT> | null;
         leave?: boolean;
     }): (event: MouseEvent) => void;
     __options: {
@@ -547,45 +384,13 @@ export { InlineOptions }
 export declare const inner: (props: InnerProps & Partial<DetectOverflowOptions>) => Middleware;
 
 export declare interface InnerProps {
-    /**
-     * A ref which contains an array of HTML elements.
-     * @default empty list
-     */
-    listRef: React.MutableRefObject<Array<HTMLElement | null>>;
-    /**
-     * The index of the active (focused or highlighted) item in the list.
-     * @default 0
-     */
+    listRef: React_2.MutableRefObject<Array<HTMLElement | null>>;
     index: number;
-    /**
-     * Callback invoked when the fallback state changes.
-     */
     onFallbackChange?: null | ((fallback: boolean) => void);
-    /**
-     * The offset to apply to the floating element.
-     * @default 0
-     */
     offset?: number;
-    /**
-     * A ref which contains the overflow of the floating element.
-     */
-    overflowRef?: React.MutableRefObject<SideObject | null>;
-    /**
-     * An optional ref containing an HTMLElement. This may be used as the
-     * scrolling container instead of the floating element — for instance,
-     * to position inner elements as direct children without being interfered by
-     * scrolling layout.
-     */
-    scrollRef?: React.MutableRefObject<HTMLElement | null>;
-    /**
-     * The minimum number of items that should be visible in the list.
-     * @default 4
-     */
+    overflowRef?: React_2.MutableRefObject<SideObject | null>;
+    scrollRef?: React_2.MutableRefObject<HTMLElement | null>;
     minItemsVisible?: number;
-    /**
-     * The threshold for the reference element's overflow in pixels.
-     * @default 0
-     */
     referenceOverflowThreshold?: number;
 }
 
@@ -631,21 +436,21 @@ export { ReferenceElement }
 
 export declare type ReferenceType = Element | VirtualElement;
 
-declare type RenderProp = JSX.Element | ((props: React.HTMLAttributes<HTMLElement>) => JSX.Element);
+declare type RenderProp = JSX.Element | ((props: React_2.HTMLAttributes<HTMLElement>) => JSX.Element);
 
 export { RootBoundary }
 
 /**
  * Generates a safe polygon area that the user can traverse without closing the
  * floating element once leaving the reference element.
- * @see https://floating-ui.com/docs/useHover#safepolygon
+ * @see https://floating-ui.com/docs/useHover#safePolygon
  */
-export declare function safePolygon(options?: SafePolygonOptions): HandleCloseFn;
+export declare function safePolygon<RT extends ReferenceType = ReferenceType>(options?: Partial<SafePolygonOptions>): HandleCloseFn<RT>;
 
 declare interface SafePolygonOptions {
-    buffer?: number;
-    blockPointerEvents?: boolean;
-    requireIntent?: boolean;
+    buffer: number;
+    blockPointerEvents: boolean;
+    requireIntent: boolean;
 }
 
 declare const SELECTED_KEY = "selected";
@@ -670,41 +475,13 @@ export { Strategy }
  * Opens or closes the floating element when clicking the reference element.
  * @see https://floating-ui.com/docs/useClick
  */
-export declare function useClick(context: FloatingRootContext, props?: UseClickProps): ElementProps;
+export declare function useClick<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseClickProps): ElementProps;
 
 export declare interface UseClickProps {
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
     enabled?: boolean;
-    /**
-     * The type of event to use to determine a “click” with mouse input.
-     * Keyboard clicks work as normal.
-     * @default 'click'
-     */
     event?: 'click' | 'mousedown';
-    /**
-     * Whether to toggle the open state with repeated clicks.
-     * @default true
-     */
     toggle?: boolean;
-    /**
-     * Whether to ignore the logic for mouse input (for example, if `useHover()`
-     * is also being used).
-     * When `useHover()` and `useClick()` are used together, clicking the
-     * reference element after hovering it will keep the floating element open
-     * even once the cursor leaves. This may be not be desirable in some cases.
-     * @default false
-     */
     ignoreMouse?: boolean;
-    /**
-     * Whether to add keyboard handlers (Enter and Space key functionality) for
-     * non-button elements (to open/close the floating element via keyboard
-     * “click”).
-     * @default true
-     */
     keyboardHandlers?: boolean;
 }
 
@@ -713,45 +490,17 @@ export declare interface UseClickProps {
  * such as the mouse position. By default, it follows the mouse cursor.
  * @see https://floating-ui.com/docs/useClientPoint
  */
-export declare function useClientPoint(context: FloatingRootContext, props?: UseClientPointProps): ElementProps;
+export declare function useClientPoint<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseClientPointProps): ElementProps;
 
 export declare interface UseClientPointProps {
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
     enabled?: boolean;
-    /**
-     * Whether to restrict the client point to an axis and use the reference
-     * element (if it exists) as the other axis. This can be useful if the
-     * floating element is also interactive.
-     * @default 'both'
-     */
     axis?: 'x' | 'y' | 'both';
-    /**
-     * An explicitly defined `x` client coordinate.
-     * @default null
-     */
     x?: number | null;
-    /**
-     * An explicitly defined `y` client coordinate.
-     * @default null
-     */
     y?: number | null;
 }
 
-/**
- * Enables grouping when called inside a component that's a child of a
- * `FloatingDelayGroup`.
- * @see https://floating-ui.com/docs/FloatingDelayGroup
- */
-export declare function useDelayGroup(context: FloatingRootContext, options?: UseGroupOptions): GroupContext;
+export declare const useDelayGroup: ({ open, onOpenChange }: FloatingContext, { id }: UseGroupOptions) => void;
 
-/**
- * @deprecated
- * Use the return value of `useDelayGroup()` instead.
- */
 export declare const useDelayGroupContext: () => GroupContext;
 
 /**
@@ -759,74 +508,20 @@ export declare const useDelayGroupContext: () => GroupContext;
  * the user presses the `escape` key or outside of the floating element.
  * @see https://floating-ui.com/docs/useDismiss
  */
-export declare function useDismiss(context: FloatingRootContext, props?: UseDismissProps): ElementProps;
+export declare function useDismiss<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseDismissProps): ElementProps;
 
 export declare interface UseDismissProps {
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
     enabled?: boolean;
-    /**
-     * Whether to dismiss the floating element upon pressing the `esc` key.
-     * @default true
-     */
     escapeKey?: boolean;
-    /**
-     * Whether to dismiss the floating element upon pressing the reference
-     * element. You likely want to ensure the `move` option in the `useHover()`
-     * Hook has been disabled when this is in use.
-     * @default false
-     */
     referencePress?: boolean;
-    /**
-     * The type of event to use to determine a “press”.
-     * - `pointerdown` is eager on both mouse + touch input.
-     * - `mousedown` is eager on mouse input, but lazy on touch input.
-     * - `click` is lazy on both mouse + touch input.
-     * @default 'pointerdown'
-     */
     referencePressEvent?: 'pointerdown' | 'mousedown' | 'click';
-    /**
-     * Whether to dismiss the floating element upon pressing outside of the
-     * floating element.
-     * If you have another element, like a toast, that is rendered outside the
-     * floating element’s React tree and don’t want the floating element to close
-     * when pressing it, you can guard the check like so:
-     * ```jsx
-     * useDismiss(context, {
-     *   outsidePress: (event) => !event.target.closest('.toast'),
-     * });
-     * ```
-     * @default true
-     */
     outsidePress?: boolean | ((event: MouseEvent) => boolean);
-    /**
-     * The type of event to use to determine an outside “press”.
-     * - `pointerdown` is eager on both mouse + touch input.
-     * - `mousedown` is eager on mouse input, but lazy on touch input.
-     * - `click` is lazy on both mouse + touch input.
-     * @default 'pointerdown'
-     */
     outsidePressEvent?: 'pointerdown' | 'mousedown' | 'click';
-    /**
-     * Whether to dismiss the floating element upon scrolling an overflow
-     * ancestor.
-     * @default false
-     */
     ancestorScroll?: boolean;
-    /**
-     * Determines whether event listeners bubble upwards through a tree of
-     * floating elements.
-     */
     bubbles?: boolean | {
         escapeKey?: boolean;
         outsidePress?: boolean;
     };
-    /**
-     * Determines whether to use capture phase event listeners.
-     */
     capture?: boolean | {
         escapeKey?: boolean;
         outsidePress?: boolean;
@@ -837,18 +532,16 @@ export declare interface UseDismissProps {
  * Provides data to position a floating element and context to add interactions.
  * @see https://floating-ui.com/docs/useFloating
  */
-export declare function useFloating<RT extends ReferenceType = ReferenceType>(options?: UseFloatingOptions): UseFloatingReturn<RT>;
+export declare function useFloating<RT extends ReferenceType = ReferenceType>(options?: Partial<UseFloatingOptions>): UseFloatingReturn<RT>;
 
 export declare type UseFloatingData = Prettify<UseFloatingReturn>;
 
 /**
- * Registers a node into the `FloatingTree`, returning its id.
- * @see https://floating-ui.com/docs/FloatingTree
+ * Registers a node into the floating tree, returning its id.
  */
 export declare function useFloatingNodeId(customParentId?: string): string;
 
 export declare interface UseFloatingOptions<RT extends ReferenceType = ReferenceType> extends Omit<UseFloatingOptions_2<RT>, 'elements'> {
-    rootContext?: FloatingRootContext<RT>;
     /**
      * Object of external elements as an alternative to the `refs` object setters.
      */
@@ -873,46 +566,19 @@ export declare interface UseFloatingOptions<RT extends ReferenceType = Reference
     nodeId?: string;
 }
 
-/**
- * Returns the parent node id for nested floating elements, if available.
- * Returns `null` for top-level floating elements.
- */
 export declare const useFloatingParentNodeId: () => string | null;
 
-/**
- * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode
- */
-export declare function useFloatingPortalNode(props?: {
+export declare function useFloatingPortalNode({ id, root, }?: {
     id?: string;
-    root?: HTMLElement | null | React.MutableRefObject<HTMLElement | null>;
+    root?: HTMLElement | null | React_2.MutableRefObject<HTMLElement | null>;
 }): HTMLElement | null;
 
 export declare type UseFloatingReturn<RT extends ReferenceType = ReferenceType> = Prettify<UseFloatingReturn_2 & {
-    /**
-     * `FloatingContext`
-     */
     context: Prettify<FloatingContext<RT>>;
-    /**
-     * Object containing the reference and floating refs and reactive setters.
-     */
     refs: ExtendedRefs<RT>;
     elements: ExtendedElements<RT>;
 }>;
 
-export declare function useFloatingRootContext(options: UseFloatingRootContextOptions): FloatingRootContext;
-
-export declare interface UseFloatingRootContextOptions {
-    open?: boolean;
-    onOpenChange?: (open: boolean, event?: Event, reason?: OpenChangeReason) => void;
-    elements: {
-        reference: Element | null;
-        floating: HTMLElement | null;
-    };
-}
-
-/**
- * Returns the nearest floating tree context, if available.
- */
 export declare const useFloatingTree: <RT extends ReferenceType = ReferenceType>() => FloatingTreeType<RT> | null;
 
 /**
@@ -920,25 +586,15 @@ export declare const useFloatingTree: <RT extends ReferenceType = ReferenceType>
  * `:focus`.
  * @see https://floating-ui.com/docs/useFocus
  */
-export declare function useFocus(context: FloatingRootContext, props?: UseFocusProps): ElementProps;
+export declare function useFocus<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseFocusProps): ElementProps;
 
 export declare interface UseFocusProps {
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
     enabled?: boolean;
-    /**
-     * Whether the open state only changes if the focus event is considered
-     * visible (`:focus-visible` CSS selector).
-     * @default true
-     */
     visibleOnly?: boolean;
 }
 
 declare interface UseGroupOptions {
-    id?: any;
+    id: any;
 }
 
 /**
@@ -946,48 +602,17 @@ declare interface UseGroupOptions {
  * CSS `:hover`.
  * @see https://floating-ui.com/docs/useHover
  */
-export declare function useHover(context: FloatingRootContext, props?: UseHoverProps): ElementProps;
+export declare function useHover<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseHoverProps<RT>): ElementProps;
 
-export declare interface UseHoverProps {
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
+export declare interface UseHoverProps<RT extends ReferenceType = ReferenceType> {
     enabled?: boolean;
-    /**
-     * Instead of closing the floating element when the cursor leaves its
-     * reference, we can leave it open until a certain condition is satisfied,
-     * e.g. to let them traverse into the floating element.
-     * @default null
-     */
-    handleClose?: HandleCloseFn | null;
-    /**
-     * Waits until the user’s cursor is at “rest” over the reference element
-     *  before changing the `open` state.
-     * @default 0
-     */
+    handleClose?: HandleCloseFn<RT> | null;
     restMs?: number;
-    /**
-     * Waits for the specified time when the event listener runs before changing
-     * the `open` state.
-     * @default 0
-     */
     delay?: number | Partial<{
         open: number;
         close: number;
     }>;
-    /**
-     * Whether the logic only runs for mouse input, ignoring touch input.
-     * Note: due to a bug with Linux Chrome, "pen" inputs are considered "mouse".
-     * @default false
-     */
     mouseOnly?: boolean;
-    /**
-     * Whether moving the cursor over the floating element will open it, without a
-     * regular hover event required.
-     * @default true
-     */
     move?: boolean;
 }
 
@@ -995,7 +620,7 @@ export declare interface UseHoverProps {
  * Uses React 18's built-in `useId()` when available, or falls back to a
  * slightly less performant (requiring a double render) implementation for
  * earlier React versions.
- * @see https://floating-ui.com/docs/react-utils#useid
+ * @see https://floating-ui.com/docs/useId
  */
 export declare const useId: () => string;
 
@@ -1004,29 +629,12 @@ export declare const useId: () => string;
  * expand the floating element's height, revealing more list items.
  * @see https://floating-ui.com/docs/inner
  */
-export declare function useInnerOffset(context: FloatingRootContext, props: UseInnerOffsetProps): ElementProps;
+export declare function useInnerOffset(context: FloatingContext, props: UseInnerOffsetProps): ElementProps;
 
 export declare interface UseInnerOffsetProps {
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
     enabled?: boolean;
-    /**
-     * A ref which contains the overflow of the floating element.
-     */
-    overflowRef: React.MutableRefObject<SideObject | null>;
-    /**
-     * An optional ref containing an HTMLElement. This may be used as the
-     * scrolling container instead of the floating element — for instance,
-     * to position inner elements as direct children without being interfered by
-     * scrolling layout.
-     */
-    scrollRef?: React.MutableRefObject<HTMLElement | null>;
-    /**
-     * Callback invoked when the offset changes.
-     */
+    overflowRef: React_2.MutableRefObject<SideObject | null>;
+    scrollRef?: React_2.MutableRefObject<HTMLElement | null>;
     onChange: (offset: number | ((offset: number) => number)) => void;
 }
 
@@ -1036,20 +644,13 @@ export declare interface UseInnerOffsetProps {
  * another.
  * @see https://floating-ui.com/docs/useInteractions
  */
-export declare function useInteractions(propsList?: Array<ElementProps | void>): UseInteractionsReturn;
-
-export declare interface UseInteractionsReturn {
-    getReferenceProps: (userProps?: React.HTMLProps<Element>) => Record<string, unknown>;
-    getFloatingProps: (userProps?: React.HTMLProps<HTMLElement>) => Record<string, unknown>;
-    getItemProps: (userProps?: Omit<React.HTMLProps<HTMLElement>, 'selected' | 'active'> & ExtendedUserProps) => Record<string, unknown>;
-}
+export declare function useInteractions(propsList?: Array<ElementProps | void>): {
+    getReferenceProps: (userProps?: React_2.HTMLProps<Element>) => Record<string, unknown>;
+    getFloatingProps: (userProps?: React_2.HTMLProps<HTMLElement>) => Record<string, unknown>;
+    getItemProps: (userProps?: Omit<React_2.HTMLProps<HTMLElement>, 'selected' | 'active'> & ExtendedUserProps) => Record<string, unknown>;
+};
 
-/**
- * Used to register a list item and its index (DOM position) in the
- * `FloatingList`.
- * @see https://floating-ui.com/docs/FloatingList#uselistitem
- */
-export declare function useListItem(props?: UseListItemProps): {
+export declare function useListItem({ label }?: UseListItemProps): {
     ref: (node: HTMLElement | null) => void;
     index: number;
 };
@@ -1063,130 +664,27 @@ declare interface UseListItemProps {
  * focus or virtual focus.
  * @see https://floating-ui.com/docs/useListNavigation
  */
-export declare function useListNavigation(context: FloatingRootContext, props: UseListNavigationProps): ElementProps;
+export declare function useListNavigation<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props: UseListNavigationProps): ElementProps;
 
 export declare interface UseListNavigationProps {
-    /**
-     * A ref that holds an array of list items.
-     * @default empty list
-     */
-    listRef: React.MutableRefObject<Array<HTMLElement | null>>;
-    /**
-     * The index of the currently active (focused or highlighted) item, which may
-     * or may not be selected.
-     * @default null
-     */
+    listRef: React_2.MutableRefObject<Array<HTMLElement | null>>;
     activeIndex: number | null;
-    /**
-     * A callback that is called when the user navigates to a new active item,
-     * passed in a new `activeIndex`.
-     */
-    onNavigate?: (activeIndex: number | null) => void;
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
+    onNavigate?: (index: number | null) => void;
     enabled?: boolean;
-    /**
-     * The currently selected item index, which may or may not be active.
-     * @default null
-     */
     selectedIndex?: number | null;
-    /**
-     * Whether to focus the item upon opening the floating element. 'auto' infers
-     * what to do based on the input type (keyboard vs. pointer), while a boolean
-     * value will force the value.
-     * @default 'auto'
-     */
     focusItemOnOpen?: boolean | 'auto';
-    /**
-     * Whether hovering an item synchronizes the focus.
-     * @default true
-     */
     focusItemOnHover?: boolean;
-    /**
-     * Whether pressing an arrow key on the navigation’s main axis opens the
-     * floating element.
-     * @default true
-     */
     openOnArrowKeyDown?: boolean;
-    /**
-     * By default elements with either a `disabled` or `aria-disabled` attribute
-     * are skipped in the list navigation — however, this requires the items to
-     * be rendered.
-     * This prop allows you to manually specify indices which should be disabled,
-     * overriding the default logic.
-     * For Windows-style select menus, where the menu does not open when
-     * navigating via arrow keys, specify an empty array.
-     * @default undefined
-     */
     disabledIndices?: Array<number>;
-    /**
-     * Determines whether focus can escape the list, such that nothing is selected
-     * after navigating beyond the boundary of the list. In some
-     * autocomplete/combobox components, this may be desired, as screen
-     * readers will return to the input.
-     * `loop` must be `true`.
-     * @default false
-     */
     allowEscape?: boolean;
-    /**
-     * Determines whether focus should loop around when navigating past the first
-     * or last item.
-     * @default false
-     */
     loop?: boolean;
-    /**
-     * If the list is nested within another one (e.g. a nested submenu), the
-     * navigation semantics change.
-     * @default false
-     */
     nested?: boolean;
-    /**
-     * Whether the direction of the floating element’s navigation is in RTL
-     * layout.
-     * @default false
-     */
     rtl?: boolean;
-    /**
-     * Whether the focus is virtual (using `aria-activedescendant`).
-     * Use this if you need focus to remain on the reference element
-     * (such as an input), but allow arrow keys to navigate list items.
-     * This is common in autocomplete listbox components.
-     * Your virtually-focused list items must have a unique `id` set on them.
-     * If you’re using a component role with the `useRole()` Hook, then an `id` is
-     * generated automatically.
-     * @default false
-     */
     virtual?: boolean;
-    /**
-     * The orientation in which navigation occurs.
-     * @default 'vertical'
-     */
     orientation?: 'vertical' | 'horizontal' | 'both';
-    /**
-     * Specifies how many columns the list has (i.e., it’s a grid). Use an
-     * orientation of 'horizontal' (e.g. for an emoji picker/date picker, where
-     * pressing ArrowRight or ArrowLeft can change rows), or 'both' (where the
-     * current row cannot be escaped with ArrowRight or ArrowLeft, only ArrowUp
-     * and ArrowDown).
-     * @default 1
-     */
     cols?: number;
-    /**
-     * Whether to scroll the active item into view when navigating. The default
-     * value uses nearest options.
-     */
     scrollItemIntoView?: boolean | ScrollIntoViewOptions;
-    /**
-     * When using virtual focus management, this holds a ref to the
-     * virtually-focused item. This allows nested virtual navigation to be
-     * enabled, and lets you know when a nested element is virtually focused from
-     * the root reference handling the events. Requires `FloatingTree` to be
-     * setup.
-     */
-    virtualItemRef?: React.MutableRefObject<HTMLElement | null>;
+    virtualItemRef?: React_2.MutableRefObject<HTMLElement | null>;
     /**
      * Only for `cols > 1`, specify sizes for grid items.
      * `{ width: 2, height: 2 }` means an item is 2 columns wide and 2 rows tall.
@@ -1194,36 +692,26 @@ export declare interface UseListNavigationProps {
     itemSizes?: Dimensions[];
     /**
      * Only relevant for `cols > 1` and items with different sizes, specify if
-     * the grid is dense (as defined in the CSS spec for `grid-auto-flow`).
-     * @default false
+     * the grid is dense (as defined in the CSS spec for grid-auto-flow).
      */
     dense?: boolean;
 }
 
 /**
  * Merges an array of refs into a single memoized callback ref or `null`.
- * @see https://floating-ui.com/docs/react-utils#usemergerefs
+ * @see https://floating-ui.com/docs/useMergeRefs
  */
-export declare function useMergeRefs<Instance>(refs: Array<React.Ref<Instance> | undefined>): React.RefCallback<Instance> | null;
+export declare function useMergeRefs<Instance>(refs: Array<React_2.Ref<Instance> | undefined>): React_2.RefCallback<Instance> | null;
 
 /**
  * Adds base screen reader props to the reference and floating elements for a
  * given floating element `role`.
  * @see https://floating-ui.com/docs/useRole
  */
-export declare function useRole(context: FloatingRootContext, props?: UseRoleProps): ElementProps;
+export declare function useRole<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseRoleProps): ElementProps;
 
 export declare interface UseRoleProps {
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
     enabled?: boolean;
-    /**
-     * The role of the floating element.
-     * @default 'dialog'
-     */
     role?: AriaRole | ComponentRole;
 }
 
@@ -1232,16 +720,12 @@ export declare interface UseRoleProps {
  * correctly handling placement-aware transitions.
  * @see https://floating-ui.com/docs/useTransition#usetransitionstatus
  */
-export declare function useTransitionStatus(context: FloatingContext, props?: UseTransitionStatusProps): {
+export declare function useTransitionStatus<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseTransitionStatusProps): {
     isMounted: boolean;
     status: Status;
 };
 
 export declare interface UseTransitionStatusProps {
-    /**
-     * The duration of the transition in milliseconds, or an object containing
-     * `open` and `close` keys for different durations.
-     */
     duration?: number | Partial<{
         open: number;
         close: number;
@@ -1255,27 +739,13 @@ export declare interface UseTransitionStatusProps {
  */
 export declare function useTransitionStyles<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseTransitionStylesProps): {
     isMounted: boolean;
-    styles: React.CSSProperties;
+    styles: React_2.CSSProperties;
 };
 
 export declare interface UseTransitionStylesProps extends UseTransitionStatusProps {
-    /**
-     * The styles to apply when the floating element is initially mounted.
-     */
     initial?: CSSStylesProperty;
-    /**
-     * The styles to apply when the floating element is transitioning to the
-     * `open` state.
-     */
     open?: CSSStylesProperty;
-    /**
-     * The styles to apply when the floating element is transitioning to the
-     * `close` state.
-     */
     close?: CSSStylesProperty;
-    /**
-     * The styles to apply to all states.
-     */
     common?: CSSStylesProperty;
 }
 
@@ -1284,53 +754,17 @@ export declare interface UseTransitionStylesProps extends UseTransitionStatusPro
  * types, often used in tandem with `useListNavigation()`.
  * @see https://floating-ui.com/docs/useTypeahead
  */
-export declare function useTypeahead(context: FloatingRootContext, props: UseTypeaheadProps): ElementProps;
+export declare function useTypeahead<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props: UseTypeaheadProps): ElementProps;
 
 export declare interface UseTypeaheadProps {
-    /**
-     * A ref which contains an array of strings whose indices match the HTML
-     * elements of the list.
-     * @default empty list
-     */
-    listRef: React.MutableRefObject<Array<string | null>>;
-    /**
-     * The index of the active (focused or highlighted) item in the list.
-     * @default null
-     */
+    listRef: React_2.MutableRefObject<Array<string | null>>;
     activeIndex: number | null;
-    /**
-     * Callback invoked with the matching index if found as the user types.
-     */
     onMatch?: (index: number) => void;
-    /**
-     * Callback invoked with the typing state as the user types.
-     */
     onTypingChange?: (isTyping: boolean) => void;
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
     enabled?: boolean;
-    /**
-     * A function that returns the matching string from the list.
-     * @default lowercase-finder
-     */
     findMatch?: null | ((list: Array<string | null>, typedString: string) => string | null | undefined);
-    /**
-     * The number of milliseconds to wait before resetting the typed string.
-     * @default 750
-     */
     resetMs?: number;
-    /**
-     * An array of keys to ignore when typing.
-     * @default []
-     */
     ignoreKeys?: Array<string>;
-    /**
-     * The index of the selected item in the list, if available.
-     * @default null
-     */
     selectedIndex?: number | null;
 }
 
diff --git a/node_modules/@floating-ui/react/dist/floating-ui.react.d.ts b/node_modules/@floating-ui/react/dist/floating-ui.react.d.ts
index b43cdac..3d0e149 100644
--- a/node_modules/@floating-ui/react/dist/floating-ui.react.d.ts
+++ b/node_modules/@floating-ui/react/dist/floating-ui.react.d.ts
@@ -41,7 +41,7 @@ import { Padding } from '@floating-ui/react-dom';
 import { Placement } from '@floating-ui/react-dom';
 import { Platform } from '@floating-ui/react-dom';
 import { platform } from '@floating-ui/react-dom';
-import * as React from 'react';
+import * as React_2 from 'react';
 import { Rect } from '@floating-ui/react-dom';
 import { ReferenceElement } from '@floating-ui/react-dom';
 import { RootBoundary } from '@floating-ui/react-dom';
@@ -84,72 +84,19 @@ export { ClientRectObject }
 
 declare type ComponentRole = 'select' | 'label' | 'combobox';
 
-/**
- * Creates a single tab stop whose items are navigated by arrow keys, which
- * provides list navigation outside of floating element contexts.
- *
- * This is useful to enable navigation of a list of items that aren’t part of a
- * floating element. A menubar is an example of a composite, with each reference
- * element being an item.
- * @see https://floating-ui.com/docs/Composite
- */
-export declare const Composite: React.ForwardRefExoticComponent<Omit<React.HTMLProps<HTMLElement> & CompositeProps, "ref"> & React.RefAttributes<HTMLElement>>;
+export declare const Composite: React_2.ForwardRefExoticComponent<Omit<React_2.HTMLProps<HTMLElement> & CompositeProps, "ref"> & React_2.RefAttributes<HTMLElement>>;
 
-/**
- * @see https://floating-ui.com/docs/Composite
- */
-export declare const CompositeItem: React.ForwardRefExoticComponent<Omit<React.HTMLProps<HTMLElement> & CompositeItemProps, "ref"> & React.RefAttributes<HTMLElement>>;
-
-declare interface CompositeItemProps {
-    /**
-     * Determines the element to render.
-     * @example
-     * ```jsx
-     * <CompositeItem render={<li />} />
-     * <CompositeItem render={(htmlProps) => <li {...htmlProps} />} />
-     * ```
-     */
-    render?: RenderProp;
-}
+export declare const CompositeItem: React_2.ForwardRefExoticComponent<Omit<React_2.HTMLProps<HTMLElement> & {
+    render?: RenderProp | undefined;
+}, "ref"> & React_2.RefAttributes<HTMLElement>>;
 
 declare interface CompositeProps {
-    /**
-     * Determines the element to render.
-     * @example
-     * ```jsx
-     * <Composite render={<ul />} />
-     * <Composite render={(htmlProps) => <ul {...htmlProps} />} />
-     * ```
-     */
     render?: RenderProp;
-    /**
-     * Determines the orientation of the composite.
-     */
     orientation?: 'horizontal' | 'vertical' | 'both';
-    /**
-     * Determines whether focus should loop around when navigating past the first
-     * or last item.
-     */
     loop?: boolean;
-    /**
-     * Determines the number of columns there are in the composite
-     * (i.e. it’s a grid).
-     */
     cols?: number;
-    /**
-     * Determines which items are disabled. The `disabled` or `aria-disabled`
-     * attributes are used by default.
-     */
     disabledIndices?: number[];
-    /**
-     * Determines which item is active. Used to externally control the active
-     * item.
-     */
     activeIndex?: number;
-    /**
-     * Called when the user navigates to a new item. Used to externally control
-     * the active item.
-     */
     onNavigate?(index: number): void;
     /**
      * Only for `cols > 1`, specify sizes for grid items.
@@ -171,7 +118,6 @@ export { ComputePositionReturn }
 
 export declare interface ContextData {
     openEvent?: Event;
-    floatingContext?: FloatingContext;
     /** @deprecated use `onTypingChange` prop in `useTypeahead` */
     typing?: boolean;
     [key: string]: any;
@@ -179,10 +125,10 @@ export declare interface ContextData {
 
 export { Coords }
 
-declare type CSSStylesProperty = React.CSSProperties | ((params: {
+declare type CSSStylesProperty = React_2.CSSProperties | ((params: {
     side: Side;
     placement: Placement;
-}) => React.CSSProperties);
+}) => React_2.CSSProperties);
 
 declare type Delay = number | Partial<{
     open: number;
@@ -198,9 +144,9 @@ export { Dimensions }
 export { ElementContext }
 
 export declare interface ElementProps {
-    reference?: React.HTMLProps<Element>;
-    floating?: React.HTMLProps<HTMLElement>;
-    item?: React.HTMLProps<HTMLElement> | ((props: ExtendedUserProps) => React.HTMLProps<HTMLElement>);
+    reference?: React_2.HTMLProps<Element>;
+    floating?: React_2.HTMLProps<HTMLElement>;
+    item?: React_2.HTMLProps<HTMLElement> | ((props: ExtendedUserProps) => React_2.HTMLProps<HTMLElement>);
 }
 
 export { ElementRects }
@@ -214,9 +160,9 @@ export declare interface ExtendedElements<RT> {
 }
 
 export declare interface ExtendedRefs<RT> {
-    reference: React.MutableRefObject<ReferenceType | null>;
-    floating: React.MutableRefObject<HTMLElement | null>;
-    domReference: React.MutableRefObject<NarrowedElement<RT> | null>;
+    reference: React_2.MutableRefObject<ReferenceType | null>;
+    floating: React_2.MutableRefObject<HTMLElement | null>;
+    domReference: React_2.MutableRefObject<NarrowedElement<RT> | null>;
     setReference(node: RT | null): void;
     setFloating(node: HTMLElement | null): void;
     setPositionReference(node: ReferenceType | null): void;
@@ -235,9 +181,9 @@ export { FlipOptions }
  * Renders a pointing arrow triangle.
  * @see https://floating-ui.com/docs/FloatingArrow
  */
-export declare const FloatingArrow: React.ForwardRefExoticComponent<Omit<FloatingArrowProps, "ref"> & React.RefAttributes<SVGSVGElement>>;
+export declare const FloatingArrow: React_2.ForwardRefExoticComponent<FloatingArrowProps & React_2.RefAttributes<SVGSVGElement>>;
 
-export declare interface FloatingArrowProps extends React.ComponentPropsWithRef<'svg'> {
+export declare interface FloatingArrowProps extends React_2.SVGAttributes<SVGSVGElement> {
     /**
      * The floating context.
      */
@@ -281,7 +227,7 @@ export declare type FloatingContext<RT extends ReferenceType = ReferenceType> =
     open: boolean;
     onOpenChange(open: boolean, event?: Event, reason?: OpenChangeReason): void;
     events: FloatingEvents;
-    dataRef: React.MutableRefObject<ContextData>;
+    dataRef: React_2.MutableRefObject<ContextData>;
     nodeId: string | undefined;
     floatingId: string;
     refs: ExtendedRefs<RT>;
@@ -293,20 +239,11 @@ export declare type FloatingContext<RT extends ReferenceType = ReferenceType> =
  * `delay`.
  * @see https://floating-ui.com/docs/FloatingDelayGroup
  */
-export declare function FloatingDelayGroup(props: FloatingDelayGroupProps): JSX.Element;
+export declare const FloatingDelayGroup: ({ children, delay, timeoutMs, }: FloatingDelayGroupProps) => JSX.Element;
 
 declare interface FloatingDelayGroupProps {
-    children?: React.ReactNode;
-    /**
-     * The delay to use for the group.
-     */
+    children?: React_2.ReactNode;
     delay: Delay;
-    /**
-     * An optional explicit timeout to use for the group, which represents when
-     * grouping logic will no longer be active after the close delay completes.
-     * This is useful if you want grouping to “last” longer than the close delay,
-     * for example if there is no close delay at all.
-     */
     timeoutMs?: number;
 }
 
@@ -322,69 +259,18 @@ export declare interface FloatingEvents {
  * Provides focus management for the floating element.
  * @see https://floating-ui.com/docs/FloatingFocusManager
  */
-export declare function FloatingFocusManager(props: FloatingFocusManagerProps): JSX.Element;
+export declare function FloatingFocusManager<RT extends ReferenceType = ReferenceType>(props: FloatingFocusManagerProps<RT>): JSX.Element;
 
-export declare interface FloatingFocusManagerProps {
+export declare interface FloatingFocusManagerProps<RT extends ReferenceType = ReferenceType> {
+    context: FloatingContext<RT>;
     children: JSX.Element;
-    /**
-     * The floating context returned from `useFloating`.
-     */
-    context: FloatingContext;
-    /**
-     * Whether or not the focus manager should be disabled. Useful to delay focus
-     * management until after a transition completes or some other conditional
-     * state.
-     * @default false
-     */
     disabled?: boolean;
-    /**
-     * The order in which focus cycles.
-     * @default ['content']
-     */
     order?: Array<'reference' | 'floating' | 'content'>;
-    /**
-     * Which element to initially focus. Can be either a number (tabbable index as
-     * specified by the `order`) or a ref.
-     * @default 0
-     */
-    initialFocus?: number | React.MutableRefObject<HTMLElement | null>;
-    /**
-     * Determines if the focus guards are rendered. If not, focus can escape into
-     * the address bar/console/browser UI, like in native dialogs.
-     * @default true
-     */
+    initialFocus?: number | React_2.MutableRefObject<HTMLElement | null>;
     guards?: boolean;
-    /**
-     * Determines if focus should be returned to the reference element once the
-     * floating element closes/unmounts (or if that is not available, the
-     * previously focused element). This prop is ignored if the floating element
-     * lost focus.
-     * @default true
-     */
     returnFocus?: boolean;
-    /**
-     * Determines if focus is “modal”, meaning focus is fully trapped inside the
-     * floating element and outside content cannot be accessed. This includes
-     * screen reader virtual cursors.
-     * @default true
-     */
     modal?: boolean;
-    /**
-     * If your focus management is modal and there is no explicit close button
-     * available, you can use this prop to render a visually-hidden dismiss
-     * button at the start and end of the floating element. This allows
-     * touch-based screen readers to escape the floating element due to lack of
-     * an `esc` key.
-     * @default undefined
-     */
     visuallyHiddenDismiss?: boolean | string;
-    /**
-     * Determines whether `focusout` event listeners that control whether the
-     * floating element should be closed if the focus moves outside of it are
-     * attached to the reference and floating elements. This affects non-modal
-     * focus management.
-     * @default true
-     */
     closeOnFocusOut?: boolean;
 }
 
@@ -392,28 +278,20 @@ export declare interface FloatingFocusManagerProps {
  * Provides context for a list of items within the floating element.
  * @see https://floating-ui.com/docs/FloatingList
  */
-export declare function FloatingList(props: FloatingListProps): JSX.Element;
+export declare function FloatingList({ children, elementsRef, labelsRef, }: FloatingListProps): JSX.Element;
 
 declare interface FloatingListProps {
-    children: React.ReactNode;
-    /**
-     * A ref to the list of HTML elements, ordered by their index.
-     * `useListNavigation`'s `listRef` prop.
-     */
-    elementsRef: React.MutableRefObject<Array<HTMLElement | null>>;
-    /**
-     * A ref to the list of element labels, ordered by their index.
-     * `useTypeahead`'s `listRef` prop.
-     */
-    labelsRef?: React.MutableRefObject<Array<string | null>>;
+    children: React_2.ReactNode;
+    elementsRef: React_2.MutableRefObject<Array<HTMLElement | null>>;
+    labelsRef?: React_2.MutableRefObject<Array<string | null>>;
 }
 
 /**
  * Provides parent node context for nested floating elements.
  * @see https://floating-ui.com/docs/FloatingTree
  */
-export declare function FloatingNode(props: {
-    children?: React.ReactNode;
+export declare function FloatingNode({ children, id, }: {
+    children?: React_2.ReactNode;
     id: string;
 }): JSX.Element;
 
@@ -429,77 +307,36 @@ export declare interface FloatingNodeType<RT extends ReferenceType = ReferenceTy
  * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.
  * @see https://floating-ui.com/docs/FloatingOverlay
  */
-export declare const FloatingOverlay: React.ForwardRefExoticComponent<Omit<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & FloatingOverlayProps & React.RefAttributes<HTMLDivElement>>;
-
-export declare interface FloatingOverlayProps {
-    /**
-     * Whether the overlay should lock scrolling on the document body.
-     * @default false
-     */
-    lockScroll?: boolean;
-}
+export declare const FloatingOverlay: React_2.ForwardRefExoticComponent<Omit<React_2.HTMLProps<HTMLDivElement> & {
+    lockScroll?: boolean | undefined;
+}, "ref"> & React_2.RefAttributes<HTMLDivElement>>;
 
 /**
  * Portals the floating element into a given container element — by default,
  * outside of the app root and into the body.
- * This is necessary to ensure the floating element can appear outside any
- * potential parent containers that cause clipping (such as `overflow: hidden`),
- * while retaining its location in the React tree.
  * @see https://floating-ui.com/docs/FloatingPortal
  */
-export declare function FloatingPortal(props: FloatingPortalProps): JSX.Element;
+export declare function FloatingPortal({ children, id, root, preserveTabOrder, }: FloatingPortalProps): JSX.Element;
 
 declare interface FloatingPortalProps {
-    children?: React.ReactNode;
-    /**
-     * Optionally selects the node with the id if it exists, or create it and
-     * append it to the specified `root` (by default `document.body`).
-     */
+    children?: React_2.ReactNode;
     id?: string;
-    /**
-     * Specifies the root node the portal container will be appended to.
-     */
-    root?: HTMLElement | null | React.MutableRefObject<HTMLElement | null>;
-    /**
-     * When using non-modal focus management using `FloatingFocusManager`, this
-     * will preserve the tab order context based on the React tree instead of the
-     * DOM tree.
-     */
+    root?: HTMLElement | null | React_2.MutableRefObject<HTMLElement | null>;
     preserveTabOrder?: boolean;
 }
 
-export declare interface FloatingRootContext<RT extends ReferenceType = ReferenceType> {
-    dataRef: React.MutableRefObject<ContextData>;
-    open: boolean;
-    onOpenChange: (open: boolean, event?: Event, reason?: OpenChangeReason) => void;
-    elements: {
-        domReference: Element | null;
-        reference: RT | null;
-        floating: HTMLElement | null;
-    };
-    events: FloatingEvents;
-    floatingId: string;
-    refs: {
-        setPositionReference(node: ReferenceType | null): void;
-    };
-}
-
 /**
  * Provides context for nested floating elements when they are not children of
- * each other on the DOM.
- * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:
- * - The `bubbles` option in the `useDismiss()` Hook
- * - Nested virtual list navigation
- * - Nested floating elements that each open on hover
- * - Custom communication between parent and child floating elements
+ * each other on the DOM (i.e. portalled to a common node, rather than their
+ * respective parent).
  * @see https://floating-ui.com/docs/FloatingTree
  */
-export declare function FloatingTree(props: {
-    children?: React.ReactNode;
+export declare function FloatingTree({ children, }: {
+    children?: React_2.ReactNode;
 }): JSX.Element;
 
 export declare interface FloatingTreeType<RT extends ReferenceType = ReferenceType> {
-    nodesRef: React.MutableRefObject<Array<FloatingNodeType<RT>>>;
+    nodesRef: React_2.MutableRefObject<Array<FloatingNodeType<RT>>>;
     events: FloatingEvents;
     addNode(node: FloatingNodeType): void;
     removeNode(node: FloatingNodeType): void;
@@ -508,8 +345,8 @@ export declare interface FloatingTreeType<RT extends ReferenceType = ReferenceTy
 export { getOverflowAncestors }
 
 declare interface GroupContext extends GroupState {
-    setCurrentId: React.Dispatch<React.SetStateAction<any>>;
-    setState: React.Dispatch<Partial<GroupState>>;
+    setCurrentId: React_2.Dispatch<React_2.SetStateAction<any>>;
+    setState: React_2.Dispatch<Partial<GroupState>>;
 }
 
 declare interface GroupState {
@@ -520,10 +357,10 @@ declare interface GroupState {
     isInstantPhase: boolean;
 }
 
-declare interface HandleCloseFn {
-    (context: FloatingContext & {
+declare interface HandleCloseFn<RT extends ReferenceType = ReferenceType> {
+    (context: FloatingContext<RT> & {
         onClose: () => void;
-        tree?: FloatingTreeType | null;
+        tree?: FloatingTreeType<RT> | null;
         leave?: boolean;
     }): (event: MouseEvent) => void;
     __options: {
@@ -547,45 +384,13 @@ export { InlineOptions }
 export declare const inner: (props: InnerProps & Partial<DetectOverflowOptions>) => Middleware;
 
 export declare interface InnerProps {
-    /**
-     * A ref which contains an array of HTML elements.
-     * @default empty list
-     */
-    listRef: React.MutableRefObject<Array<HTMLElement | null>>;
-    /**
-     * The index of the active (focused or highlighted) item in the list.
-     * @default 0
-     */
+    listRef: React_2.MutableRefObject<Array<HTMLElement | null>>;
     index: number;
-    /**
-     * Callback invoked when the fallback state changes.
-     */
     onFallbackChange?: null | ((fallback: boolean) => void);
-    /**
-     * The offset to apply to the floating element.
-     * @default 0
-     */
     offset?: number;
-    /**
-     * A ref which contains the overflow of the floating element.
-     */
-    overflowRef?: React.MutableRefObject<SideObject | null>;
-    /**
-     * An optional ref containing an HTMLElement. This may be used as the
-     * scrolling container instead of the floating element — for instance,
-     * to position inner elements as direct children without being interfered by
-     * scrolling layout.
-     */
-    scrollRef?: React.MutableRefObject<HTMLElement | null>;
-    /**
-     * The minimum number of items that should be visible in the list.
-     * @default 4
-     */
+    overflowRef?: React_2.MutableRefObject<SideObject | null>;
+    scrollRef?: React_2.MutableRefObject<HTMLElement | null>;
     minItemsVisible?: number;
-    /**
-     * The threshold for the reference element's overflow in pixels.
-     * @default 0
-     */
     referenceOverflowThreshold?: number;
 }
 
@@ -631,21 +436,21 @@ export { ReferenceElement }
 
 export declare type ReferenceType = Element | VirtualElement;
 
-declare type RenderProp = JSX.Element | ((props: React.HTMLAttributes<HTMLElement>) => JSX.Element);
+declare type RenderProp = JSX.Element | ((props: React_2.HTMLAttributes<HTMLElement>) => JSX.Element);
 
 export { RootBoundary }
 
 /**
  * Generates a safe polygon area that the user can traverse without closing the
  * floating element once leaving the reference element.
- * @see https://floating-ui.com/docs/useHover#safepolygon
+ * @see https://floating-ui.com/docs/useHover#safePolygon
  */
-export declare function safePolygon(options?: SafePolygonOptions): HandleCloseFn;
+export declare function safePolygon<RT extends ReferenceType = ReferenceType>(options?: Partial<SafePolygonOptions>): HandleCloseFn<RT>;
 
 declare interface SafePolygonOptions {
-    buffer?: number;
-    blockPointerEvents?: boolean;
-    requireIntent?: boolean;
+    buffer: number;
+    blockPointerEvents: boolean;
+    requireIntent: boolean;
 }
 
 declare const SELECTED_KEY = "selected";
@@ -670,41 +475,13 @@ export { Strategy }
  * Opens or closes the floating element when clicking the reference element.
  * @see https://floating-ui.com/docs/useClick
  */
-export declare function useClick(context: FloatingRootContext, props?: UseClickProps): ElementProps;
+export declare function useClick<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseClickProps): ElementProps;
 
 export declare interface UseClickProps {
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
     enabled?: boolean;
-    /**
-     * The type of event to use to determine a “click” with mouse input.
-     * Keyboard clicks work as normal.
-     * @default 'click'
-     */
     event?: 'click' | 'mousedown';
-    /**
-     * Whether to toggle the open state with repeated clicks.
-     * @default true
-     */
     toggle?: boolean;
-    /**
-     * Whether to ignore the logic for mouse input (for example, if `useHover()`
-     * is also being used).
-     * When `useHover()` and `useClick()` are used together, clicking the
-     * reference element after hovering it will keep the floating element open
-     * even once the cursor leaves. This may be not be desirable in some cases.
-     * @default false
-     */
     ignoreMouse?: boolean;
-    /**
-     * Whether to add keyboard handlers (Enter and Space key functionality) for
-     * non-button elements (to open/close the floating element via keyboard
-     * “click”).
-     * @default true
-     */
     keyboardHandlers?: boolean;
 }
 
@@ -713,45 +490,17 @@ export declare interface UseClickProps {
  * such as the mouse position. By default, it follows the mouse cursor.
  * @see https://floating-ui.com/docs/useClientPoint
  */
-export declare function useClientPoint(context: FloatingRootContext, props?: UseClientPointProps): ElementProps;
+export declare function useClientPoint<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseClientPointProps): ElementProps;
 
 export declare interface UseClientPointProps {
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
     enabled?: boolean;
-    /**
-     * Whether to restrict the client point to an axis and use the reference
-     * element (if it exists) as the other axis. This can be useful if the
-     * floating element is also interactive.
-     * @default 'both'
-     */
     axis?: 'x' | 'y' | 'both';
-    /**
-     * An explicitly defined `x` client coordinate.
-     * @default null
-     */
     x?: number | null;
-    /**
-     * An explicitly defined `y` client coordinate.
-     * @default null
-     */
     y?: number | null;
 }
 
-/**
- * Enables grouping when called inside a component that's a child of a
- * `FloatingDelayGroup`.
- * @see https://floating-ui.com/docs/FloatingDelayGroup
- */
-export declare function useDelayGroup(context: FloatingRootContext, options?: UseGroupOptions): GroupContext;
+export declare const useDelayGroup: ({ open, onOpenChange }: FloatingContext, { id }: UseGroupOptions) => void;
 
-/**
- * @deprecated
- * Use the return value of `useDelayGroup()` instead.
- */
 export declare const useDelayGroupContext: () => GroupContext;
 
 /**
@@ -759,74 +508,20 @@ export declare const useDelayGroupContext: () => GroupContext;
  * the user presses the `escape` key or outside of the floating element.
  * @see https://floating-ui.com/docs/useDismiss
  */
-export declare function useDismiss(context: FloatingRootContext, props?: UseDismissProps): ElementProps;
+export declare function useDismiss<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseDismissProps): ElementProps;
 
 export declare interface UseDismissProps {
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
     enabled?: boolean;
-    /**
-     * Whether to dismiss the floating element upon pressing the `esc` key.
-     * @default true
-     */
     escapeKey?: boolean;
-    /**
-     * Whether to dismiss the floating element upon pressing the reference
-     * element. You likely want to ensure the `move` option in the `useHover()`
-     * Hook has been disabled when this is in use.
-     * @default false
-     */
     referencePress?: boolean;
-    /**
-     * The type of event to use to determine a “press”.
-     * - `pointerdown` is eager on both mouse + touch input.
-     * - `mousedown` is eager on mouse input, but lazy on touch input.
-     * - `click` is lazy on both mouse + touch input.
-     * @default 'pointerdown'
-     */
     referencePressEvent?: 'pointerdown' | 'mousedown' | 'click';
-    /**
-     * Whether to dismiss the floating element upon pressing outside of the
-     * floating element.
-     * If you have another element, like a toast, that is rendered outside the
-     * floating element’s React tree and don’t want the floating element to close
-     * when pressing it, you can guard the check like so:
-     * ```jsx
-     * useDismiss(context, {
-     *   outsidePress: (event) => !event.target.closest('.toast'),
-     * });
-     * ```
-     * @default true
-     */
     outsidePress?: boolean | ((event: MouseEvent) => boolean);
-    /**
-     * The type of event to use to determine an outside “press”.
-     * - `pointerdown` is eager on both mouse + touch input.
-     * - `mousedown` is eager on mouse input, but lazy on touch input.
-     * - `click` is lazy on both mouse + touch input.
-     * @default 'pointerdown'
-     */
     outsidePressEvent?: 'pointerdown' | 'mousedown' | 'click';
-    /**
-     * Whether to dismiss the floating element upon scrolling an overflow
-     * ancestor.
-     * @default false
-     */
     ancestorScroll?: boolean;
-    /**
-     * Determines whether event listeners bubble upwards through a tree of
-     * floating elements.
-     */
     bubbles?: boolean | {
         escapeKey?: boolean;
         outsidePress?: boolean;
     };
-    /**
-     * Determines whether to use capture phase event listeners.
-     */
     capture?: boolean | {
         escapeKey?: boolean;
         outsidePress?: boolean;
@@ -837,18 +532,16 @@ export declare interface UseDismissProps {
  * Provides data to position a floating element and context to add interactions.
  * @see https://floating-ui.com/docs/useFloating
  */
-export declare function useFloating<RT extends ReferenceType = ReferenceType>(options?: UseFloatingOptions): UseFloatingReturn<RT>;
+export declare function useFloating<RT extends ReferenceType = ReferenceType>(options?: Partial<UseFloatingOptions>): UseFloatingReturn<RT>;
 
 export declare type UseFloatingData = Prettify<UseFloatingReturn>;
 
 /**
- * Registers a node into the `FloatingTree`, returning its id.
- * @see https://floating-ui.com/docs/FloatingTree
+ * Registers a node into the floating tree, returning its id.
  */
 export declare function useFloatingNodeId(customParentId?: string): string;
 
 export declare interface UseFloatingOptions<RT extends ReferenceType = ReferenceType> extends Omit<UseFloatingOptions_2<RT>, 'elements'> {
-    rootContext?: FloatingRootContext<RT>;
     /**
      * Object of external elements as an alternative to the `refs` object setters.
      */
@@ -873,46 +566,19 @@ export declare interface UseFloatingOptions<RT extends ReferenceType = Reference
     nodeId?: string;
 }
 
-/**
- * Returns the parent node id for nested floating elements, if available.
- * Returns `null` for top-level floating elements.
- */
 export declare const useFloatingParentNodeId: () => string | null;
 
-/**
- * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode
- */
-export declare function useFloatingPortalNode(props?: {
+export declare function useFloatingPortalNode({ id, root, }?: {
     id?: string;
-    root?: HTMLElement | null | React.MutableRefObject<HTMLElement | null>;
+    root?: HTMLElement | null | React_2.MutableRefObject<HTMLElement | null>;
 }): HTMLElement | null;
 
 export declare type UseFloatingReturn<RT extends ReferenceType = ReferenceType> = Prettify<UseFloatingReturn_2 & {
-    /**
-     * `FloatingContext`
-     */
     context: Prettify<FloatingContext<RT>>;
-    /**
-     * Object containing the reference and floating refs and reactive setters.
-     */
     refs: ExtendedRefs<RT>;
     elements: ExtendedElements<RT>;
 }>;
 
-export declare function useFloatingRootContext(options: UseFloatingRootContextOptions): FloatingRootContext;
-
-export declare interface UseFloatingRootContextOptions {
-    open?: boolean;
-    onOpenChange?: (open: boolean, event?: Event, reason?: OpenChangeReason) => void;
-    elements: {
-        reference: Element | null;
-        floating: HTMLElement | null;
-    };
-}
-
-/**
- * Returns the nearest floating tree context, if available.
- */
 export declare const useFloatingTree: <RT extends ReferenceType = ReferenceType>() => FloatingTreeType<RT> | null;
 
 /**
@@ -920,25 +586,15 @@ export declare const useFloatingTree: <RT extends ReferenceType = ReferenceType>
  * `:focus`.
  * @see https://floating-ui.com/docs/useFocus
  */
-export declare function useFocus(context: FloatingRootContext, props?: UseFocusProps): ElementProps;
+export declare function useFocus<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseFocusProps): ElementProps;
 
 export declare interface UseFocusProps {
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
     enabled?: boolean;
-    /**
-     * Whether the open state only changes if the focus event is considered
-     * visible (`:focus-visible` CSS selector).
-     * @default true
-     */
     visibleOnly?: boolean;
 }
 
 declare interface UseGroupOptions {
-    id?: any;
+    id: any;
 }
 
 /**
@@ -946,48 +602,17 @@ declare interface UseGroupOptions {
  * CSS `:hover`.
  * @see https://floating-ui.com/docs/useHover
  */
-export declare function useHover(context: FloatingRootContext, props?: UseHoverProps): ElementProps;
+export declare function useHover<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseHoverProps<RT>): ElementProps;
 
-export declare interface UseHoverProps {
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
+export declare interface UseHoverProps<RT extends ReferenceType = ReferenceType> {
     enabled?: boolean;
-    /**
-     * Instead of closing the floating element when the cursor leaves its
-     * reference, we can leave it open until a certain condition is satisfied,
-     * e.g. to let them traverse into the floating element.
-     * @default null
-     */
-    handleClose?: HandleCloseFn | null;
-    /**
-     * Waits until the user’s cursor is at “rest” over the reference element
-     *  before changing the `open` state.
-     * @default 0
-     */
+    handleClose?: HandleCloseFn<RT> | null;
     restMs?: number;
-    /**
-     * Waits for the specified time when the event listener runs before changing
-     * the `open` state.
-     * @default 0
-     */
     delay?: number | Partial<{
         open: number;
         close: number;
     }>;
-    /**
-     * Whether the logic only runs for mouse input, ignoring touch input.
-     * Note: due to a bug with Linux Chrome, "pen" inputs are considered "mouse".
-     * @default false
-     */
     mouseOnly?: boolean;
-    /**
-     * Whether moving the cursor over the floating element will open it, without a
-     * regular hover event required.
-     * @default true
-     */
     move?: boolean;
 }
 
@@ -995,7 +620,7 @@ export declare interface UseHoverProps {
  * Uses React 18's built-in `useId()` when available, or falls back to a
  * slightly less performant (requiring a double render) implementation for
  * earlier React versions.
- * @see https://floating-ui.com/docs/react-utils#useid
+ * @see https://floating-ui.com/docs/useId
  */
 export declare const useId: () => string;
 
@@ -1004,29 +629,12 @@ export declare const useId: () => string;
  * expand the floating element's height, revealing more list items.
  * @see https://floating-ui.com/docs/inner
  */
-export declare function useInnerOffset(context: FloatingRootContext, props: UseInnerOffsetProps): ElementProps;
+export declare function useInnerOffset(context: FloatingContext, props: UseInnerOffsetProps): ElementProps;
 
 export declare interface UseInnerOffsetProps {
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
     enabled?: boolean;
-    /**
-     * A ref which contains the overflow of the floating element.
-     */
-    overflowRef: React.MutableRefObject<SideObject | null>;
-    /**
-     * An optional ref containing an HTMLElement. This may be used as the
-     * scrolling container instead of the floating element — for instance,
-     * to position inner elements as direct children without being interfered by
-     * scrolling layout.
-     */
-    scrollRef?: React.MutableRefObject<HTMLElement | null>;
-    /**
-     * Callback invoked when the offset changes.
-     */
+    overflowRef: React_2.MutableRefObject<SideObject | null>;
+    scrollRef?: React_2.MutableRefObject<HTMLElement | null>;
     onChange: (offset: number | ((offset: number) => number)) => void;
 }
 
@@ -1036,20 +644,13 @@ export declare interface UseInnerOffsetProps {
  * another.
  * @see https://floating-ui.com/docs/useInteractions
  */
-export declare function useInteractions(propsList?: Array<ElementProps | void>): UseInteractionsReturn;
-
-export declare interface UseInteractionsReturn {
-    getReferenceProps: (userProps?: React.HTMLProps<Element>) => Record<string, unknown>;
-    getFloatingProps: (userProps?: React.HTMLProps<HTMLElement>) => Record<string, unknown>;
-    getItemProps: (userProps?: Omit<React.HTMLProps<HTMLElement>, 'selected' | 'active'> & ExtendedUserProps) => Record<string, unknown>;
-}
+export declare function useInteractions(propsList?: Array<ElementProps | void>): {
+    getReferenceProps: (userProps?: React_2.HTMLProps<Element>) => Record<string, unknown>;
+    getFloatingProps: (userProps?: React_2.HTMLProps<HTMLElement>) => Record<string, unknown>;
+    getItemProps: (userProps?: Omit<React_2.HTMLProps<HTMLElement>, 'selected' | 'active'> & ExtendedUserProps) => Record<string, unknown>;
+};
 
-/**
- * Used to register a list item and its index (DOM position) in the
- * `FloatingList`.
- * @see https://floating-ui.com/docs/FloatingList#uselistitem
- */
-export declare function useListItem(props?: UseListItemProps): {
+export declare function useListItem({ label }?: UseListItemProps): {
     ref: (node: HTMLElement | null) => void;
     index: number;
 };
@@ -1063,130 +664,27 @@ declare interface UseListItemProps {
  * focus or virtual focus.
  * @see https://floating-ui.com/docs/useListNavigation
  */
-export declare function useListNavigation(context: FloatingRootContext, props: UseListNavigationProps): ElementProps;
+export declare function useListNavigation<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props: UseListNavigationProps): ElementProps;
 
 export declare interface UseListNavigationProps {
-    /**
-     * A ref that holds an array of list items.
-     * @default empty list
-     */
-    listRef: React.MutableRefObject<Array<HTMLElement | null>>;
-    /**
-     * The index of the currently active (focused or highlighted) item, which may
-     * or may not be selected.
-     * @default null
-     */
+    listRef: React_2.MutableRefObject<Array<HTMLElement | null>>;
     activeIndex: number | null;
-    /**
-     * A callback that is called when the user navigates to a new active item,
-     * passed in a new `activeIndex`.
-     */
-    onNavigate?: (activeIndex: number | null) => void;
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
+    onNavigate?: (index: number | null) => void;
     enabled?: boolean;
-    /**
-     * The currently selected item index, which may or may not be active.
-     * @default null
-     */
     selectedIndex?: number | null;
-    /**
-     * Whether to focus the item upon opening the floating element. 'auto' infers
-     * what to do based on the input type (keyboard vs. pointer), while a boolean
-     * value will force the value.
-     * @default 'auto'
-     */
     focusItemOnOpen?: boolean | 'auto';
-    /**
-     * Whether hovering an item synchronizes the focus.
-     * @default true
-     */
     focusItemOnHover?: boolean;
-    /**
-     * Whether pressing an arrow key on the navigation’s main axis opens the
-     * floating element.
-     * @default true
-     */
     openOnArrowKeyDown?: boolean;
-    /**
-     * By default elements with either a `disabled` or `aria-disabled` attribute
-     * are skipped in the list navigation — however, this requires the items to
-     * be rendered.
-     * This prop allows you to manually specify indices which should be disabled,
-     * overriding the default logic.
-     * For Windows-style select menus, where the menu does not open when
-     * navigating via arrow keys, specify an empty array.
-     * @default undefined
-     */
     disabledIndices?: Array<number>;
-    /**
-     * Determines whether focus can escape the list, such that nothing is selected
-     * after navigating beyond the boundary of the list. In some
-     * autocomplete/combobox components, this may be desired, as screen
-     * readers will return to the input.
-     * `loop` must be `true`.
-     * @default false
-     */
     allowEscape?: boolean;
-    /**
-     * Determines whether focus should loop around when navigating past the first
-     * or last item.
-     * @default false
-     */
     loop?: boolean;
-    /**
-     * If the list is nested within another one (e.g. a nested submenu), the
-     * navigation semantics change.
-     * @default false
-     */
     nested?: boolean;
-    /**
-     * Whether the direction of the floating element’s navigation is in RTL
-     * layout.
-     * @default false
-     */
     rtl?: boolean;
-    /**
-     * Whether the focus is virtual (using `aria-activedescendant`).
-     * Use this if you need focus to remain on the reference element
-     * (such as an input), but allow arrow keys to navigate list items.
-     * This is common in autocomplete listbox components.
-     * Your virtually-focused list items must have a unique `id` set on them.
-     * If you’re using a component role with the `useRole()` Hook, then an `id` is
-     * generated automatically.
-     * @default false
-     */
     virtual?: boolean;
-    /**
-     * The orientation in which navigation occurs.
-     * @default 'vertical'
-     */
     orientation?: 'vertical' | 'horizontal' | 'both';
-    /**
-     * Specifies how many columns the list has (i.e., it’s a grid). Use an
-     * orientation of 'horizontal' (e.g. for an emoji picker/date picker, where
-     * pressing ArrowRight or ArrowLeft can change rows), or 'both' (where the
-     * current row cannot be escaped with ArrowRight or ArrowLeft, only ArrowUp
-     * and ArrowDown).
-     * @default 1
-     */
     cols?: number;
-    /**
-     * Whether to scroll the active item into view when navigating. The default
-     * value uses nearest options.
-     */
     scrollItemIntoView?: boolean | ScrollIntoViewOptions;
-    /**
-     * When using virtual focus management, this holds a ref to the
-     * virtually-focused item. This allows nested virtual navigation to be
-     * enabled, and lets you know when a nested element is virtually focused from
-     * the root reference handling the events. Requires `FloatingTree` to be
-     * setup.
-     */
-    virtualItemRef?: React.MutableRefObject<HTMLElement | null>;
+    virtualItemRef?: React_2.MutableRefObject<HTMLElement | null>;
     /**
      * Only for `cols > 1`, specify sizes for grid items.
      * `{ width: 2, height: 2 }` means an item is 2 columns wide and 2 rows tall.
@@ -1194,36 +692,26 @@ export declare interface UseListNavigationProps {
     itemSizes?: Dimensions[];
     /**
      * Only relevant for `cols > 1` and items with different sizes, specify if
-     * the grid is dense (as defined in the CSS spec for `grid-auto-flow`).
-     * @default false
+     * the grid is dense (as defined in the CSS spec for grid-auto-flow).
      */
     dense?: boolean;
 }
 
 /**
  * Merges an array of refs into a single memoized callback ref or `null`.
- * @see https://floating-ui.com/docs/react-utils#usemergerefs
+ * @see https://floating-ui.com/docs/useMergeRefs
  */
-export declare function useMergeRefs<Instance>(refs: Array<React.Ref<Instance> | undefined>): React.RefCallback<Instance> | null;
+export declare function useMergeRefs<Instance>(refs: Array<React_2.Ref<Instance> | undefined>): React_2.RefCallback<Instance> | null;
 
 /**
  * Adds base screen reader props to the reference and floating elements for a
  * given floating element `role`.
  * @see https://floating-ui.com/docs/useRole
  */
-export declare function useRole(context: FloatingRootContext, props?: UseRoleProps): ElementProps;
+export declare function useRole<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseRoleProps): ElementProps;
 
 export declare interface UseRoleProps {
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
     enabled?: boolean;
-    /**
-     * The role of the floating element.
-     * @default 'dialog'
-     */
     role?: AriaRole | ComponentRole;
 }
 
@@ -1232,16 +720,12 @@ export declare interface UseRoleProps {
  * correctly handling placement-aware transitions.
  * @see https://floating-ui.com/docs/useTransition#usetransitionstatus
  */
-export declare function useTransitionStatus(context: FloatingContext, props?: UseTransitionStatusProps): {
+export declare function useTransitionStatus<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseTransitionStatusProps): {
     isMounted: boolean;
     status: Status;
 };
 
 export declare interface UseTransitionStatusProps {
-    /**
-     * The duration of the transition in milliseconds, or an object containing
-     * `open` and `close` keys for different durations.
-     */
     duration?: number | Partial<{
         open: number;
         close: number;
@@ -1255,27 +739,13 @@ export declare interface UseTransitionStatusProps {
  */
 export declare function useTransitionStyles<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseTransitionStylesProps): {
     isMounted: boolean;
-    styles: React.CSSProperties;
+    styles: React_2.CSSProperties;
 };
 
 export declare interface UseTransitionStylesProps extends UseTransitionStatusProps {
-    /**
-     * The styles to apply when the floating element is initially mounted.
-     */
     initial?: CSSStylesProperty;
-    /**
-     * The styles to apply when the floating element is transitioning to the
-     * `open` state.
-     */
     open?: CSSStylesProperty;
-    /**
-     * The styles to apply when the floating element is transitioning to the
-     * `close` state.
-     */
     close?: CSSStylesProperty;
-    /**
-     * The styles to apply to all states.
-     */
     common?: CSSStylesProperty;
 }
 
@@ -1284,53 +754,17 @@ export declare interface UseTransitionStylesProps extends UseTransitionStatusPro
  * types, often used in tandem with `useListNavigation()`.
  * @see https://floating-ui.com/docs/useTypeahead
  */
-export declare function useTypeahead(context: FloatingRootContext, props: UseTypeaheadProps): ElementProps;
+export declare function useTypeahead<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props: UseTypeaheadProps): ElementProps;
 
 export declare interface UseTypeaheadProps {
-    /**
-     * A ref which contains an array of strings whose indices match the HTML
-     * elements of the list.
-     * @default empty list
-     */
-    listRef: React.MutableRefObject<Array<string | null>>;
-    /**
-     * The index of the active (focused or highlighted) item in the list.
-     * @default null
-     */
+    listRef: React_2.MutableRefObject<Array<string | null>>;
     activeIndex: number | null;
-    /**
-     * Callback invoked with the matching index if found as the user types.
-     */
     onMatch?: (index: number) => void;
-    /**
-     * Callback invoked with the typing state as the user types.
-     */
     onTypingChange?: (isTyping: boolean) => void;
-    /**
-     * Whether the Hook is enabled, including all internal Effects and event
-     * handlers.
-     * @default true
-     */
     enabled?: boolean;
-    /**
-     * A function that returns the matching string from the list.
-     * @default lowercase-finder
-     */
     findMatch?: null | ((list: Array<string | null>, typedString: string) => string | null | undefined);
-    /**
-     * The number of milliseconds to wait before resetting the typed string.
-     * @default 750
-     */
     resetMs?: number;
-    /**
-     * An array of keys to ignore when typing.
-     * @default []
-     */
     ignoreKeys?: Array<string>;
-    /**
-     * The index of the selected item in the list, if available.
-     * @default null
-     */
     selectedIndex?: number | null;
 }
 
diff --git a/node_modules/@floating-ui/react/dist/floating-ui.react.esm.js b/node_modules/@floating-ui/react/dist/floating-ui.react.esm.js
index 4aa9c86..99a6599 100644
--- a/node_modules/@floating-ui/react/dist/floating-ui.react.esm.js
+++ b/node_modules/@floating-ui/react/dist/floating-ui.react.esm.js
@@ -4,15 +4,16 @@ import { stopEvent, getDocument, isMouseLikePointerType, contains, activeElement
 import { floor } from '@floating-ui/utils';
 import { platform, getOverflowAncestors, useFloating as useFloating$1, offset, detectOverflow } from '@floating-ui/react-dom';
 export { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/react-dom';
-import { isElement, getNodeName, isHTMLElement, getWindow, isLastTraversableNode, getParentNode, getComputedStyle } from '@floating-ui/utils/dom';
-import { tabbable, isTabbable } from 'tabbable';
+import { isElement, isHTMLElement, getNodeName, getWindow, isLastTraversableNode, getParentNode, getComputedStyle } from '@floating-ui/utils/dom';
+import { tabbable } from 'tabbable';
 import { createPortal, flushSync } from 'react-dom';
 
 /**
  * Merges an array of refs into a single memoized callback ref or `null`.
- * @see https://floating-ui.com/docs/react-utils#usemergerefs
+ * @see https://floating-ui.com/docs/useMergeRefs
  */
 function useMergeRefs(refs) {
+  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
   return React.useMemo(() => {
     if (refs.every(ref => ref == null)) {
       return null;
@@ -26,16 +27,11 @@ function useMergeRefs(refs) {
         }
       });
     };
-    // eslint-disable-next-line react-hooks/exhaustive-deps
   }, refs);
 }
 
-// https://github.com/mui/material-ui/issues/41190#issuecomment-2040873379
-const SafeReact = {
-  ...React
-};
-
-const useInsertionEffect = SafeReact.useInsertionEffect;
+// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`
+const useInsertionEffect = React[/*#__PURE__*/'useInsertionEffect'.toString()];
 const useSafeInsertionEffect = useInsertionEffect || (fn => fn());
 function useEffectEvent(callback) {
   const ref = React.useRef(() => {
@@ -84,10 +80,14 @@ function findNonDisabledIndex(listRef, _temp) {
     amount = 1
   } = _temp === void 0 ? {} : _temp;
   const list = listRef.current;
+  const isDisabledIndex = disabledIndices ? index => disabledIndices.includes(index) : index => {
+    const element = list[index];
+    return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';
+  };
   let index = startingIndex;
   do {
     index += decrement ? -amount : amount;
-  } while (index >= 0 && index <= list.length - 1 && isDisabled(list, index, disabledIndices));
+  } while (index >= 0 && index <= list.length - 1 && isDisabledIndex(index));
   return index;
 }
 function getGridNavigatedIndex(elementsRef, _ref) {
@@ -183,8 +183,8 @@ function getGridNavigatedIndex(elementsRef, _ref) {
       if (prevIndex % cols !== 0) {
         nextIndex = findNonDisabledIndex(elementsRef, {
           startingIndex: prevIndex,
-          decrement: true,
-          disabledIndices
+          disabledIndices,
+          decrement: true
         });
         if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
           nextIndex = findNonDisabledIndex(elementsRef, {
@@ -263,20 +263,13 @@ function buildCellMap(sizes, cols, dense) {
 function getCellIndexOfCorner(index, sizes, cellMap, cols, corner) {
   if (index === -1) return -1;
   const firstCellIndex = cellMap.indexOf(index);
-  const sizeItem = sizes[index];
   switch (corner) {
     case 'tl':
       return firstCellIndex;
     case 'tr':
-      if (!sizeItem) {
-        return firstCellIndex;
-      }
-      return firstCellIndex + sizeItem.width - 1;
+      return firstCellIndex + sizes[index].width - 1;
     case 'bl':
-      if (!sizeItem) {
-        return firstCellIndex;
-      }
-      return firstCellIndex + (sizeItem.height - 1) * cols;
+      return firstCellIndex + (sizes[index].height - 1) * cols;
     case 'br':
       return cellMap.lastIndexOf(index);
   }
@@ -286,13 +279,6 @@ function getCellIndexOfCorner(index, sizes, cellMap, cols, corner) {
 function getCellIndices(indices, cellMap) {
   return cellMap.flatMap((index, cellIndex) => indices.includes(index) ? [cellIndex] : []);
 }
-function isDisabled(list, index, disabledIndices) {
-  if (disabledIndices) {
-    return disabledIndices.includes(index);
-  }
-  const element = list[index];
-  return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';
-}
 
 let rafId = 0;
 function enqueueFocus(el, options) {
@@ -350,12 +336,12 @@ const FloatingListContext = /*#__PURE__*/React.createContext({
  * Provides context for a list of items within the floating element.
  * @see https://floating-ui.com/docs/FloatingList
  */
-function FloatingList(props) {
-  const {
+function FloatingList(_ref) {
+  let {
     children,
     elementsRef,
     labelsRef
-  } = props;
+  } = _ref;
   const [map, setMap] = React.useState(() => new Map());
   const register = React.useCallback(node => {
     setMap(prevMap => new Map(prevMap).set(node, null));
@@ -387,18 +373,12 @@ function FloatingList(props) {
     }), [register, unregister, map, elementsRef, labelsRef])
   }, children);
 }
-/**
- * Used to register a list item and its index (DOM position) in the
- * `FloatingList`.
- * @see https://floating-ui.com/docs/FloatingList#uselistitem
- */
-function useListItem(props) {
-  if (props === void 0) {
-    props = {};
-  }
-  const {
+function useListItem(_temp) {
+  let {
     label
-  } = props;
+  } = _temp === void 0 ? {} : _temp;
+  const [index$1, setIndex] = React.useState(null);
+  const componentRef = React.useRef(null);
   const {
     register,
     unregister,
@@ -406,8 +386,6 @@ function useListItem(props) {
     elementsRef,
     labelsRef
   } = React.useContext(FloatingListContext);
-  const [index$1, setIndex] = React.useState(null);
-  const componentRef = React.useRef(null);
   const ref = React.useCallback(node => {
     componentRef.current = node;
     if (index$1 !== null) {
@@ -456,29 +434,19 @@ const CompositeContext = /*#__PURE__*/React.createContext({
 const horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];
 const verticalKeys = [ARROW_UP, ARROW_DOWN];
 const allKeys = [...horizontalKeys, ...verticalKeys];
-
-/**
- * Creates a single tab stop whose items are navigated by arrow keys, which
- * provides list navigation outside of floating element contexts.
- *
- * This is useful to enable navigation of a list of items that aren’t part of a
- * floating element. A menubar is an example of a composite, with each reference
- * element being an item.
- * @see https://floating-ui.com/docs/Composite
- */
-const Composite = /*#__PURE__*/React.forwardRef(function Composite(props, forwardedRef) {
-  const {
+const Composite = /*#__PURE__*/React.forwardRef(function Composite(_ref, forwardedRef) {
+  let {
     render,
     orientation = 'both',
     loop = true,
     cols = 1,
-    disabledIndices,
+    disabledIndices = [],
     activeIndex: externalActiveIndex,
     onNavigate: externalSetActiveIndex,
     itemSizes,
     dense = false,
-    ...domProps
-  } = props;
+    ...props
+  } = _ref;
   const [internalActiveIndex, internalSetActiveIndex] = React.useState(0);
   const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;
   const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);
@@ -492,21 +460,17 @@ const Composite = /*#__PURE__*/React.forwardRef(function Composite(props, forwar
   function handleKeyDown(event) {
     if (!allKeys.includes(event.key)) return;
     let nextIndex = activeIndex;
-    const minIndex = getMinIndex(elementsRef, disabledIndices);
-    const maxIndex = getMaxIndex(elementsRef, disabledIndices);
     if (isGrid) {
-      const sizes = itemSizes || Array.from({
-        length: elementsRef.current.length
-      }, () => ({
+      const sizes = itemSizes != null ? itemSizes : Array.from(Array(elementsRef.current.length), () => ({
         width: 1,
         height: 1
       }));
       // To calculate movements on the grid, we use hypothetical cell indices
       // as if every item was 1x1, then convert back to real indices.
       const cellMap = buildCellMap(sizes, cols, dense);
-      const minGridIndex = cellMap.findIndex(index => index != null && !isDisabled(elementsRef.current, index, disabledIndices));
+      const minGridIndex = cellMap.findIndex(index => index != null && !disabledIndices.includes(index));
       // last enabled index
-      const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !isDisabled(elementsRef.current, index, disabledIndices) ? cellIndex : foundIndex, -1);
+      const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);
       nextIndex = cellMap[getGridNavigatedIndex({
         current: cellMap.map(itemIndex => itemIndex ? elementsRef.current[itemIndex] : null)
       }, {
@@ -516,16 +480,18 @@ const Composite = /*#__PURE__*/React.forwardRef(function Composite(props, forwar
         cols,
         // treat undefined (empty grid spaces) as disabled indices so we
         // don't end up in them
-        disabledIndices: getCellIndices([...(disabledIndices || elementsRef.current.map((_, index) => isDisabled(elementsRef.current, index) ? index : undefined)), undefined], cellMap),
+        disabledIndices: getCellIndices([...disabledIndices, undefined], cellMap),
         minIndex: minGridIndex,
         maxIndex: maxGridIndex,
-        prevIndex: getCellIndexOfCorner(activeIndex > maxIndex ? minIndex : activeIndex, sizes, cellMap, cols,
+        prevIndex: getCellIndexOfCorner(activeIndex, sizes, cellMap, cols,
         // use a corner matching the edge closest to the direction we're
         // moving in so we don't end up in the same item. Prefer
         // top/left over bottom/right.
         event.key === ARROW_DOWN ? 'bl' : event.key === ARROW_RIGHT ? 'tr' : 'tl')
       })]; // navigated cell will never be nullish
     }
+    const minIndex = getMinIndex(elementsRef, disabledIndices);
+    const maxIndex = getMaxIndex(elementsRef, disabledIndices);
     const toEndKeys = {
       horizontal: [ARROW_RIGHT],
       vertical: [ARROW_DOWN],
@@ -568,12 +534,12 @@ const Composite = /*#__PURE__*/React.forwardRef(function Composite(props, forwar
     }
   }
   const computedProps = {
-    ...domProps,
+    ...props,
     ...renderElementProps,
     ref: forwardedRef,
     'aria-orientation': orientation === 'both' ? undefined : orientation,
     onKeyDown(e) {
-      domProps.onKeyDown == null || domProps.onKeyDown(e);
+      props.onKeyDown == null || props.onKeyDown(e);
       renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);
       handleKeyDown(e);
     }
@@ -584,14 +550,11 @@ const Composite = /*#__PURE__*/React.forwardRef(function Composite(props, forwar
     elementsRef: elementsRef
   }, renderJsx(render, computedProps)));
 });
-/**
- * @see https://floating-ui.com/docs/Composite
- */
-const CompositeItem = /*#__PURE__*/React.forwardRef(function CompositeItem(props, forwardedRef) {
-  const {
+const CompositeItem = /*#__PURE__*/React.forwardRef(function CompositeItem(_ref2, forwardedRef) {
+  let {
     render,
-    ...domProps
-  } = props;
+    ...props
+  } = _ref2;
   const renderElementProps = render && typeof render !== 'function' ? render.props : {};
   const {
     activeIndex,
@@ -604,13 +567,13 @@ const CompositeItem = /*#__PURE__*/React.forwardRef(function CompositeItem(props
   const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);
   const isActive = activeIndex === index;
   const computedProps = {
-    ...domProps,
+    ...props,
     ...renderElementProps,
     ref: mergedRef,
     tabIndex: isActive ? 0 : -1,
     'data-active': isActive ? '' : undefined,
     onFocus(e) {
-      domProps.onFocus == null || domProps.onFocus(e);
+      props.onFocus == null || props.onFocus(e);
       renderElementProps.onFocus == null || renderElementProps.onFocus(e);
       onNavigate(index);
     }
@@ -635,67 +598,41 @@ function _extends() {
 
 let serverHandoffComplete = false;
 let count = 0;
-const genId = () => // Ensure the id is unique with multiple independent versions of Floating UI
-// on <React 18
-"floating-ui-" + Math.random().toString(36).slice(2, 6) + count++;
+const genId = () => "floating-ui-" + count++;
 function useFloatingId() {
   const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : undefined);
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
   index(() => {
     if (id == null) {
       setId(genId());
     }
-    // eslint-disable-next-line react-hooks/exhaustive-deps
   }, []);
   React.useEffect(() => {
-    serverHandoffComplete = true;
+    if (!serverHandoffComplete) {
+      serverHandoffComplete = true;
+    }
   }, []);
   return id;
 }
-const useReactId = SafeReact.useId;
+
+// `toString()` prevents bundlers from trying to `import { useId } from 'react'`
+const useReactId = React[/*#__PURE__*/'useId'.toString()];
 
 /**
  * Uses React 18's built-in `useId()` when available, or falls back to a
  * slightly less performant (requiring a double render) implementation for
  * earlier React versions.
- * @see https://floating-ui.com/docs/react-utils#useid
+ * @see https://floating-ui.com/docs/useId
  */
 const useId = useReactId || useFloatingId;
 
-let devMessageSet;
-if (process.env.NODE_ENV !== "production") {
-  devMessageSet = /*#__PURE__*/new Set();
-}
-function warn() {
-  var _devMessageSet;
-  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
-    messages[_key] = arguments[_key];
-  }
-  const message = "Floating UI: " + messages.join(' ');
-  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {
-    var _devMessageSet2;
-    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);
-    console.warn(message);
-  }
-}
-function error() {
-  var _devMessageSet3;
-  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
-    messages[_key2] = arguments[_key2];
-  }
-  const message = "Floating UI: " + messages.join(' ');
-  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {
-    var _devMessageSet4;
-    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);
-    console.error(message);
-  }
-}
-
 /**
  * Renders a pointing arrow triangle.
  * @see https://floating-ui.com/docs/FloatingArrow
  */
-const FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(props, ref) {
-  const {
+const FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(_ref, ref) {
+  let {
     context: {
       placement,
       elements: {
@@ -717,10 +654,10 @@ const FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(props
       ...restStyle
     } = {},
     ...rest
-  } = props;
+  } = _ref;
   if (process.env.NODE_ENV !== "production") {
     if (!ref) {
-      warn('The `ref` prop is required for `FloatingArrow`.');
+      console.warn('Floating UI: The `ref` prop is required for the `FloatingArrow`', 'component.');
     }
   }
   const clipPathId = useId();
@@ -730,8 +667,8 @@ const FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(props
 
   // Strokes must be double the border width, this ensures the stroke's width
   // works as you'd expect.
-  const computedStrokeWidth = strokeWidth * 2;
-  const halfStrokeWidth = computedStrokeWidth / 2;
+  strokeWidth *= 2;
+  const halfStrokeWidth = strokeWidth / 2;
   const svgX = width / 2 * (tipRadius / -8 + 1);
   const svgY = height / 2 * tipRadius / 4;
   const [side, alignment] = placement.split('-');
@@ -745,7 +682,9 @@ const FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(props
   }
   const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : '';
   const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y : '';
-  const dValue = d || 'M0,0' + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + ' Z';
+  const dValue = d ||
+  // biome-ignore lint/style/useTemplate: readability
+  'M0,0' + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + ' Z';
   const rotation = {
     top: isCustomShape ? 'rotate(180deg)' : '',
     left: isCustomShape ? 'rotate(90deg)' : 'rotate(-90deg)',
@@ -755,7 +694,7 @@ const FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(props
   return /*#__PURE__*/React.createElement("svg", _extends({}, rest, {
     "aria-hidden": true,
     ref: ref,
-    width: isCustomShape ? width : width + computedStrokeWidth,
+    width: isCustomShape ? width : width + strokeWidth,
     height: width,
     viewBox: "0 0 " + width + " " + (height > width ? height : width),
     style: {
@@ -763,27 +702,27 @@ const FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(props
       pointerEvents: 'none',
       [xOffsetProp]: arrowX,
       [yOffsetProp]: arrowY,
-      [side]: isVerticalSide || isCustomShape ? '100%' : "calc(100% - " + computedStrokeWidth / 2 + "px)",
+      [side]: isVerticalSide || isCustomShape ? '100%' : "calc(100% - " + strokeWidth / 2 + "px)",
       transform: "" + rotation + (transform != null ? transform : ''),
       ...restStyle
     }
-  }), computedStrokeWidth > 0 && /*#__PURE__*/React.createElement("path", {
+  }), strokeWidth > 0 && /*#__PURE__*/React.createElement("path", {
     clipPath: "url(#" + clipPathId + ")",
     fill: "none",
     stroke: stroke
     // Account for the stroke on the fill path rendered below.
     ,
-    strokeWidth: computedStrokeWidth + (d ? 0 : 1),
+    strokeWidth: strokeWidth + (d ? 0 : 1),
     d: dValue
   }), /*#__PURE__*/React.createElement("path", {
-    stroke: computedStrokeWidth && !d ? rest.fill : 'none',
+    stroke: strokeWidth && !d ? rest.fill : 'none',
     d: dValue
   }), /*#__PURE__*/React.createElement("clipPath", {
     id: clipPathId
   }, /*#__PURE__*/React.createElement("rect", {
     x: -halfStrokeWidth,
     y: halfStrokeWidth * (isCustomShape ? -1 : 1),
-    width: width + computedStrokeWidth,
+    width: width + strokeWidth,
     height: width
   })));
 });
@@ -807,24 +746,14 @@ function createPubSub() {
 
 const FloatingNodeContext = /*#__PURE__*/React.createContext(null);
 const FloatingTreeContext = /*#__PURE__*/React.createContext(null);
-
-/**
- * Returns the parent node id for nested floating elements, if available.
- * Returns `null` for top-level floating elements.
- */
 const useFloatingParentNodeId = () => {
   var _React$useContext;
   return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
 };
-
-/**
- * Returns the nearest floating tree context, if available.
- */
 const useFloatingTree = () => React.useContext(FloatingTreeContext);
 
 /**
- * Registers a node into the `FloatingTree`, returning its id.
- * @see https://floating-ui.com/docs/FloatingTree
+ * Registers a node into the floating tree, returning its id.
  */
 function useFloatingNodeId(customParentId) {
   const id = useId();
@@ -848,11 +777,11 @@ function useFloatingNodeId(customParentId) {
  * Provides parent node context for nested floating elements.
  * @see https://floating-ui.com/docs/FloatingTree
  */
-function FloatingNode(props) {
-  const {
+function FloatingNode(_ref) {
+  let {
     children,
     id
-  } = props;
+  } = _ref;
   const parentId = useFloatingParentNodeId();
   return /*#__PURE__*/React.createElement(FloatingNodeContext.Provider, {
     value: React.useMemo(() => ({
@@ -864,18 +793,14 @@ function FloatingNode(props) {
 
 /**
  * Provides context for nested floating elements when they are not children of
- * each other on the DOM.
- * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:
- * - The `bubbles` option in the `useDismiss()` Hook
- * - Nested virtual list navigation
- * - Nested floating elements that each open on hover
- * - Custom communication between parent and child floating elements
+ * each other on the DOM (i.e. portalled to a common node, rather than their
+ * respective parent).
  * @see https://floating-ui.com/docs/FloatingTree
  */
-function FloatingTree(props) {
-  const {
+function FloatingTree(_ref2) {
+  let {
     children
-  } = props;
+  } = _ref2;
   const nodesRef = React.useRef([]);
   const addNode = React.useCallback(node => {
     nodesRef.current = [...nodesRef.current, node];
@@ -933,7 +858,8 @@ function useHover(context, props) {
     elements: {
       domReference,
       floating
-    }
+    },
+    refs
   } = context;
   const {
     enabled = true,
@@ -948,9 +874,9 @@ function useHover(context, props) {
   const handleCloseRef = useLatestRef(handleClose);
   const delayRef = useLatestRef(delay);
   const pointerTypeRef = React.useRef();
-  const timeoutRef = React.useRef(-1);
+  const timeoutRef = React.useRef();
   const handlerRef = React.useRef();
-  const restTimeoutRef = React.useRef(-1);
+  const restTimeoutRef = React.useRef();
   const blockMouseMoveRef = React.useRef(true);
   const performedPointerEventsMutationRef = React.useRef(false);
   const unbindMouseMoveRef = React.useRef(() => {});
@@ -1006,24 +932,24 @@ function useHover(context, props) {
     const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);
     if (closeDelay && !handlerRef.current) {
       clearTimeout(timeoutRef.current);
-      timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);
+      timeoutRef.current = setTimeout(() => onOpenChange(false, event, reason), closeDelay);
     } else if (runElseBranch) {
       clearTimeout(timeoutRef.current);
       onOpenChange(false, event, reason);
     }
   }, [delayRef, onOpenChange]);
-  const cleanupMouseMoveHandler = useEffectEvent(() => {
+  const cleanupMouseMoveHandler = React.useCallback(() => {
     unbindMouseMoveRef.current();
     handlerRef.current = undefined;
-  });
-  const clearPointerEvents = useEffectEvent(() => {
+  }, []);
+  const clearPointerEvents = React.useCallback(() => {
     if (performedPointerEventsMutationRef.current) {
-      const body = getDocument(floating).body;
+      const body = getDocument(refs.floating.current).body;
       body.style.pointerEvents = '';
       body.removeAttribute(safePolygonIdentifier);
       performedPointerEventsMutationRef.current = false;
     }
-  });
+  }, [refs]);
 
   // Registering the mouse events on the reference directly to bypass React's
   // delegation system. If the cursor was on a disabled element and then entered
@@ -1038,12 +964,12 @@ function useHover(context, props) {
     function onMouseEnter(event) {
       clearTimeout(timeoutRef.current);
       blockMouseMoveRef.current = false;
-      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && !getDelay(delayRef.current, 'open')) {
+      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {
         return;
       }
       const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);
       if (openDelay) {
-        timeoutRef.current = window.setTimeout(() => {
+        timeoutRef.current = setTimeout(() => {
           onOpenChange(true, event, 'hover');
         }, openDelay);
       } else {
@@ -1051,17 +977,19 @@ function useHover(context, props) {
       }
     }
     function onMouseLeave(event) {
-      if (isClickLikeOpenEvent()) return;
+      if (isClickLikeOpenEvent()) {
+        return;
+      }
       unbindMouseMoveRef.current();
       const doc = getDocument(floating);
       clearTimeout(restTimeoutRef.current);
-      if (handleCloseRef.current && dataRef.current.floatingContext) {
+      if (handleCloseRef.current) {
         // Prevent clearing `onScrollMouseLeave` timeout.
         if (!open) {
           clearTimeout(timeoutRef.current);
         }
         handlerRef.current = handleCloseRef.current({
-          ...dataRef.current.floatingContext,
+          ...context,
           tree,
           x: event.clientX,
           y: event.clientY,
@@ -1092,10 +1020,11 @@ function useHover(context, props) {
     // did not move.
     // https://github.com/floating-ui/floating-ui/discussions/1692
     function onScrollMouseLeave(event) {
-      if (isClickLikeOpenEvent()) return;
-      if (!dataRef.current.floatingContext) return;
+      if (isClickLikeOpenEvent()) {
+        return;
+      }
       handleCloseRef.current == null || handleCloseRef.current({
-        ...dataRef.current.floatingContext,
+        ...context,
         tree,
         x: event.clientX,
         y: event.clientY,
@@ -1162,6 +1091,8 @@ function useHover(context, props) {
       clearPointerEvents();
     }
   }, [open, cleanupMouseMoveHandler, clearPointerEvents]);
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
   React.useEffect(() => {
     return () => {
       cleanupMouseMoveHandler();
@@ -1182,23 +1113,15 @@ function useHover(context, props) {
         onPointerDown: setPointerRef,
         onPointerEnter: setPointerRef,
         onMouseMove(event) {
-          function handleMouseMove() {
-            if (!blockMouseMoveRef.current) {
-              onOpenChange(true, event.nativeEvent, 'hover');
-            }
-          }
-          if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) {
-            return;
-          }
           if (open || restMs === 0) {
             return;
           }
           clearTimeout(restTimeoutRef.current);
-          if (pointerTypeRef.current === 'touch') {
-            handleMouseMove();
-          } else {
-            restTimeoutRef.current = window.setTimeout(handleMouseMove, restMs);
-          }
+          restTimeoutRef.current = setTimeout(() => {
+            if (!blockMouseMoveRef.current) {
+              onOpenChange(true, event.nativeEvent, 'hover');
+            }
+          }, restMs);
         }
       },
       floating: {
@@ -1210,36 +1133,30 @@ function useHover(context, props) {
         }
       }
     };
-  }, [enabled, mouseOnly, open, restMs, onOpenChange, closeWithDelay]);
+  }, [enabled, restMs, open, onOpenChange, closeWithDelay]);
 }
 
-const NOOP = () => {};
 const FloatingDelayGroupContext = /*#__PURE__*/React.createContext({
   delay: 0,
   initialDelay: 0,
   timeoutMs: 0,
   currentId: null,
-  setCurrentId: NOOP,
-  setState: NOOP,
+  setCurrentId: () => {},
+  setState: () => {},
   isInstantPhase: false
 });
-
-/**
- * @deprecated
- * Use the return value of `useDelayGroup()` instead.
- */
 const useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);
 /**
  * Provides context for a group of floating elements that should share a
  * `delay`.
  * @see https://floating-ui.com/docs/FloatingDelayGroup
  */
-function FloatingDelayGroup(props) {
-  const {
+const FloatingDelayGroup = _ref => {
+  let {
     children,
     delay,
     timeoutMs = 0
-  } = props;
+  } = _ref;
   const [state, setState] = React.useReducer((prev, next) => ({
     ...prev,
     ...next
@@ -1260,20 +1177,18 @@ function FloatingDelayGroup(props) {
     if (state.currentId) {
       if (initialCurrentIdRef.current === null) {
         initialCurrentIdRef.current = state.currentId;
-      } else if (!state.isInstantPhase) {
+      } else {
         setState({
           isInstantPhase: true
         });
       }
     } else {
-      if (state.isInstantPhase) {
-        setState({
-          isInstantPhase: false
-        });
-      }
+      setState({
+        isInstantPhase: false
+      });
       initialCurrentIdRef.current = null;
     }
-  }, [state.currentId, state.isInstantPhase]);
+  }, [state.currentId]);
   return /*#__PURE__*/React.createElement(FloatingDelayGroupContext.Provider, {
     value: React.useMemo(() => ({
       ...state,
@@ -1281,43 +1196,33 @@ function FloatingDelayGroup(props) {
       setCurrentId
     }), [state, setCurrentId])
   }, children);
-}
-/**
- * Enables grouping when called inside a component that's a child of a
- * `FloatingDelayGroup`.
- * @see https://floating-ui.com/docs/FloatingDelayGroup
- */
-function useDelayGroup(context, options) {
-  if (options === void 0) {
-    options = {};
-  }
-  const {
+};
+const useDelayGroup = (_ref2, _ref3) => {
+  let {
     open,
-    onOpenChange,
-    floatingId
-  } = context;
-  const {
-    id: optionId
-  } = options;
-  const id = optionId != null ? optionId : floatingId;
-  const groupContext = useDelayGroupContext();
+    onOpenChange
+  } = _ref2;
+  let {
+    id
+  } = _ref3;
   const {
     currentId,
     setCurrentId,
     initialDelay,
     setState,
     timeoutMs
-  } = groupContext;
+  } = useDelayGroupContext();
   index(() => {
-    if (!currentId) return;
-    setState({
-      delay: {
-        open: 1,
-        close: getDelay(initialDelay, 'close')
+    if (currentId) {
+      setState({
+        delay: {
+          open: 1,
+          close: getDelay(initialDelay, 'close')
+        }
+      });
+      if (currentId !== id) {
+        onOpenChange(false);
       }
-    });
-    if (currentId !== id) {
-      onOpenChange(false);
     }
   }, [id, onOpenChange, setState, currentId, initialDelay]);
   index(() => {
@@ -1328,7 +1233,6 @@ function useDelayGroup(context, options) {
         currentId: null
       });
     }
-    if (!currentId) return;
     if (!open && currentId === id) {
       if (timeoutMs) {
         const timeout = window.setTimeout(unset, timeoutMs);
@@ -1340,11 +1244,11 @@ function useDelayGroup(context, options) {
     }
   }, [open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);
   index(() => {
-    if (setCurrentId === NOOP || !open) return;
-    setCurrentId(id);
+    if (open) {
+      setCurrentId(id);
+    }
   }, [open, setCurrentId, id]);
-  return groupContext;
-}
+};
 
 function getAncestors(nodes, id) {
   var _nodes$find;
@@ -1438,8 +1342,7 @@ function applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, iner
     if (!parent || elementsToStop.has(parent)) {
       return;
     }
-    [].forEach.call(parent.children, node => {
-      if (getNodeName(node) === 'script') return;
+    Array.prototype.forEach.call(parent.children, node => {
       if (elementsToKeep.has(node)) {
         deep(node);
       } else {
@@ -1538,6 +1441,7 @@ function enableFocusInside(container) {
   const elements = container.querySelectorAll('[data-tabindex]');
   elements.forEach(element => {
     const tabindex = element.dataset.tabindex;
+    // biome-ignore lint/performance/noDelete: purity
     delete element.dataset.tabindex;
     if (tabindex) {
       element.setAttribute('tabindex', tabindex);
@@ -1599,86 +1503,77 @@ const FocusGuard = /*#__PURE__*/React.forwardRef(function FocusGuard(props, ref)
 });
 
 const PortalContext = /*#__PURE__*/React.createContext(null);
-const attr = /*#__PURE__*/createAttribute('portal');
-
-/**
- * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode
- */
-function useFloatingPortalNode(props) {
-  if (props === void 0) {
-    props = {};
-  }
-  const {
+function useFloatingPortalNode(_temp) {
+  let {
     id,
     root
-  } = props;
+  } = _temp === void 0 ? {} : _temp;
+  const [portalNode, setPortalNode] = React.useState(null);
   const uniqueId = useId();
   const portalContext = usePortalContext();
-  const [portalNode, setPortalNode] = React.useState(null);
-  const portalNodeRef = React.useRef(null);
+  const data = React.useMemo(() => ({
+    id,
+    root,
+    portalContext,
+    uniqueId
+  }), [id, root, portalContext, uniqueId]);
+  const dataRef = React.useRef();
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: `data` is intentionally specified
   index(() => {
     return () => {
       portalNode == null || portalNode.remove();
-      // Allow the subsequent layout effects to create a new node on updates.
-      // The portal node will still be cleaned up on unmount.
-      // https://github.com/floating-ui/floating-ui/issues/2454
-      queueMicrotask(() => {
-        portalNodeRef.current = null;
-      });
     };
-  }, [portalNode]);
+  }, [portalNode, data]);
   index(() => {
-    // Wait for the uniqueId to be generated before creating the portal node in
-    // React <18 (using `useFloatingId` instead of the native `useId`).
-    // https://github.com/floating-ui/floating-ui/issues/2778
-    if (!uniqueId) return;
-    if (portalNodeRef.current) return;
+    if (dataRef.current === data) return;
+    dataRef.current = data;
+    const {
+      id,
+      root,
+      portalContext,
+      uniqueId
+    } = data;
     const existingIdRoot = id ? document.getElementById(id) : null;
-    if (!existingIdRoot) return;
-    const subRoot = document.createElement('div');
-    subRoot.id = uniqueId;
-    subRoot.setAttribute(attr, '');
-    existingIdRoot.appendChild(subRoot);
-    portalNodeRef.current = subRoot;
-    setPortalNode(subRoot);
-  }, [id, uniqueId]);
-  index(() => {
-    if (!uniqueId) return;
-    if (portalNodeRef.current) return;
-    let container = root || (portalContext == null ? void 0 : portalContext.portalNode);
-    if (container && !isElement(container)) container = container.current;
-    container = container || document.body;
-    let idWrapper = null;
-    if (id) {
-      idWrapper = document.createElement('div');
-      idWrapper.id = id;
-      container.appendChild(idWrapper);
-    }
-    const subRoot = document.createElement('div');
-    subRoot.id = uniqueId;
-    subRoot.setAttribute(attr, '');
-    container = idWrapper || container;
-    container.appendChild(subRoot);
-    portalNodeRef.current = subRoot;
-    setPortalNode(subRoot);
-  }, [id, root, uniqueId, portalContext]);
+    const attr = createAttribute('portal');
+    if (existingIdRoot) {
+      const subRoot = document.createElement('div');
+      subRoot.id = uniqueId;
+      subRoot.setAttribute(attr, '');
+      existingIdRoot.appendChild(subRoot);
+      setPortalNode(subRoot);
+    } else {
+      let container = root || (portalContext == null ? void 0 : portalContext.portalNode);
+      if (container && !isElement(container)) container = container.current;
+      container = container || document.body;
+      let idWrapper = null;
+      if (id) {
+        idWrapper = document.createElement('div');
+        idWrapper.id = id;
+        container.appendChild(idWrapper);
+      }
+      const subRoot = document.createElement('div');
+      subRoot.id = uniqueId;
+      subRoot.setAttribute(attr, '');
+      container = idWrapper || container;
+      container.appendChild(subRoot);
+      setPortalNode(subRoot);
+    }
+  }, [data]);
   return portalNode;
 }
 /**
  * Portals the floating element into a given container element — by default,
  * outside of the app root and into the body.
- * This is necessary to ensure the floating element can appear outside any
- * potential parent containers that cause clipping (such as `overflow: hidden`),
- * while retaining its location in the React tree.
  * @see https://floating-ui.com/docs/FloatingPortal
  */
-function FloatingPortal(props) {
-  const {
+function FloatingPortal(_ref) {
+  let {
     children,
     id,
     root = null,
     preserveTabOrder = true
-  } = props;
+  } = _ref;
   const portalNode = useFloatingPortalNode({
     id,
     root
@@ -1768,18 +1663,12 @@ const LIST_LIMIT = 20;
 let previouslyFocusedElements = [];
 function addPreviouslyFocusedElement(element) {
   previouslyFocusedElements = previouslyFocusedElements.filter(el => el.isConnected);
-  let tabbableEl = element;
-  if (!tabbableEl || getNodeName(tabbableEl) === 'body') return;
-  if (!isTabbable(tabbableEl, getTabbableOptions())) {
-    const tabbableChild = tabbable(tabbableEl, getTabbableOptions())[0];
-    if (tabbableChild) {
-      tabbableEl = tabbableChild;
+  if (element && getNodeName(element) !== 'body') {
+    previouslyFocusedElements.push(element);
+    if (previouslyFocusedElements.length > LIST_LIMIT) {
+      previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);
     }
   }
-  previouslyFocusedElements.push(tabbableEl);
-  if (previouslyFocusedElements.length > LIST_LIMIT) {
-    previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);
-  }
 }
 function getPreviouslyFocusedElement() {
   return previouslyFocusedElements.slice().reverse().find(el => el.isConnected);
@@ -1969,21 +1858,16 @@ function FloatingFocusManager(props) {
     const doc = getDocument(floating);
     const previouslyFocusedElement = activeElement(doc);
     const contextData = dataRef.current;
-    let openEvent = contextData.openEvent;
     addPreviouslyFocusedElement(previouslyFocusedElement);
 
     // Dismissing via outside press should always ignore `returnFocus` to
     // prevent unwanted scrolling.
     function onOpenChange(_ref) {
       let {
-        open,
         reason,
         event,
         nested
       } = _ref;
-      if (open) {
-        openEvent = event;
-      }
       if (reason === 'escape-key' && refs.domReference.current) {
         addPreviouslyFocusedElement(refs.domReference.current);
       }
@@ -2006,14 +1890,12 @@ function FloatingFocusManager(props) {
         var _node$context5;
         return contains((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);
       });
-      const shouldFocusReference = isFocusInsideFloatingTree || openEvent && ['click', 'mousedown'].includes(openEvent.type);
+      const shouldFocusReference = isFocusInsideFloatingTree || contextData.openEvent && ['click', 'mousedown'].includes(contextData.openEvent.type);
       if (shouldFocusReference && refs.domReference.current) {
         addPreviouslyFocusedElement(refs.domReference.current);
       }
       const returnElement = getPreviouslyFocusedElement();
-      if (
-      // eslint-disable-next-line react-hooks/exhaustive-deps
-      returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(returnElement) && (
+      if (returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(returnElement) && (
       // If the focus moved somewhere else after mount, avoid returning focus
       // since it likely entered a different element which should be
       // respected: https://github.com/floating-ui/floating-ui/issues/2607
@@ -2121,17 +2003,18 @@ function FloatingFocusManager(props) {
 }
 
 const activeLocks = /*#__PURE__*/new Set();
+
 /**
  * Provides base styling for a fixed overlay element to dim content or block
  * pointer events behind a floating element.
  * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.
  * @see https://floating-ui.com/docs/FloatingOverlay
  */
-const FloatingOverlay = /*#__PURE__*/React.forwardRef(function FloatingOverlay(props, ref) {
-  const {
+const FloatingOverlay = /*#__PURE__*/React.forwardRef(function FloatingOverlay(_ref, ref) {
+  let {
     lockScroll = false,
     ...rest
-  } = props;
+  } = _ref;
   const lockId = useId();
   index(() => {
     if (!lockScroll) return;
@@ -2305,15 +2188,15 @@ function useClick(context, props) {
   }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);
 }
 
-function createVirtualElement(domElement, data) {
+function createVirtualElement(domRef, data) {
   let offsetX = null;
   let offsetY = null;
   let isAutoUpdateEvent = false;
   return {
-    contextElement: domElement || undefined,
+    contextElement: domRef.current || undefined,
     getBoundingClientRect() {
-      var _data$dataRef$current;
-      const domRect = (domElement == null ? void 0 : domElement.getBoundingClientRect()) || {
+      var _domRef$current, _data$dataRef$current;
+      const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {
         width: 0,
         height: 0,
         x: 0,
@@ -2373,12 +2256,11 @@ function useClientPoint(context, props) {
   }
   const {
     open,
+    refs,
     dataRef,
     elements: {
-      floating,
-      domReference
-    },
-    refs
+      floating
+    }
   } = context;
   const {
     enabled = true,
@@ -2399,7 +2281,7 @@ function useClientPoint(context, props) {
     if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {
       return;
     }
-    refs.setPositionReference(createVirtualElement(domReference, {
+    refs.setPositionReference(createVirtualElement(refs.domReference, {
       x,
       y,
       axis,
@@ -2427,10 +2309,10 @@ function useClientPoint(context, props) {
   const addListener = React.useCallback(() => {
     // Explicitly specified `x`/`y` coordinates shouldn't add a listener.
     if (!openCheck || !enabled || x != null || y != null) return;
-    const win = getWindow(floating);
+    const win = getWindow(refs.floating.current);
     function handleMouseMove(event) {
       const target = getTarget(event);
-      if (!contains(floating, target)) {
+      if (!contains(refs.floating.current, target)) {
         setReference(event.clientX, event.clientY);
       } else {
         win.removeEventListener('mousemove', handleMouseMove);
@@ -2446,8 +2328,10 @@ function useClientPoint(context, props) {
       cleanupListenerRef.current = cleanup;
       return cleanup;
     }
-    refs.setPositionReference(domReference);
-  }, [openCheck, enabled, x, y, floating, dataRef, refs, domReference, setReference]);
+    refs.setPositionReference(refs.domReference.current);
+  }, [dataRef, enabled, openCheck, refs, setReference, x, y]);
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: intentionally specifying `reactive`
   React.useEffect(() => {
     return addListener();
   }, [addListener, reactive]);
@@ -2515,6 +2399,7 @@ function useDismiss(context, props) {
   const {
     open,
     onOpenChange,
+    nodeId,
     elements: {
       reference,
       domReference,
@@ -2547,11 +2432,9 @@ function useDismiss(context, props) {
     outsidePress: outsidePressCapture
   } = normalizeProp(capture);
   const closeOnEscapeKeyDown = useEffectEvent(event => {
-    var _dataRef$current$floa;
     if (!open || !enabled || !escapeKey || event.key !== 'Escape') {
       return;
     }
-    const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;
     const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
     if (!escapeKeyBubbles) {
       event.stopPropagation();
@@ -2581,7 +2464,6 @@ function useDismiss(context, props) {
     (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener('keydown', callback);
   });
   const closeOnPressOutside = useEffectEvent(event => {
-    var _dataRef$current$floa2;
     // Given developers can stop the propagation of the synthetic event,
     // we can only be confident with a positive value.
     const insideReactTree = insideReactTreeRef.current;
@@ -2647,7 +2529,6 @@ function useDismiss(context, props) {
         return;
       }
     }
-    const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId;
     const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {
       var _node$context;
       return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);
@@ -2723,6 +2604,8 @@ function useDismiss(context, props) {
       });
     };
   }, [dataRef, floating, domReference, reference, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
   React.useEffect(() => {
     insideReactTreeRef.current = false;
   }, [outsidePress, outsidePressEvent]);
@@ -2755,50 +2638,9 @@ function useDismiss(context, props) {
   }, [enabled, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);
 }
 
-function useFloatingRootContext(options) {
-  const {
-    open = false,
-    onOpenChange: onOpenChangeProp,
-    elements: elementsProp
-  } = options;
-  const floatingId = useId();
-  const dataRef = React.useRef({});
-  const [events] = React.useState(() => createPubSub());
-  const nested = useFloatingParentNodeId() != null;
-  if (process.env.NODE_ENV !== "production") {
-    const optionDomReference = elementsProp.reference;
-    if (optionDomReference && !isElement(optionDomReference)) {
-      error('Cannot pass a virtual element to the `elements.reference` option,', 'as it must be a real DOM element. Use `refs.setPositionReference()`', 'instead.');
-    }
-  }
-  const [positionReference, setPositionReference] = React.useState(elementsProp.reference);
-  const onOpenChange = useEffectEvent((open, event, reason) => {
-    dataRef.current.openEvent = open ? event : undefined;
-    events.emit('openchange', {
-      open,
-      event,
-      reason,
-      nested
-    });
-    onOpenChangeProp == null || onOpenChangeProp(open, event, reason);
-  });
-  const refs = React.useMemo(() => ({
-    setPositionReference
-  }), []);
-  const elements = React.useMemo(() => ({
-    reference: positionReference || elementsProp.reference || null,
-    floating: elementsProp.floating || null,
-    domReference: elementsProp.reference
-  }), [positionReference, elementsProp.reference, elementsProp.floating]);
-  return React.useMemo(() => ({
-    dataRef,
-    open,
-    onOpenChange,
-    elements,
-    events,
-    floatingId,
-    refs
-  }), [open, onOpenChange, elements, events, floatingId, refs]);
+let devMessageSet;
+if (process.env.NODE_ENV !== "production") {
+  devMessageSet = /*#__PURE__*/new Set();
 }
 
 /**
@@ -2806,51 +2648,54 @@ function useFloatingRootContext(options) {
  * @see https://floating-ui.com/docs/useFloating
  */
 function useFloating(options) {
+  var _options$elements2;
   if (options === void 0) {
     options = {};
   }
   const {
+    open = false,
+    onOpenChange: unstable_onOpenChange,
     nodeId
   } = options;
-  const internalRootContext = useFloatingRootContext({
-    ...options,
-    elements: {
-      reference: null,
-      floating: null,
-      ...options.elements
+  if (process.env.NODE_ENV !== "production") {
+    var _options$elements;
+    const err = 'Floating UI: Cannot pass a virtual element to the ' + '`elements.reference` option, as it must be a real DOM element. ' + 'Use `refs.setPositionReference` instead.';
+    if ((_options$elements = options.elements) != null && _options$elements.reference && !isElement(options.elements.reference)) {
+      var _devMessageSet;
+      if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(err))) {
+        var _devMessageSet2;
+        (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(err);
+        console.error(err);
+      }
     }
-  });
-  const rootContext = options.rootContext || internalRootContext;
-  const computedElements = rootContext.elements;
+  }
   const [_domReference, setDomReference] = React.useState(null);
-  const [positionReference, _setPositionReference] = React.useState(null);
-  const optionDomReference = computedElements == null ? void 0 : computedElements.reference;
-  const domReference = optionDomReference || _domReference;
-  const domReferenceRef = React.useRef(null);
+  const domReference = ((_options$elements2 = options.elements) == null ? void 0 : _options$elements2.reference) || _domReference;
+  const position = useFloating$1(options);
   const tree = useFloatingTree();
-  index(() => {
-    if (domReference) {
-      domReferenceRef.current = domReference;
-    }
-  }, [domReference]);
-  const position = useFloating$1({
-    ...options,
-    elements: {
-      ...computedElements,
-      ...(positionReference && {
-        reference: positionReference
-      })
+  const nested = useFloatingParentNodeId() != null;
+  const onOpenChange = useEffectEvent((open, event, reason) => {
+    if (open) {
+      dataRef.current.openEvent = event;
     }
+    events.emit('openchange', {
+      open,
+      event,
+      reason,
+      nested
+    });
+    unstable_onOpenChange == null || unstable_onOpenChange(open, event, reason);
   });
+  const domReferenceRef = React.useRef(null);
+  const dataRef = React.useRef({});
+  const events = React.useState(() => createPubSub())[0];
+  const floatingId = useId();
   const setPositionReference = React.useCallback(node => {
-    const computedPositionReference = isElement(node) ? {
+    const positionReference = isElement(node) ? {
       getBoundingClientRect: () => node.getBoundingClientRect(),
       contextElement: node
     } : node;
-    // Store the positionReference in state if the DOM reference is specified externally via the
-    // `elements.reference` option. This ensures that it won't be overridden on future renders.
-    _setPositionReference(computedPositionReference);
-    position.refs.setReference(computedPositionReference);
+    position.refs.setReference(positionReference);
   }, [position.refs]);
   const setReference = React.useCallback(node => {
     if (isElement(node) || node === null) {
@@ -2880,13 +2725,16 @@ function useFloating(options) {
   }), [position.elements, domReference]);
   const context = React.useMemo(() => ({
     ...position,
-    ...rootContext,
     refs,
     elements,
-    nodeId
-  }), [position, refs, elements, nodeId, rootContext]);
+    dataRef,
+    nodeId,
+    floatingId,
+    events,
+    open,
+    onOpenChange
+  }), [position, nodeId, floatingId, events, open, onOpenChange, refs, elements]);
   index(() => {
-    rootContext.dataRef.current.floatingContext = context;
     const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);
     if (node) {
       node.context = context;
@@ -2913,8 +2761,9 @@ function useFocus(context, props) {
     open,
     onOpenChange,
     events,
-    dataRef,
+    refs,
     elements: {
+      floating,
       domReference
     }
   } = context;
@@ -3013,7 +2862,6 @@ function useFocus(context, props) {
 
           // Wait for the window blur listener to fire.
           timeoutRef.current = window.setTimeout(() => {
-            var _dataRef$current$floa;
             const activeEl = activeElement(domReference ? domReference.ownerDocument : document);
 
             // Focus left the page, keep it open.
@@ -3022,11 +2870,7 @@ function useFocus(context, props) {
             // When focusing the reference element (e.g. regular click), then
             // clicking into the floating element, prevent it from hiding.
             // Note: it must be focusable, e.g. `tabindex="-1"`.
-            // We can not rely on relatedTarget to point to the correct element
-            // as it will only point to the shadow host of the newly focused element
-            // and not the element that actually has received focus if it is located
-            // inside a shadow root.
-            if (contains((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || contains(domReference, activeEl) || movedToFocusGuard) {
+            if (contains(refs.floating.current, relatedTarget) || contains(domReference, relatedTarget) || movedToFocusGuard) {
               return;
             }
             onOpenChange(false, event.nativeEvent, 'focus');
@@ -3034,7 +2878,7 @@ function useFocus(context, props) {
         }
       }
     };
-  }, [enabled, visibleOnly, dataRef, domReference, onOpenChange]);
+  }, [enabled, visibleOnly, domReference, refs, onOpenChange]);
 }
 
 const ACTIVE_KEY = 'active';
@@ -3094,6 +2938,7 @@ function mergeProps(userProps, propsList, elementKey) {
     }, {})
   };
 }
+
 /**
  * Merges an array of interaction hooks' props into prop getters, allowing
  * event handler functions to be composed together without overwriting one
@@ -3107,18 +2952,19 @@ function useInteractions(propsList) {
   // The dependencies are a dynamic array, so we can't use the linter's
   // suggestion to add it to the deps array.
   const deps = propsList;
-  const getReferenceProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'reference'),
-  // eslint-disable-next-line react-hooks/exhaustive-deps
-  deps);
-  const getFloatingProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'floating'),
-  // eslint-disable-next-line react-hooks/exhaustive-deps
-  deps);
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
+  const getReferenceProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'reference'), deps);
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
+  const getFloatingProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'floating'), deps);
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
   const getItemProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'item'),
   // Granularly check for `item` changes, because the `getItemProps` getter
   // should be as referentially stable as possible since it may be passed as
   // a prop to many components. All `item` key values must therefore be
   // memoized.
-  // eslint-disable-next-line react-hooks/exhaustive-deps
   propsList.map(key => key == null ? void 0 : key.item));
   return React.useMemo(() => ({
     getReferenceProps,
@@ -3167,6 +3013,7 @@ function useListNavigation(context, props) {
   const {
     open,
     onOpenChange,
+    refs,
     elements: {
       domReference,
       floating
@@ -3197,14 +3044,14 @@ function useListNavigation(context, props) {
   if (process.env.NODE_ENV !== "production") {
     if (allowEscape) {
       if (!loop) {
-        warn('`useListNavigation` looping must be enabled to allow escaping.');
+        console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));
       }
       if (!virtual) {
-        warn('`useListNavigation` must be virtual to allow escaping.');
+        console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));
       }
     }
     if (orientation === 'vertical' && cols > 1) {
-      warn('In grid list navigation mode (`cols` > 1), the `orientation` should', 'be either "horizontal" or "both".');
+      console.warn(['Floating UI: In grid list navigation mode (`cols` > 1), the', '`orientation` should be either "horizontal" or "both".'].join(' '));
     }
   }
   const parentId = useFloatingParentNodeId();
@@ -3221,52 +3068,41 @@ function useListNavigation(context, props) {
   const disabledIndicesRef = useLatestRef(disabledIndices);
   const latestOpenRef = useLatestRef(open);
   const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);
-  const floatingRef = useLatestRef(floating);
-  const selectedIndexRef = useLatestRef(selectedIndex);
   const [activeId, setActiveId] = React.useState();
   const [virtualId, setVirtualId] = React.useState();
   const focusItem = useEffectEvent(function (listRef, indexRef, forceScrollIntoView) {
     if (forceScrollIntoView === void 0) {
       forceScrollIntoView = false;
     }
-    function runFocus(item) {
-      if (virtual) {
-        setActiveId(item.id);
-        tree == null || tree.events.emit('virtualfocus', item);
-        if (virtualItemRef) {
-          virtualItemRef.current = item;
-        }
-      } else {
-        enqueueFocus(item, {
-          preventScroll: true,
-          // Mac Safari does not move the virtual cursor unless the focus call
-          // is sync. However, for the very first focus call, we need to wait
-          // for the position to be ready in order to prevent unwanted
-          // scrolling. This means the virtual cursor will not move to the first
-          // item when first opening the floating element, but will on
-          // subsequent calls. `preventScroll` is supported in modern Safari,
-          // so we can use that instead.
-          // iOS Safari must be async or the first item will not be focused.
-          sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false
-        });
+    const item = listRef.current[indexRef.current];
+    if (!item) return;
+    if (virtual) {
+      setActiveId(item.id);
+      tree == null || tree.events.emit('virtualfocus', item);
+      if (virtualItemRef) {
+        virtualItemRef.current = item;
       }
-    }
-    const initialItem = listRef.current[indexRef.current];
-    if (initialItem) {
-      runFocus(initialItem);
+    } else {
+      enqueueFocus(item, {
+        preventScroll: true,
+        // Mac Safari does not move the virtual cursor unless the focus call
+        // is sync. However, for the very first focus call, we need to wait
+        // for the position to be ready in order to prevent unwanted
+        // scrolling. This means the virtual cursor will not move to the first
+        // item when first opening the floating element, but will on
+        // subsequent calls. `preventScroll` is supported in modern Safari,
+        // so we can use that instead.
+        // iOS Safari must be async or the first item will not be focused.
+        sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false
+      });
     }
     requestAnimationFrame(() => {
-      const waitedItem = listRef.current[indexRef.current] || initialItem;
-      if (!waitedItem) return;
-      if (!initialItem) {
-        runFocus(waitedItem);
-      }
       const scrollIntoViewOptions = scrollItemIntoViewRef.current;
       const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);
       if (shouldScrollIntoView) {
         // JSDOM doesn't support `.scrollIntoView()` but it's widely supported
         // by all browsers.
-        waitedItem.scrollIntoView == null || waitedItem.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {
+        item.scrollIntoView == null || item.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {
           block: 'nearest',
           inline: 'nearest'
         } : scrollIntoViewOptions);
@@ -3314,7 +3150,7 @@ function useListNavigation(context, props) {
     if (open && floating) {
       if (activeIndex == null) {
         forceSyncFocus.current = false;
-        if (selectedIndexRef.current != null) {
+        if (selectedIndex != null) {
           return;
         }
 
@@ -3351,7 +3187,7 @@ function useListNavigation(context, props) {
         forceScrollIntoViewRef.current = false;
       }
     }
-  }, [enabled, open, floating, activeIndex, selectedIndexRef, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);
+  }, [enabled, open, floating, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);
 
   // Ensure the parent floating element has focus when a nested child closes
   // to allow arrow key navigation to work after the pointer leaves the child.
@@ -3435,7 +3271,7 @@ function useListNavigation(context, props) {
           focusItem(listRef, indexRef);
           onNavigate(null);
           if (!virtual) {
-            enqueueFocus(floatingRef.current, {
+            enqueueFocus(refs.floating.current, {
               preventScroll: true
             });
           }
@@ -3443,7 +3279,7 @@ function useListNavigation(context, props) {
       })
     };
     return props;
-  }, [open, floatingRef, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);
+  }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);
   return React.useMemo(() => {
     if (!enabled) {
       return {};
@@ -3456,7 +3292,7 @@ function useListNavigation(context, props) {
       // If the floating element is animating out, ignore navigation. Otherwise,
       // the `activeIndex` gets set to 0 despite not being open so the next time
       // the user ArrowDowns, the first item won't be focused.
-      if (!latestOpenRef.current && event.currentTarget === floatingRef.current) {
+      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {
         return;
       }
       if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {
@@ -3492,9 +3328,9 @@ function useListNavigation(context, props) {
         // To calculate movements on the grid, we use hypothetical cell indices
         // as if every item was 1x1, then convert back to real indices.
         const cellMap = buildCellMap(sizes, cols, dense);
-        const minGridIndex = cellMap.findIndex(index => index != null && !isDisabled(listRef.current, index, disabledIndices));
+        const minGridIndex = cellMap.findIndex(index => index != null && !(disabledIndices != null && disabledIndices.includes(index)));
         // last enabled index
-        const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !isDisabled(listRef.current, index, disabledIndices) ? cellIndex : foundIndex, -1);
+        const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);
         indexRef.current = cellMap[getGridNavigatedIndex({
           current: cellMap.map(itemIndex => itemIndex != null ? listRef.current[itemIndex] : null)
         }, {
@@ -3504,10 +3340,10 @@ function useListNavigation(context, props) {
           cols,
           // treat undefined (empty grid spaces) as disabled indices so we
           // don't end up in them
-          disabledIndices: getCellIndices([...(disabledIndices || listRef.current.map((_, index) => isDisabled(listRef.current, index) ? index : undefined)), undefined], cellMap),
+          disabledIndices: getCellIndices([...(disabledIndices || []), undefined], cellMap),
           minIndex: minGridIndex,
           maxIndex: maxGridIndex,
-          prevIndex: getCellIndexOfCorner(indexRef.current > maxIndex ? minIndex : indexRef.current, sizes, cellMap, cols,
+          prevIndex: getCellIndexOfCorner(indexRef.current, sizes, cellMap, cols,
           // use a corner matching the edge closest to the direction
           // we're moving in so we don't end up in the same item. Prefer
           // top/left over bottom/right.
@@ -3655,7 +3491,7 @@ function useListNavigation(context, props) {
           }
         },
         onFocus() {
-          if (open && !virtual) {
+          if (open) {
             onNavigate(null);
           }
         },
@@ -3673,7 +3509,7 @@ function useListNavigation(context, props) {
       },
       item
     };
-  }, [domReference, floatingRef, activeId, virtualId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item, tree, virtualItemRef, itemSizes, dense]);
+  }, [domReference, refs, activeId, virtualId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item, tree, virtualItemRef, itemSizes, dense]);
 }
 
 const componentRoleToAriaRoleMap = /*#__PURE__*/new Map([['select', 'listbox'], ['combobox', 'listbox'], ['label', false]]);
@@ -3792,11 +3628,11 @@ function useDelayUnmount(open, durationMs) {
     setIsMounted(true);
   }
   React.useEffect(() => {
-    if (!open && isMounted) {
+    if (!open) {
       const timeout = setTimeout(() => setIsMounted(false), durationMs);
       return () => clearTimeout(timeout);
     }
-  }, [open, isMounted, durationMs]);
+  }, [open, durationMs]);
   return isMounted;
 }
 /**
@@ -3819,11 +3655,19 @@ function useTransitionStatus(context, props) {
   } = props;
   const isNumberDuration = typeof duration === 'number';
   const closeDuration = (isNumberDuration ? duration : duration.close) || 0;
+  const [initiated, setInitiated] = React.useState(false);
   const [status, setStatus] = React.useState('unmounted');
   const isMounted = useDelayUnmount(open, closeDuration);
-  if (!isMounted && status === 'close') {
-    setStatus('unmounted');
-  }
+
+  // `initiated` check prevents this `setState` call from breaking
+  // <FloatingPortal />. This call is necessary to ensure subsequent opens
+  // after the initial one allows the correct side animation to play when the
+  // placement has changed.
+  index(() => {
+    if (initiated && !isMounted) {
+      setStatus('unmounted');
+    }
+  }, [initiated, isMounted]);
   index(() => {
     if (!floating) return;
     if (open) {
@@ -3835,6 +3679,7 @@ function useTransitionStatus(context, props) {
         cancelAnimationFrame(frame);
       };
     }
+    setInitiated(true);
     setStatus('close');
   }, [open, floating]);
   return {
@@ -4095,7 +3940,7 @@ const inner = props => ({
     const item = listRef.current[index];
     if (process.env.NODE_ENV !== "production") {
       if (!state.placement.startsWith('bottom')) {
-        warn('`placement` side must be "bottom" when using the `inner`', 'middleware.');
+        console.warn(['Floating UI: `placement` side must be "bottom" when using the', '`inner` middleware.'].join(' '));
       }
     }
     if (!item) {
@@ -4261,7 +4106,7 @@ function isInside(point, rect) {
 /**
  * Generates a safe polygon area that the user can traverse without closing the
  * floating element once leaving the reference element.
- * @see https://floating-ui.com/docs/useHover#safepolygon
+ * @see https://floating-ui.com/docs/useHover#safePolygon
  */
 function safePolygon(options) {
   if (options === void 0) {
@@ -4453,4 +4298,4 @@ function safePolygon(options) {
   return fn;
 }
 
-export { Composite, CompositeItem, FloatingArrow, FloatingDelayGroup, FloatingFocusManager, FloatingList, FloatingNode, FloatingOverlay, FloatingPortal, FloatingTree, inner, safePolygon, useClick, useClientPoint, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingRootContext, useFloatingTree, useFocus, useHover, useId, useInnerOffset, useInteractions, useListItem, useListNavigation, useMergeRefs, useRole, useTransitionStatus, useTransitionStyles, useTypeahead };
+export { Composite, CompositeItem, FloatingArrow, FloatingDelayGroup, FloatingFocusManager, FloatingList, FloatingNode, FloatingOverlay, FloatingPortal, FloatingTree, inner, safePolygon, useClick, useClientPoint, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingTree, useFocus, useHover, useId, useInnerOffset, useInteractions, useListItem, useListNavigation, useMergeRefs, useRole, useTransitionStatus, useTransitionStyles, useTypeahead };
diff --git a/node_modules/@floating-ui/react/dist/floating-ui.react.mjs b/node_modules/@floating-ui/react/dist/floating-ui.react.mjs
index 4aa9c86..65efbce 100644
--- a/node_modules/@floating-ui/react/dist/floating-ui.react.mjs
+++ b/node_modules/@floating-ui/react/dist/floating-ui.react.mjs
@@ -4,15 +4,32 @@ import { stopEvent, getDocument, isMouseLikePointerType, contains, activeElement
 import { floor } from '@floating-ui/utils';
 import { platform, getOverflowAncestors, useFloating as useFloating$1, offset, detectOverflow } from '@floating-ui/react-dom';
 export { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/react-dom';
-import { isElement, getNodeName, isHTMLElement, getWindow, isLastTraversableNode, getParentNode, getComputedStyle } from '@floating-ui/utils/dom';
-import { tabbable, isTabbable } from 'tabbable';
+import { isElement, isHTMLElement, getNodeName, getWindow, isLastTraversableNode, getParentNode, getComputedStyle } from '@floating-ui/utils/dom';
+import { tabbable } from 'tabbable';
 import { createPortal, flushSync } from 'react-dom';
+import { startTransition, useCallback, useState } from 'react'
+
+export const useTransitionState = ((val) => {
+  const [a, b] = useState(val)
+  // @ts-ignore
+  const wrapped = useCallback(
+    (...args) => {
+      startTransition(() => {
+        // @ts-ignore
+        b(...args)
+      })
+    },
+    [b]
+  )
+  return [a, wrapped]
+})
 
 /**
  * Merges an array of refs into a single memoized callback ref or `null`.
- * @see https://floating-ui.com/docs/react-utils#usemergerefs
+ * @see https://floating-ui.com/docs/useMergeRefs
  */
 function useMergeRefs(refs) {
+  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
   return React.useMemo(() => {
     if (refs.every(ref => ref == null)) {
       return null;
@@ -26,16 +43,11 @@ function useMergeRefs(refs) {
         }
       });
     };
-    // eslint-disable-next-line react-hooks/exhaustive-deps
   }, refs);
 }
 
-// https://github.com/mui/material-ui/issues/41190#issuecomment-2040873379
-const SafeReact = {
-  ...React
-};
-
-const useInsertionEffect = SafeReact.useInsertionEffect;
+// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`
+const useInsertionEffect = React[/*#__PURE__*/'useInsertionEffect'.toString()];
 const useSafeInsertionEffect = useInsertionEffect || (fn => fn());
 function useEffectEvent(callback) {
   const ref = React.useRef(() => {
@@ -84,10 +96,14 @@ function findNonDisabledIndex(listRef, _temp) {
     amount = 1
   } = _temp === void 0 ? {} : _temp;
   const list = listRef.current;
+  const isDisabledIndex = disabledIndices ? index => disabledIndices.includes(index) : index => {
+    const element = list[index];
+    return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';
+  };
   let index = startingIndex;
   do {
     index += decrement ? -amount : amount;
-  } while (index >= 0 && index <= list.length - 1 && isDisabled(list, index, disabledIndices));
+  } while (index >= 0 && index <= list.length - 1 && isDisabledIndex(index));
   return index;
 }
 function getGridNavigatedIndex(elementsRef, _ref) {
@@ -183,8 +199,8 @@ function getGridNavigatedIndex(elementsRef, _ref) {
       if (prevIndex % cols !== 0) {
         nextIndex = findNonDisabledIndex(elementsRef, {
           startingIndex: prevIndex,
-          decrement: true,
-          disabledIndices
+          disabledIndices,
+          decrement: true
         });
         if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
           nextIndex = findNonDisabledIndex(elementsRef, {
@@ -263,20 +279,13 @@ function buildCellMap(sizes, cols, dense) {
 function getCellIndexOfCorner(index, sizes, cellMap, cols, corner) {
   if (index === -1) return -1;
   const firstCellIndex = cellMap.indexOf(index);
-  const sizeItem = sizes[index];
   switch (corner) {
     case 'tl':
       return firstCellIndex;
     case 'tr':
-      if (!sizeItem) {
-        return firstCellIndex;
-      }
-      return firstCellIndex + sizeItem.width - 1;
+      return firstCellIndex + sizes[index].width - 1;
     case 'bl':
-      if (!sizeItem) {
-        return firstCellIndex;
-      }
-      return firstCellIndex + (sizeItem.height - 1) * cols;
+      return firstCellIndex + (sizes[index].height - 1) * cols;
     case 'br':
       return cellMap.lastIndexOf(index);
   }
@@ -286,13 +295,6 @@ function getCellIndexOfCorner(index, sizes, cellMap, cols, corner) {
 function getCellIndices(indices, cellMap) {
   return cellMap.flatMap((index, cellIndex) => indices.includes(index) ? [cellIndex] : []);
 }
-function isDisabled(list, index, disabledIndices) {
-  if (disabledIndices) {
-    return disabledIndices.includes(index);
-  }
-  const element = list[index];
-  return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';
-}
 
 let rafId = 0;
 function enqueueFocus(el, options) {
@@ -350,13 +352,13 @@ const FloatingListContext = /*#__PURE__*/React.createContext({
  * Provides context for a list of items within the floating element.
  * @see https://floating-ui.com/docs/FloatingList
  */
-function FloatingList(props) {
-  const {
+function FloatingList(_ref) {
+  let {
     children,
     elementsRef,
     labelsRef
-  } = props;
-  const [map, setMap] = React.useState(() => new Map());
+  } = _ref;
+  const [map, setMap] = useTransitionState(() => new Map());
   const register = React.useCallback(node => {
     setMap(prevMap => new Map(prevMap).set(node, null));
   }, []);
@@ -387,18 +389,12 @@ function FloatingList(props) {
     }), [register, unregister, map, elementsRef, labelsRef])
   }, children);
 }
-/**
- * Used to register a list item and its index (DOM position) in the
- * `FloatingList`.
- * @see https://floating-ui.com/docs/FloatingList#uselistitem
- */
-function useListItem(props) {
-  if (props === void 0) {
-    props = {};
-  }
-  const {
+function useListItem(_temp) {
+  let {
     label
-  } = props;
+  } = _temp === void 0 ? {} : _temp;
+  const [index$1, setIndex] = useTransitionState(null);
+  const componentRef = React.useRef(null);
   const {
     register,
     unregister,
@@ -406,8 +402,6 @@ function useListItem(props) {
     elementsRef,
     labelsRef
   } = React.useContext(FloatingListContext);
-  const [index$1, setIndex] = React.useState(null);
-  const componentRef = React.useRef(null);
   const ref = React.useCallback(node => {
     componentRef.current = node;
     if (index$1 !== null) {
@@ -456,30 +450,20 @@ const CompositeContext = /*#__PURE__*/React.createContext({
 const horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];
 const verticalKeys = [ARROW_UP, ARROW_DOWN];
 const allKeys = [...horizontalKeys, ...verticalKeys];
-
-/**
- * Creates a single tab stop whose items are navigated by arrow keys, which
- * provides list navigation outside of floating element contexts.
- *
- * This is useful to enable navigation of a list of items that aren’t part of a
- * floating element. A menubar is an example of a composite, with each reference
- * element being an item.
- * @see https://floating-ui.com/docs/Composite
- */
-const Composite = /*#__PURE__*/React.forwardRef(function Composite(props, forwardedRef) {
-  const {
+const Composite = /*#__PURE__*/React.forwardRef(function Composite(_ref, forwardedRef) {
+  let {
     render,
     orientation = 'both',
     loop = true,
     cols = 1,
-    disabledIndices,
+    disabledIndices = [],
     activeIndex: externalActiveIndex,
     onNavigate: externalSetActiveIndex,
     itemSizes,
     dense = false,
-    ...domProps
-  } = props;
-  const [internalActiveIndex, internalSetActiveIndex] = React.useState(0);
+    ...props
+  } = _ref;
+  const [internalActiveIndex, internalSetActiveIndex] = useTransitionState(0);
   const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;
   const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);
   const elementsRef = React.useRef([]);
@@ -492,21 +476,17 @@ const Composite = /*#__PURE__*/React.forwardRef(function Composite(props, forwar
   function handleKeyDown(event) {
     if (!allKeys.includes(event.key)) return;
     let nextIndex = activeIndex;
-    const minIndex = getMinIndex(elementsRef, disabledIndices);
-    const maxIndex = getMaxIndex(elementsRef, disabledIndices);
     if (isGrid) {
-      const sizes = itemSizes || Array.from({
-        length: elementsRef.current.length
-      }, () => ({
+      const sizes = itemSizes != null ? itemSizes : Array.from(Array(elementsRef.current.length), () => ({
         width: 1,
         height: 1
       }));
       // To calculate movements on the grid, we use hypothetical cell indices
       // as if every item was 1x1, then convert back to real indices.
       const cellMap = buildCellMap(sizes, cols, dense);
-      const minGridIndex = cellMap.findIndex(index => index != null && !isDisabled(elementsRef.current, index, disabledIndices));
+      const minGridIndex = cellMap.findIndex(index => index != null && !disabledIndices.includes(index));
       // last enabled index
-      const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !isDisabled(elementsRef.current, index, disabledIndices) ? cellIndex : foundIndex, -1);
+      const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);
       nextIndex = cellMap[getGridNavigatedIndex({
         current: cellMap.map(itemIndex => itemIndex ? elementsRef.current[itemIndex] : null)
       }, {
@@ -516,16 +496,18 @@ const Composite = /*#__PURE__*/React.forwardRef(function Composite(props, forwar
         cols,
         // treat undefined (empty grid spaces) as disabled indices so we
         // don't end up in them
-        disabledIndices: getCellIndices([...(disabledIndices || elementsRef.current.map((_, index) => isDisabled(elementsRef.current, index) ? index : undefined)), undefined], cellMap),
+        disabledIndices: getCellIndices([...disabledIndices, undefined], cellMap),
         minIndex: minGridIndex,
         maxIndex: maxGridIndex,
-        prevIndex: getCellIndexOfCorner(activeIndex > maxIndex ? minIndex : activeIndex, sizes, cellMap, cols,
+        prevIndex: getCellIndexOfCorner(activeIndex, sizes, cellMap, cols,
         // use a corner matching the edge closest to the direction we're
         // moving in so we don't end up in the same item. Prefer
         // top/left over bottom/right.
         event.key === ARROW_DOWN ? 'bl' : event.key === ARROW_RIGHT ? 'tr' : 'tl')
       })]; // navigated cell will never be nullish
     }
+    const minIndex = getMinIndex(elementsRef, disabledIndices);
+    const maxIndex = getMaxIndex(elementsRef, disabledIndices);
     const toEndKeys = {
       horizontal: [ARROW_RIGHT],
       vertical: [ARROW_DOWN],
@@ -568,12 +550,12 @@ const Composite = /*#__PURE__*/React.forwardRef(function Composite(props, forwar
     }
   }
   const computedProps = {
-    ...domProps,
+    ...props,
     ...renderElementProps,
     ref: forwardedRef,
     'aria-orientation': orientation === 'both' ? undefined : orientation,
     onKeyDown(e) {
-      domProps.onKeyDown == null || domProps.onKeyDown(e);
+      props.onKeyDown == null || props.onKeyDown(e);
       renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);
       handleKeyDown(e);
     }
@@ -584,14 +566,11 @@ const Composite = /*#__PURE__*/React.forwardRef(function Composite(props, forwar
     elementsRef: elementsRef
   }, renderJsx(render, computedProps)));
 });
-/**
- * @see https://floating-ui.com/docs/Composite
- */
-const CompositeItem = /*#__PURE__*/React.forwardRef(function CompositeItem(props, forwardedRef) {
-  const {
+const CompositeItem = /*#__PURE__*/React.forwardRef(function CompositeItem(_ref2, forwardedRef) {
+  let {
     render,
-    ...domProps
-  } = props;
+    ...props
+  } = _ref2;
   const renderElementProps = render && typeof render !== 'function' ? render.props : {};
   const {
     activeIndex,
@@ -604,13 +583,13 @@ const CompositeItem = /*#__PURE__*/React.forwardRef(function CompositeItem(props
   const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);
   const isActive = activeIndex === index;
   const computedProps = {
-    ...domProps,
+    ...props,
     ...renderElementProps,
     ref: mergedRef,
     tabIndex: isActive ? 0 : -1,
     'data-active': isActive ? '' : undefined,
     onFocus(e) {
-      domProps.onFocus == null || domProps.onFocus(e);
+      props.onFocus == null || props.onFocus(e);
       renderElementProps.onFocus == null || renderElementProps.onFocus(e);
       onNavigate(index);
     }
@@ -635,67 +614,41 @@ function _extends() {
 
 let serverHandoffComplete = false;
 let count = 0;
-const genId = () => // Ensure the id is unique with multiple independent versions of Floating UI
-// on <React 18
-"floating-ui-" + Math.random().toString(36).slice(2, 6) + count++;
+const genId = () => "floating-ui-" + count++;
 function useFloatingId() {
-  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : undefined);
+  const [id, setId] = useTransitionState(() => serverHandoffComplete ? genId() : undefined);
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
   index(() => {
     if (id == null) {
       setId(genId());
     }
-    // eslint-disable-next-line react-hooks/exhaustive-deps
   }, []);
   React.useEffect(() => {
-    serverHandoffComplete = true;
+    if (!serverHandoffComplete) {
+      serverHandoffComplete = true;
+    }
   }, []);
   return id;
 }
-const useReactId = SafeReact.useId;
+
+// `toString()` prevents bundlers from trying to `import { useId } from 'react'`
+const useReactId = React[/*#__PURE__*/'useId'.toString()];
 
 /**
  * Uses React 18's built-in `useId()` when available, or falls back to a
  * slightly less performant (requiring a double render) implementation for
  * earlier React versions.
- * @see https://floating-ui.com/docs/react-utils#useid
+ * @see https://floating-ui.com/docs/useId
  */
 const useId = useReactId || useFloatingId;
 
-let devMessageSet;
-if (process.env.NODE_ENV !== "production") {
-  devMessageSet = /*#__PURE__*/new Set();
-}
-function warn() {
-  var _devMessageSet;
-  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
-    messages[_key] = arguments[_key];
-  }
-  const message = "Floating UI: " + messages.join(' ');
-  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {
-    var _devMessageSet2;
-    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);
-    console.warn(message);
-  }
-}
-function error() {
-  var _devMessageSet3;
-  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
-    messages[_key2] = arguments[_key2];
-  }
-  const message = "Floating UI: " + messages.join(' ');
-  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {
-    var _devMessageSet4;
-    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);
-    console.error(message);
-  }
-}
-
 /**
  * Renders a pointing arrow triangle.
  * @see https://floating-ui.com/docs/FloatingArrow
  */
-const FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(props, ref) {
-  const {
+const FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(_ref, ref) {
+  let {
     context: {
       placement,
       elements: {
@@ -717,10 +670,10 @@ const FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(props
       ...restStyle
     } = {},
     ...rest
-  } = props;
+  } = _ref;
   if (process.env.NODE_ENV !== "production") {
     if (!ref) {
-      warn('The `ref` prop is required for `FloatingArrow`.');
+      console.warn('Floating UI: The `ref` prop is required for the `FloatingArrow`', 'component.');
     }
   }
   const clipPathId = useId();
@@ -730,8 +683,8 @@ const FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(props
 
   // Strokes must be double the border width, this ensures the stroke's width
   // works as you'd expect.
-  const computedStrokeWidth = strokeWidth * 2;
-  const halfStrokeWidth = computedStrokeWidth / 2;
+  strokeWidth *= 2;
+  const halfStrokeWidth = strokeWidth / 2;
   const svgX = width / 2 * (tipRadius / -8 + 1);
   const svgY = height / 2 * tipRadius / 4;
   const [side, alignment] = placement.split('-');
@@ -745,7 +698,9 @@ const FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(props
   }
   const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : '';
   const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y : '';
-  const dValue = d || 'M0,0' + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + ' Z';
+  const dValue = d ||
+  // biome-ignore lint/style/useTemplate: readability
+  'M0,0' + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + ' Z';
   const rotation = {
     top: isCustomShape ? 'rotate(180deg)' : '',
     left: isCustomShape ? 'rotate(90deg)' : 'rotate(-90deg)',
@@ -755,7 +710,7 @@ const FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(props
   return /*#__PURE__*/React.createElement("svg", _extends({}, rest, {
     "aria-hidden": true,
     ref: ref,
-    width: isCustomShape ? width : width + computedStrokeWidth,
+    width: isCustomShape ? width : width + strokeWidth,
     height: width,
     viewBox: "0 0 " + width + " " + (height > width ? height : width),
     style: {
@@ -763,27 +718,27 @@ const FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(props
       pointerEvents: 'none',
       [xOffsetProp]: arrowX,
       [yOffsetProp]: arrowY,
-      [side]: isVerticalSide || isCustomShape ? '100%' : "calc(100% - " + computedStrokeWidth / 2 + "px)",
+      [side]: isVerticalSide || isCustomShape ? '100%' : "calc(100% - " + strokeWidth / 2 + "px)",
       transform: "" + rotation + (transform != null ? transform : ''),
       ...restStyle
     }
-  }), computedStrokeWidth > 0 && /*#__PURE__*/React.createElement("path", {
+  }), strokeWidth > 0 && /*#__PURE__*/React.createElement("path", {
     clipPath: "url(#" + clipPathId + ")",
     fill: "none",
     stroke: stroke
     // Account for the stroke on the fill path rendered below.
     ,
-    strokeWidth: computedStrokeWidth + (d ? 0 : 1),
+    strokeWidth: strokeWidth + (d ? 0 : 1),
     d: dValue
   }), /*#__PURE__*/React.createElement("path", {
-    stroke: computedStrokeWidth && !d ? rest.fill : 'none',
+    stroke: strokeWidth && !d ? rest.fill : 'none',
     d: dValue
   }), /*#__PURE__*/React.createElement("clipPath", {
     id: clipPathId
   }, /*#__PURE__*/React.createElement("rect", {
     x: -halfStrokeWidth,
     y: halfStrokeWidth * (isCustomShape ? -1 : 1),
-    width: width + computedStrokeWidth,
+    width: width + strokeWidth,
     height: width
   })));
 });
@@ -807,24 +762,14 @@ function createPubSub() {
 
 const FloatingNodeContext = /*#__PURE__*/React.createContext(null);
 const FloatingTreeContext = /*#__PURE__*/React.createContext(null);
-
-/**
- * Returns the parent node id for nested floating elements, if available.
- * Returns `null` for top-level floating elements.
- */
 const useFloatingParentNodeId = () => {
   var _React$useContext;
   return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
 };
-
-/**
- * Returns the nearest floating tree context, if available.
- */
 const useFloatingTree = () => React.useContext(FloatingTreeContext);
 
 /**
- * Registers a node into the `FloatingTree`, returning its id.
- * @see https://floating-ui.com/docs/FloatingTree
+ * Registers a node into the floating tree, returning its id.
  */
 function useFloatingNodeId(customParentId) {
   const id = useId();
@@ -848,11 +793,11 @@ function useFloatingNodeId(customParentId) {
  * Provides parent node context for nested floating elements.
  * @see https://floating-ui.com/docs/FloatingTree
  */
-function FloatingNode(props) {
-  const {
+function FloatingNode(_ref) {
+  let {
     children,
     id
-  } = props;
+  } = _ref;
   const parentId = useFloatingParentNodeId();
   return /*#__PURE__*/React.createElement(FloatingNodeContext.Provider, {
     value: React.useMemo(() => ({
@@ -864,18 +809,14 @@ function FloatingNode(props) {
 
 /**
  * Provides context for nested floating elements when they are not children of
- * each other on the DOM.
- * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:
- * - The `bubbles` option in the `useDismiss()` Hook
- * - Nested virtual list navigation
- * - Nested floating elements that each open on hover
- * - Custom communication between parent and child floating elements
+ * each other on the DOM (i.e. portalled to a common node, rather than their
+ * respective parent).
  * @see https://floating-ui.com/docs/FloatingTree
  */
-function FloatingTree(props) {
-  const {
+function FloatingTree(_ref2) {
+  let {
     children
-  } = props;
+  } = _ref2;
   const nodesRef = React.useRef([]);
   const addNode = React.useCallback(node => {
     nodesRef.current = [...nodesRef.current, node];
@@ -883,7 +824,7 @@ function FloatingTree(props) {
   const removeNode = React.useCallback(node => {
     nodesRef.current = nodesRef.current.filter(n => n !== node);
   }, []);
-  const events = React.useState(() => createPubSub())[0];
+  const events = useTransitionState(() => createPubSub())[0];
   return /*#__PURE__*/React.createElement(FloatingTreeContext.Provider, {
     value: React.useMemo(() => ({
       nodesRef,
@@ -933,7 +874,8 @@ function useHover(context, props) {
     elements: {
       domReference,
       floating
-    }
+    },
+    refs
   } = context;
   const {
     enabled = true,
@@ -948,9 +890,9 @@ function useHover(context, props) {
   const handleCloseRef = useLatestRef(handleClose);
   const delayRef = useLatestRef(delay);
   const pointerTypeRef = React.useRef();
-  const timeoutRef = React.useRef(-1);
+  const timeoutRef = React.useRef();
   const handlerRef = React.useRef();
-  const restTimeoutRef = React.useRef(-1);
+  const restTimeoutRef = React.useRef();
   const blockMouseMoveRef = React.useRef(true);
   const performedPointerEventsMutationRef = React.useRef(false);
   const unbindMouseMoveRef = React.useRef(() => {});
@@ -1006,24 +948,24 @@ function useHover(context, props) {
     const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);
     if (closeDelay && !handlerRef.current) {
       clearTimeout(timeoutRef.current);
-      timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);
+      timeoutRef.current = setTimeout(() => onOpenChange(false, event, reason), closeDelay);
     } else if (runElseBranch) {
       clearTimeout(timeoutRef.current);
       onOpenChange(false, event, reason);
     }
   }, [delayRef, onOpenChange]);
-  const cleanupMouseMoveHandler = useEffectEvent(() => {
+  const cleanupMouseMoveHandler = React.useCallback(() => {
     unbindMouseMoveRef.current();
     handlerRef.current = undefined;
-  });
-  const clearPointerEvents = useEffectEvent(() => {
+  }, []);
+  const clearPointerEvents = React.useCallback(() => {
     if (performedPointerEventsMutationRef.current) {
-      const body = getDocument(floating).body;
+      const body = getDocument(refs.floating.current).body;
       body.style.pointerEvents = '';
       body.removeAttribute(safePolygonIdentifier);
       performedPointerEventsMutationRef.current = false;
     }
-  });
+  }, [refs]);
 
   // Registering the mouse events on the reference directly to bypass React's
   // delegation system. If the cursor was on a disabled element and then entered
@@ -1038,12 +980,12 @@ function useHover(context, props) {
     function onMouseEnter(event) {
       clearTimeout(timeoutRef.current);
       blockMouseMoveRef.current = false;
-      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && !getDelay(delayRef.current, 'open')) {
+      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {
         return;
       }
       const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);
       if (openDelay) {
-        timeoutRef.current = window.setTimeout(() => {
+        timeoutRef.current = setTimeout(() => {
           onOpenChange(true, event, 'hover');
         }, openDelay);
       } else {
@@ -1051,17 +993,19 @@ function useHover(context, props) {
       }
     }
     function onMouseLeave(event) {
-      if (isClickLikeOpenEvent()) return;
+      if (isClickLikeOpenEvent()) {
+        return;
+      }
       unbindMouseMoveRef.current();
       const doc = getDocument(floating);
       clearTimeout(restTimeoutRef.current);
-      if (handleCloseRef.current && dataRef.current.floatingContext) {
+      if (handleCloseRef.current) {
         // Prevent clearing `onScrollMouseLeave` timeout.
         if (!open) {
           clearTimeout(timeoutRef.current);
         }
         handlerRef.current = handleCloseRef.current({
-          ...dataRef.current.floatingContext,
+          ...context,
           tree,
           x: event.clientX,
           y: event.clientY,
@@ -1092,10 +1036,11 @@ function useHover(context, props) {
     // did not move.
     // https://github.com/floating-ui/floating-ui/discussions/1692
     function onScrollMouseLeave(event) {
-      if (isClickLikeOpenEvent()) return;
-      if (!dataRef.current.floatingContext) return;
+      if (isClickLikeOpenEvent()) {
+        return;
+      }
       handleCloseRef.current == null || handleCloseRef.current({
-        ...dataRef.current.floatingContext,
+        ...context,
         tree,
         x: event.clientX,
         y: event.clientY,
@@ -1162,6 +1107,8 @@ function useHover(context, props) {
       clearPointerEvents();
     }
   }, [open, cleanupMouseMoveHandler, clearPointerEvents]);
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
   React.useEffect(() => {
     return () => {
       cleanupMouseMoveHandler();
@@ -1182,23 +1129,15 @@ function useHover(context, props) {
         onPointerDown: setPointerRef,
         onPointerEnter: setPointerRef,
         onMouseMove(event) {
-          function handleMouseMove() {
-            if (!blockMouseMoveRef.current) {
-              onOpenChange(true, event.nativeEvent, 'hover');
-            }
-          }
-          if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) {
-            return;
-          }
           if (open || restMs === 0) {
             return;
           }
           clearTimeout(restTimeoutRef.current);
-          if (pointerTypeRef.current === 'touch') {
-            handleMouseMove();
-          } else {
-            restTimeoutRef.current = window.setTimeout(handleMouseMove, restMs);
-          }
+          restTimeoutRef.current = setTimeout(() => {
+            if (!blockMouseMoveRef.current) {
+              onOpenChange(true, event.nativeEvent, 'hover');
+            }
+          }, restMs);
         }
       },
       floating: {
@@ -1210,37 +1149,31 @@ function useHover(context, props) {
         }
       }
     };
-  }, [enabled, mouseOnly, open, restMs, onOpenChange, closeWithDelay]);
+  }, [enabled, restMs, open, onOpenChange, closeWithDelay]);
 }
 
-const NOOP = () => {};
 const FloatingDelayGroupContext = /*#__PURE__*/React.createContext({
   delay: 0,
   initialDelay: 0,
   timeoutMs: 0,
   currentId: null,
-  setCurrentId: NOOP,
-  setState: NOOP,
+  setCurrentId: () => {},
+  setState: () => {},
   isInstantPhase: false
 });
-
-/**
- * @deprecated
- * Use the return value of `useDelayGroup()` instead.
- */
 const useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);
 /**
  * Provides context for a group of floating elements that should share a
  * `delay`.
  * @see https://floating-ui.com/docs/FloatingDelayGroup
  */
-function FloatingDelayGroup(props) {
-  const {
+const FloatingDelayGroup = _ref => {
+  let {
     children,
     delay,
     timeoutMs = 0
-  } = props;
-  const [state, setState] = React.useReducer((prev, next) => ({
+  } = _ref;
+  const [state, setState_] = React.useReducer((prev, next) => ({
     ...prev,
     ...next
   }), {
@@ -1250,6 +1183,11 @@ function FloatingDelayGroup(props) {
     currentId: null,
     isInstantPhase: false
   });
+  const setState = React.useCallback((...args) => {
+    React.startTransition(() => {
+      setState_(...args)
+    })
+  }, [setState_])
   const initialCurrentIdRef = React.useRef(null);
   const setCurrentId = React.useCallback(currentId => {
     setState({
@@ -1260,20 +1198,18 @@ function FloatingDelayGroup(props) {
     if (state.currentId) {
       if (initialCurrentIdRef.current === null) {
         initialCurrentIdRef.current = state.currentId;
-      } else if (!state.isInstantPhase) {
+      } else {
         setState({
           isInstantPhase: true
         });
       }
     } else {
-      if (state.isInstantPhase) {
-        setState({
-          isInstantPhase: false
-        });
-      }
+      setState({
+        isInstantPhase: false
+      });
       initialCurrentIdRef.current = null;
     }
-  }, [state.currentId, state.isInstantPhase]);
+  }, [state.currentId]);
   return /*#__PURE__*/React.createElement(FloatingDelayGroupContext.Provider, {
     value: React.useMemo(() => ({
       ...state,
@@ -1281,43 +1217,33 @@ function FloatingDelayGroup(props) {
       setCurrentId
     }), [state, setCurrentId])
   }, children);
-}
-/**
- * Enables grouping when called inside a component that's a child of a
- * `FloatingDelayGroup`.
- * @see https://floating-ui.com/docs/FloatingDelayGroup
- */
-function useDelayGroup(context, options) {
-  if (options === void 0) {
-    options = {};
-  }
-  const {
+};
+const useDelayGroup = (_ref2, _ref3) => {
+  let {
     open,
-    onOpenChange,
-    floatingId
-  } = context;
-  const {
-    id: optionId
-  } = options;
-  const id = optionId != null ? optionId : floatingId;
-  const groupContext = useDelayGroupContext();
+    onOpenChange
+  } = _ref2;
+  let {
+    id
+  } = _ref3;
   const {
     currentId,
     setCurrentId,
     initialDelay,
     setState,
     timeoutMs
-  } = groupContext;
+  } = useDelayGroupContext();
   index(() => {
-    if (!currentId) return;
-    setState({
-      delay: {
-        open: 1,
-        close: getDelay(initialDelay, 'close')
+    if (currentId) {
+      setState({
+        delay: {
+          open: 1,
+          close: getDelay(initialDelay, 'close')
+        }
+      });
+      if (currentId !== id) {
+        onOpenChange(false);
       }
-    });
-    if (currentId !== id) {
-      onOpenChange(false);
     }
   }, [id, onOpenChange, setState, currentId, initialDelay]);
   index(() => {
@@ -1328,7 +1254,6 @@ function useDelayGroup(context, options) {
         currentId: null
       });
     }
-    if (!currentId) return;
     if (!open && currentId === id) {
       if (timeoutMs) {
         const timeout = window.setTimeout(unset, timeoutMs);
@@ -1340,11 +1265,11 @@ function useDelayGroup(context, options) {
     }
   }, [open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);
   index(() => {
-    if (setCurrentId === NOOP || !open) return;
-    setCurrentId(id);
+    if (open) {
+      setCurrentId(id);
+    }
   }, [open, setCurrentId, id]);
-  return groupContext;
-}
+};
 
 function getAncestors(nodes, id) {
   var _nodes$find;
@@ -1438,8 +1363,7 @@ function applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, iner
     if (!parent || elementsToStop.has(parent)) {
       return;
     }
-    [].forEach.call(parent.children, node => {
-      if (getNodeName(node) === 'script') return;
+    Array.prototype.forEach.call(parent.children, node => {
       if (elementsToKeep.has(node)) {
         deep(node);
       } else {
@@ -1538,6 +1462,7 @@ function enableFocusInside(container) {
   const elements = container.querySelectorAll('[data-tabindex]');
   elements.forEach(element => {
     const tabindex = element.dataset.tabindex;
+    // biome-ignore lint/performance/noDelete: purity
     delete element.dataset.tabindex;
     if (tabindex) {
       element.setAttribute('tabindex', tabindex);
@@ -1571,7 +1496,7 @@ function setActiveElementOnTab(event) {
   }
 }
 const FocusGuard = /*#__PURE__*/React.forwardRef(function FocusGuard(props, ref) {
-  const [role, setRole] = React.useState();
+  const [role, setRole] = useTransitionState();
   index(() => {
     if (isSafari()) {
       // Unlike other screen readers such as NVDA and JAWS, the virtual cursor
@@ -1599,91 +1524,82 @@ const FocusGuard = /*#__PURE__*/React.forwardRef(function FocusGuard(props, ref)
 });
 
 const PortalContext = /*#__PURE__*/React.createContext(null);
-const attr = /*#__PURE__*/createAttribute('portal');
-
-/**
- * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode
- */
-function useFloatingPortalNode(props) {
-  if (props === void 0) {
-    props = {};
-  }
-  const {
+function useFloatingPortalNode(_temp) {
+  let {
     id,
     root
-  } = props;
+  } = _temp === void 0 ? {} : _temp;
+  const [portalNode, setPortalNode] = useTransitionState(null);
   const uniqueId = useId();
   const portalContext = usePortalContext();
-  const [portalNode, setPortalNode] = React.useState(null);
-  const portalNodeRef = React.useRef(null);
+  const data = React.useMemo(() => ({
+    id,
+    root,
+    portalContext,
+    uniqueId
+  }), [id, root, portalContext, uniqueId]);
+  const dataRef = React.useRef();
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: `data` is intentionally specified
   index(() => {
     return () => {
       portalNode == null || portalNode.remove();
-      // Allow the subsequent layout effects to create a new node on updates.
-      // The portal node will still be cleaned up on unmount.
-      // https://github.com/floating-ui/floating-ui/issues/2454
-      queueMicrotask(() => {
-        portalNodeRef.current = null;
-      });
     };
-  }, [portalNode]);
+  }, [portalNode, data]);
   index(() => {
-    // Wait for the uniqueId to be generated before creating the portal node in
-    // React <18 (using `useFloatingId` instead of the native `useId`).
-    // https://github.com/floating-ui/floating-ui/issues/2778
-    if (!uniqueId) return;
-    if (portalNodeRef.current) return;
+    if (dataRef.current === data) return;
+    dataRef.current = data;
+    const {
+      id,
+      root,
+      portalContext,
+      uniqueId
+    } = data;
     const existingIdRoot = id ? document.getElementById(id) : null;
-    if (!existingIdRoot) return;
-    const subRoot = document.createElement('div');
-    subRoot.id = uniqueId;
-    subRoot.setAttribute(attr, '');
-    existingIdRoot.appendChild(subRoot);
-    portalNodeRef.current = subRoot;
-    setPortalNode(subRoot);
-  }, [id, uniqueId]);
-  index(() => {
-    if (!uniqueId) return;
-    if (portalNodeRef.current) return;
-    let container = root || (portalContext == null ? void 0 : portalContext.portalNode);
-    if (container && !isElement(container)) container = container.current;
-    container = container || document.body;
-    let idWrapper = null;
-    if (id) {
-      idWrapper = document.createElement('div');
-      idWrapper.id = id;
-      container.appendChild(idWrapper);
-    }
-    const subRoot = document.createElement('div');
-    subRoot.id = uniqueId;
-    subRoot.setAttribute(attr, '');
-    container = idWrapper || container;
-    container.appendChild(subRoot);
-    portalNodeRef.current = subRoot;
-    setPortalNode(subRoot);
-  }, [id, root, uniqueId, portalContext]);
+    const attr = createAttribute('portal');
+    if (existingIdRoot) {
+      const subRoot = document.createElement('div');
+      subRoot.id = uniqueId;
+      subRoot.setAttribute(attr, '');
+      existingIdRoot.appendChild(subRoot);
+      setPortalNode(subRoot);
+    } else {
+      let container = root || (portalContext == null ? void 0 : portalContext.portalNode);
+      if (container && !isElement(container)) container = container.current;
+      container = container || document.body;
+      let idWrapper = null;
+      if (id) {
+        idWrapper = document.createElement('div');
+        idWrapper.id = id;
+        container.appendChild(idWrapper);
+      }
+      const subRoot = document.createElement('div');
+      subRoot.id = uniqueId;
+      subRoot.setAttribute(attr, '');
+      container = idWrapper || container;
+      container.appendChild(subRoot);
+      setPortalNode(subRoot);
+    }
+  }, [data]);
   return portalNode;
 }
 /**
  * Portals the floating element into a given container element — by default,
  * outside of the app root and into the body.
- * This is necessary to ensure the floating element can appear outside any
- * potential parent containers that cause clipping (such as `overflow: hidden`),
- * while retaining its location in the React tree.
  * @see https://floating-ui.com/docs/FloatingPortal
  */
-function FloatingPortal(props) {
-  const {
+function FloatingPortal(_ref) {
+  let {
     children,
     id,
     root = null,
     preserveTabOrder = true
-  } = props;
+  } = _ref;
   const portalNode = useFloatingPortalNode({
     id,
     root
   });
-  const [focusManagerState, setFocusManagerState] = React.useState(null);
+  const [focusManagerState, setFocusManagerState] = useTransitionState(null);
   const beforeOutsideRef = React.useRef(null);
   const afterOutsideRef = React.useRef(null);
   const beforeInsideRef = React.useRef(null);
@@ -1768,18 +1684,12 @@ const LIST_LIMIT = 20;
 let previouslyFocusedElements = [];
 function addPreviouslyFocusedElement(element) {
   previouslyFocusedElements = previouslyFocusedElements.filter(el => el.isConnected);
-  let tabbableEl = element;
-  if (!tabbableEl || getNodeName(tabbableEl) === 'body') return;
-  if (!isTabbable(tabbableEl, getTabbableOptions())) {
-    const tabbableChild = tabbable(tabbableEl, getTabbableOptions())[0];
-    if (tabbableChild) {
-      tabbableEl = tabbableChild;
+  if (element && getNodeName(element) !== 'body') {
+    previouslyFocusedElements.push(element);
+    if (previouslyFocusedElements.length > LIST_LIMIT) {
+      previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);
     }
   }
-  previouslyFocusedElements.push(tabbableEl);
-  if (previouslyFocusedElements.length > LIST_LIMIT) {
-    previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);
-  }
 }
 function getPreviouslyFocusedElement() {
   return previouslyFocusedElements.slice().reverse().find(el => el.isConnected);
@@ -1969,21 +1879,16 @@ function FloatingFocusManager(props) {
     const doc = getDocument(floating);
     const previouslyFocusedElement = activeElement(doc);
     const contextData = dataRef.current;
-    let openEvent = contextData.openEvent;
     addPreviouslyFocusedElement(previouslyFocusedElement);
 
     // Dismissing via outside press should always ignore `returnFocus` to
     // prevent unwanted scrolling.
     function onOpenChange(_ref) {
       let {
-        open,
         reason,
         event,
         nested
       } = _ref;
-      if (open) {
-        openEvent = event;
-      }
       if (reason === 'escape-key' && refs.domReference.current) {
         addPreviouslyFocusedElement(refs.domReference.current);
       }
@@ -2006,14 +1911,12 @@ function FloatingFocusManager(props) {
         var _node$context5;
         return contains((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);
       });
-      const shouldFocusReference = isFocusInsideFloatingTree || openEvent && ['click', 'mousedown'].includes(openEvent.type);
+      const shouldFocusReference = isFocusInsideFloatingTree || contextData.openEvent && ['click', 'mousedown'].includes(contextData.openEvent.type);
       if (shouldFocusReference && refs.domReference.current) {
         addPreviouslyFocusedElement(refs.domReference.current);
       }
       const returnElement = getPreviouslyFocusedElement();
-      if (
-      // eslint-disable-next-line react-hooks/exhaustive-deps
-      returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(returnElement) && (
+      if (returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(returnElement) && (
       // If the focus moved somewhere else after mount, avoid returning focus
       // since it likely entered a different element which should be
       // respected: https://github.com/floating-ui/floating-ui/issues/2607
@@ -2121,17 +2024,18 @@ function FloatingFocusManager(props) {
 }
 
 const activeLocks = /*#__PURE__*/new Set();
+
 /**
  * Provides base styling for a fixed overlay element to dim content or block
  * pointer events behind a floating element.
  * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.
  * @see https://floating-ui.com/docs/FloatingOverlay
  */
-const FloatingOverlay = /*#__PURE__*/React.forwardRef(function FloatingOverlay(props, ref) {
-  const {
+const FloatingOverlay = /*#__PURE__*/React.forwardRef(function FloatingOverlay(_ref, ref) {
+  let {
     lockScroll = false,
     ...rest
-  } = props;
+  } = _ref;
   const lockId = useId();
   index(() => {
     if (!lockScroll) return;
@@ -2305,15 +2209,15 @@ function useClick(context, props) {
   }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);
 }
 
-function createVirtualElement(domElement, data) {
+function createVirtualElement(domRef, data) {
   let offsetX = null;
   let offsetY = null;
   let isAutoUpdateEvent = false;
   return {
-    contextElement: domElement || undefined,
+    contextElement: domRef.current || undefined,
     getBoundingClientRect() {
-      var _data$dataRef$current;
-      const domRect = (domElement == null ? void 0 : domElement.getBoundingClientRect()) || {
+      var _domRef$current, _data$dataRef$current;
+      const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {
         width: 0,
         height: 0,
         x: 0,
@@ -2373,12 +2277,11 @@ function useClientPoint(context, props) {
   }
   const {
     open,
+    refs,
     dataRef,
     elements: {
-      floating,
-      domReference
-    },
-    refs
+      floating
+    }
   } = context;
   const {
     enabled = true,
@@ -2388,8 +2291,8 @@ function useClientPoint(context, props) {
   } = props;
   const initialRef = React.useRef(false);
   const cleanupListenerRef = React.useRef(null);
-  const [pointerType, setPointerType] = React.useState();
-  const [reactive, setReactive] = React.useState([]);
+  const [pointerType, setPointerType] = useTransitionState();
+  const [reactive, setReactive] = useTransitionState([]);
   const setReference = useEffectEvent((x, y) => {
     if (initialRef.current) return;
 
@@ -2399,7 +2302,7 @@ function useClientPoint(context, props) {
     if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {
       return;
     }
-    refs.setPositionReference(createVirtualElement(domReference, {
+    refs.setPositionReference(createVirtualElement(refs.domReference, {
       x,
       y,
       axis,
@@ -2427,10 +2330,10 @@ function useClientPoint(context, props) {
   const addListener = React.useCallback(() => {
     // Explicitly specified `x`/`y` coordinates shouldn't add a listener.
     if (!openCheck || !enabled || x != null || y != null) return;
-    const win = getWindow(floating);
+    const win = getWindow(refs.floating.current);
     function handleMouseMove(event) {
       const target = getTarget(event);
-      if (!contains(floating, target)) {
+      if (!contains(refs.floating.current, target)) {
         setReference(event.clientX, event.clientY);
       } else {
         win.removeEventListener('mousemove', handleMouseMove);
@@ -2446,8 +2349,10 @@ function useClientPoint(context, props) {
       cleanupListenerRef.current = cleanup;
       return cleanup;
     }
-    refs.setPositionReference(domReference);
-  }, [openCheck, enabled, x, y, floating, dataRef, refs, domReference, setReference]);
+    refs.setPositionReference(refs.domReference.current);
+  }, [dataRef, enabled, openCheck, refs, setReference, x, y]);
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: intentionally specifying `reactive`
   React.useEffect(() => {
     return addListener();
   }, [addListener, reactive]);
@@ -2515,6 +2420,7 @@ function useDismiss(context, props) {
   const {
     open,
     onOpenChange,
+    nodeId,
     elements: {
       reference,
       domReference,
@@ -2547,11 +2453,9 @@ function useDismiss(context, props) {
     outsidePress: outsidePressCapture
   } = normalizeProp(capture);
   const closeOnEscapeKeyDown = useEffectEvent(event => {
-    var _dataRef$current$floa;
     if (!open || !enabled || !escapeKey || event.key !== 'Escape') {
       return;
     }
-    const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;
     const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
     if (!escapeKeyBubbles) {
       event.stopPropagation();
@@ -2581,7 +2485,6 @@ function useDismiss(context, props) {
     (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener('keydown', callback);
   });
   const closeOnPressOutside = useEffectEvent(event => {
-    var _dataRef$current$floa2;
     // Given developers can stop the propagation of the synthetic event,
     // we can only be confident with a positive value.
     const insideReactTree = insideReactTreeRef.current;
@@ -2647,7 +2550,6 @@ function useDismiss(context, props) {
         return;
       }
     }
-    const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId;
     const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {
       var _node$context;
       return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);
@@ -2723,6 +2625,8 @@ function useDismiss(context, props) {
       });
     };
   }, [dataRef, floating, domReference, reference, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
   React.useEffect(() => {
     insideReactTreeRef.current = false;
   }, [outsidePress, outsidePressEvent]);
@@ -2755,50 +2659,9 @@ function useDismiss(context, props) {
   }, [enabled, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);
 }
 
-function useFloatingRootContext(options) {
-  const {
-    open = false,
-    onOpenChange: onOpenChangeProp,
-    elements: elementsProp
-  } = options;
-  const floatingId = useId();
-  const dataRef = React.useRef({});
-  const [events] = React.useState(() => createPubSub());
-  const nested = useFloatingParentNodeId() != null;
-  if (process.env.NODE_ENV !== "production") {
-    const optionDomReference = elementsProp.reference;
-    if (optionDomReference && !isElement(optionDomReference)) {
-      error('Cannot pass a virtual element to the `elements.reference` option,', 'as it must be a real DOM element. Use `refs.setPositionReference()`', 'instead.');
-    }
-  }
-  const [positionReference, setPositionReference] = React.useState(elementsProp.reference);
-  const onOpenChange = useEffectEvent((open, event, reason) => {
-    dataRef.current.openEvent = open ? event : undefined;
-    events.emit('openchange', {
-      open,
-      event,
-      reason,
-      nested
-    });
-    onOpenChangeProp == null || onOpenChangeProp(open, event, reason);
-  });
-  const refs = React.useMemo(() => ({
-    setPositionReference
-  }), []);
-  const elements = React.useMemo(() => ({
-    reference: positionReference || elementsProp.reference || null,
-    floating: elementsProp.floating || null,
-    domReference: elementsProp.reference
-  }), [positionReference, elementsProp.reference, elementsProp.floating]);
-  return React.useMemo(() => ({
-    dataRef,
-    open,
-    onOpenChange,
-    elements,
-    events,
-    floatingId,
-    refs
-  }), [open, onOpenChange, elements, events, floatingId, refs]);
+let devMessageSet;
+if (process.env.NODE_ENV !== "production") {
+  devMessageSet = /*#__PURE__*/new Set();
 }
 
 /**
@@ -2806,56 +2669,61 @@ function useFloatingRootContext(options) {
  * @see https://floating-ui.com/docs/useFloating
  */
 function useFloating(options) {
+  var _options$elements2;
   if (options === void 0) {
     options = {};
   }
   const {
+    open = false,
+    onOpenChange: unstable_onOpenChange,
     nodeId
   } = options;
-  const internalRootContext = useFloatingRootContext({
-    ...options,
-    elements: {
-      reference: null,
-      floating: null,
-      ...options.elements
+  if (process.env.NODE_ENV !== "production") {
+    var _options$elements;
+    const err = 'Floating UI: Cannot pass a virtual element to the ' + '`elements.reference` option, as it must be a real DOM element. ' + 'Use `refs.setPositionReference` instead.';
+    if ((_options$elements = options.elements) != null && _options$elements.reference && !isElement(options.elements.reference)) {
+      var _devMessageSet;
+      if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(err))) {
+        var _devMessageSet2;
+        (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(err);
+        console.error(err);
+      }
     }
-  });
-  const rootContext = options.rootContext || internalRootContext;
-  const computedElements = rootContext.elements;
-  const [_domReference, setDomReference] = React.useState(null);
-  const [positionReference, _setPositionReference] = React.useState(null);
-  const optionDomReference = computedElements == null ? void 0 : computedElements.reference;
-  const domReference = optionDomReference || _domReference;
-  const domReferenceRef = React.useRef(null);
+  }
+  const [_domReference, setDomReference] = useTransitionState(null);
+  const domReference = ((_options$elements2 = options.elements) == null ? void 0 : _options$elements2.reference) || _domReference;
+  const position = useFloating$1(options);
   const tree = useFloatingTree();
-  index(() => {
-    if (domReference) {
-      domReferenceRef.current = domReference;
-    }
-  }, [domReference]);
-  const position = useFloating$1({
-    ...options,
-    elements: {
-      ...computedElements,
-      ...(positionReference && {
-        reference: positionReference
-      })
+  const nested = useFloatingParentNodeId() != null;
+  const onOpenChange = useEffectEvent((open, event, reason) => {
+    if (open) {
+      dataRef.current.openEvent = event;
     }
+    events.emit('openchange', {
+      open,
+      event,
+      reason,
+      nested
+    });
+    unstable_onOpenChange == null || unstable_onOpenChange(open, event, reason);
   });
+  const domReferenceRef = React.useRef(null);
+  const dataRef = React.useRef({});
+  const events = useTransitionState(() => createPubSub())[0];
+  const floatingId = useId();
   const setPositionReference = React.useCallback(node => {
-    const computedPositionReference = isElement(node) ? {
+    const positionReference = isElement(node) ? {
       getBoundingClientRect: () => node.getBoundingClientRect(),
       contextElement: node
     } : node;
-    // Store the positionReference in state if the DOM reference is specified externally via the
-    // `elements.reference` option. This ensures that it won't be overridden on future renders.
-    _setPositionReference(computedPositionReference);
-    position.refs.setReference(computedPositionReference);
+    position.refs.setReference(positionReference);
   }, [position.refs]);
   const setReference = React.useCallback(node => {
     if (isElement(node) || node === null) {
       domReferenceRef.current = node;
-      setDomReference(node);
+      React.startTransition(() => {
+        setDomReference(node);
+      })
     }
 
     // Backwards-compatibility for passing a virtual element to `reference`
@@ -2880,13 +2748,16 @@ function useFloating(options) {
   }), [position.elements, domReference]);
   const context = React.useMemo(() => ({
     ...position,
-    ...rootContext,
     refs,
     elements,
-    nodeId
-  }), [position, refs, elements, nodeId, rootContext]);
+    dataRef,
+    nodeId,
+    floatingId,
+    events,
+    open,
+    onOpenChange
+  }), [position, nodeId, floatingId, events, open, onOpenChange, refs, elements]);
   index(() => {
-    rootContext.dataRef.current.floatingContext = context;
     const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);
     if (node) {
       node.context = context;
@@ -2913,8 +2784,9 @@ function useFocus(context, props) {
     open,
     onOpenChange,
     events,
-    dataRef,
+    refs,
     elements: {
+      floating,
       domReference
     }
   } = context;
@@ -3013,7 +2885,6 @@ function useFocus(context, props) {
 
           // Wait for the window blur listener to fire.
           timeoutRef.current = window.setTimeout(() => {
-            var _dataRef$current$floa;
             const activeEl = activeElement(domReference ? domReference.ownerDocument : document);
 
             // Focus left the page, keep it open.
@@ -3022,11 +2893,7 @@ function useFocus(context, props) {
             // When focusing the reference element (e.g. regular click), then
             // clicking into the floating element, prevent it from hiding.
             // Note: it must be focusable, e.g. `tabindex="-1"`.
-            // We can not rely on relatedTarget to point to the correct element
-            // as it will only point to the shadow host of the newly focused element
-            // and not the element that actually has received focus if it is located
-            // inside a shadow root.
-            if (contains((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || contains(domReference, activeEl) || movedToFocusGuard) {
+            if (contains(refs.floating.current, relatedTarget) || contains(domReference, relatedTarget) || movedToFocusGuard) {
               return;
             }
             onOpenChange(false, event.nativeEvent, 'focus');
@@ -3034,7 +2901,7 @@ function useFocus(context, props) {
         }
       }
     };
-  }, [enabled, visibleOnly, dataRef, domReference, onOpenChange]);
+  }, [enabled, visibleOnly, domReference, refs, onOpenChange]);
 }
 
 const ACTIVE_KEY = 'active';
@@ -3094,6 +2961,7 @@ function mergeProps(userProps, propsList, elementKey) {
     }, {})
   };
 }
+
 /**
  * Merges an array of interaction hooks' props into prop getters, allowing
  * event handler functions to be composed together without overwriting one
@@ -3107,18 +2975,19 @@ function useInteractions(propsList) {
   // The dependencies are a dynamic array, so we can't use the linter's
   // suggestion to add it to the deps array.
   const deps = propsList;
-  const getReferenceProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'reference'),
-  // eslint-disable-next-line react-hooks/exhaustive-deps
-  deps);
-  const getFloatingProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'floating'),
-  // eslint-disable-next-line react-hooks/exhaustive-deps
-  deps);
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
+  const getReferenceProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'reference'), deps);
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
+  const getFloatingProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'floating'), deps);
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
   const getItemProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'item'),
   // Granularly check for `item` changes, because the `getItemProps` getter
   // should be as referentially stable as possible since it may be passed as
   // a prop to many components. All `item` key values must therefore be
   // memoized.
-  // eslint-disable-next-line react-hooks/exhaustive-deps
   propsList.map(key => key == null ? void 0 : key.item));
   return React.useMemo(() => ({
     getReferenceProps,
@@ -3167,6 +3036,7 @@ function useListNavigation(context, props) {
   const {
     open,
     onOpenChange,
+    refs,
     elements: {
       domReference,
       floating
@@ -3197,14 +3067,14 @@ function useListNavigation(context, props) {
   if (process.env.NODE_ENV !== "production") {
     if (allowEscape) {
       if (!loop) {
-        warn('`useListNavigation` looping must be enabled to allow escaping.');
+        console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));
       }
       if (!virtual) {
-        warn('`useListNavigation` must be virtual to allow escaping.');
+        console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));
       }
     }
     if (orientation === 'vertical' && cols > 1) {
-      warn('In grid list navigation mode (`cols` > 1), the `orientation` should', 'be either "horizontal" or "both".');
+      console.warn(['Floating UI: In grid list navigation mode (`cols` > 1), the', '`orientation` should be either "horizontal" or "both".'].join(' '));
     }
   }
   const parentId = useFloatingParentNodeId();
@@ -3221,52 +3091,41 @@ function useListNavigation(context, props) {
   const disabledIndicesRef = useLatestRef(disabledIndices);
   const latestOpenRef = useLatestRef(open);
   const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);
-  const floatingRef = useLatestRef(floating);
-  const selectedIndexRef = useLatestRef(selectedIndex);
-  const [activeId, setActiveId] = React.useState();
-  const [virtualId, setVirtualId] = React.useState();
+  const [activeId, setActiveId] = useTransitionState();
+  const [virtualId, setVirtualId] = useTransitionState();
   const focusItem = useEffectEvent(function (listRef, indexRef, forceScrollIntoView) {
     if (forceScrollIntoView === void 0) {
       forceScrollIntoView = false;
     }
-    function runFocus(item) {
-      if (virtual) {
-        setActiveId(item.id);
-        tree == null || tree.events.emit('virtualfocus', item);
-        if (virtualItemRef) {
-          virtualItemRef.current = item;
-        }
-      } else {
-        enqueueFocus(item, {
-          preventScroll: true,
-          // Mac Safari does not move the virtual cursor unless the focus call
-          // is sync. However, for the very first focus call, we need to wait
-          // for the position to be ready in order to prevent unwanted
-          // scrolling. This means the virtual cursor will not move to the first
-          // item when first opening the floating element, but will on
-          // subsequent calls. `preventScroll` is supported in modern Safari,
-          // so we can use that instead.
-          // iOS Safari must be async or the first item will not be focused.
-          sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false
-        });
+    const item = listRef.current[indexRef.current];
+    if (!item) return;
+    if (virtual) {
+      setActiveId(item.id);
+      tree == null || tree.events.emit('virtualfocus', item);
+      if (virtualItemRef) {
+        virtualItemRef.current = item;
       }
-    }
-    const initialItem = listRef.current[indexRef.current];
-    if (initialItem) {
-      runFocus(initialItem);
+    } else {
+      enqueueFocus(item, {
+        preventScroll: true,
+        // Mac Safari does not move the virtual cursor unless the focus call
+        // is sync. However, for the very first focus call, we need to wait
+        // for the position to be ready in order to prevent unwanted
+        // scrolling. This means the virtual cursor will not move to the first
+        // item when first opening the floating element, but will on
+        // subsequent calls. `preventScroll` is supported in modern Safari,
+        // so we can use that instead.
+        // iOS Safari must be async or the first item will not be focused.
+        sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false
+      });
     }
     requestAnimationFrame(() => {
-      const waitedItem = listRef.current[indexRef.current] || initialItem;
-      if (!waitedItem) return;
-      if (!initialItem) {
-        runFocus(waitedItem);
-      }
       const scrollIntoViewOptions = scrollItemIntoViewRef.current;
       const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);
       if (shouldScrollIntoView) {
         // JSDOM doesn't support `.scrollIntoView()` but it's widely supported
         // by all browsers.
-        waitedItem.scrollIntoView == null || waitedItem.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {
+        item.scrollIntoView == null || item.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {
           block: 'nearest',
           inline: 'nearest'
         } : scrollIntoViewOptions);
@@ -3314,7 +3173,7 @@ function useListNavigation(context, props) {
     if (open && floating) {
       if (activeIndex == null) {
         forceSyncFocus.current = false;
-        if (selectedIndexRef.current != null) {
+        if (selectedIndex != null) {
           return;
         }
 
@@ -3351,7 +3210,7 @@ function useListNavigation(context, props) {
         forceScrollIntoViewRef.current = false;
       }
     }
-  }, [enabled, open, floating, activeIndex, selectedIndexRef, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);
+  }, [enabled, open, floating, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);
 
   // Ensure the parent floating element has focus when a nested child closes
   // to allow arrow key navigation to work after the pointer leaves the child.
@@ -3435,7 +3294,7 @@ function useListNavigation(context, props) {
           focusItem(listRef, indexRef);
           onNavigate(null);
           if (!virtual) {
-            enqueueFocus(floatingRef.current, {
+            enqueueFocus(refs.floating.current, {
               preventScroll: true
             });
           }
@@ -3443,7 +3302,7 @@ function useListNavigation(context, props) {
       })
     };
     return props;
-  }, [open, floatingRef, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);
+  }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);
   return React.useMemo(() => {
     if (!enabled) {
       return {};
@@ -3456,7 +3315,7 @@ function useListNavigation(context, props) {
       // If the floating element is animating out, ignore navigation. Otherwise,
       // the `activeIndex` gets set to 0 despite not being open so the next time
       // the user ArrowDowns, the first item won't be focused.
-      if (!latestOpenRef.current && event.currentTarget === floatingRef.current) {
+      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {
         return;
       }
       if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {
@@ -3492,9 +3351,9 @@ function useListNavigation(context, props) {
         // To calculate movements on the grid, we use hypothetical cell indices
         // as if every item was 1x1, then convert back to real indices.
         const cellMap = buildCellMap(sizes, cols, dense);
-        const minGridIndex = cellMap.findIndex(index => index != null && !isDisabled(listRef.current, index, disabledIndices));
+        const minGridIndex = cellMap.findIndex(index => index != null && !(disabledIndices != null && disabledIndices.includes(index)));
         // last enabled index
-        const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !isDisabled(listRef.current, index, disabledIndices) ? cellIndex : foundIndex, -1);
+        const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);
         indexRef.current = cellMap[getGridNavigatedIndex({
           current: cellMap.map(itemIndex => itemIndex != null ? listRef.current[itemIndex] : null)
         }, {
@@ -3504,10 +3363,10 @@ function useListNavigation(context, props) {
           cols,
           // treat undefined (empty grid spaces) as disabled indices so we
           // don't end up in them
-          disabledIndices: getCellIndices([...(disabledIndices || listRef.current.map((_, index) => isDisabled(listRef.current, index) ? index : undefined)), undefined], cellMap),
+          disabledIndices: getCellIndices([...(disabledIndices || []), undefined], cellMap),
           minIndex: minGridIndex,
           maxIndex: maxGridIndex,
-          prevIndex: getCellIndexOfCorner(indexRef.current > maxIndex ? minIndex : indexRef.current, sizes, cellMap, cols,
+          prevIndex: getCellIndexOfCorner(indexRef.current, sizes, cellMap, cols,
           // use a corner matching the edge closest to the direction
           // we're moving in so we don't end up in the same item. Prefer
           // top/left over bottom/right.
@@ -3655,7 +3514,7 @@ function useListNavigation(context, props) {
           }
         },
         onFocus() {
-          if (open && !virtual) {
+          if (open) {
             onNavigate(null);
           }
         },
@@ -3673,7 +3532,7 @@ function useListNavigation(context, props) {
       },
       item
     };
-  }, [domReference, floatingRef, activeId, virtualId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item, tree, virtualItemRef, itemSizes, dense]);
+  }, [domReference, refs, activeId, virtualId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item, tree, virtualItemRef, itemSizes, dense]);
 }
 
 const componentRoleToAriaRoleMap = /*#__PURE__*/new Map([['select', 'listbox'], ['combobox', 'listbox'], ['label', false]]);
@@ -3787,16 +3646,16 @@ function execWithArgsOrReturn(valueOrFn, args) {
   return typeof valueOrFn === 'function' ? valueOrFn(args) : valueOrFn;
 }
 function useDelayUnmount(open, durationMs) {
-  const [isMounted, setIsMounted] = React.useState(open);
+  const [isMounted, setIsMounted] = useTransitionState(open);
   if (open && !isMounted) {
     setIsMounted(true);
   }
   React.useEffect(() => {
-    if (!open && isMounted) {
+    if (!open) {
       const timeout = setTimeout(() => setIsMounted(false), durationMs);
       return () => clearTimeout(timeout);
     }
-  }, [open, isMounted, durationMs]);
+  }, [open, durationMs]);
   return isMounted;
 }
 /**
@@ -3819,11 +3678,19 @@ function useTransitionStatus(context, props) {
   } = props;
   const isNumberDuration = typeof duration === 'number';
   const closeDuration = (isNumberDuration ? duration : duration.close) || 0;
-  const [status, setStatus] = React.useState('unmounted');
+  const [initiated, setInitiated] = useTransitionState(false);
+  const [status, setStatus] = useTransitionState('unmounted');
   const isMounted = useDelayUnmount(open, closeDuration);
-  if (!isMounted && status === 'close') {
-    setStatus('unmounted');
-  }
+
+  // `initiated` check prevents this `setState` call from breaking
+  // <FloatingPortal />. This call is necessary to ensure subsequent opens
+  // after the initial one allows the correct side animation to play when the
+  // placement has changed.
+  index(() => {
+    if (initiated && !isMounted) {
+      setStatus('unmounted');
+    }
+  }, [initiated, isMounted]);
   index(() => {
     if (!floating) return;
     if (open) {
@@ -3835,6 +3702,7 @@ function useTransitionStatus(context, props) {
         cancelAnimationFrame(frame);
       };
     }
+    setInitiated(true);
     setStatus('close');
   }, [open, floating]);
   return {
@@ -3869,7 +3737,7 @@ function useTransitionStyles(context, props) {
   const isNumberDuration = typeof duration === 'number';
   const openDuration = (isNumberDuration ? duration : duration.open) || 0;
   const closeDuration = (isNumberDuration ? duration : duration.close) || 0;
-  const [styles, setStyles] = React.useState(() => ({
+  const [styles, setStyles] = useTransitionState(() => ({
     ...execWithArgsOrReturn(unstable_common, fnArgs),
     ...execWithArgsOrReturn(unstable_initial, fnArgs)
   }));
@@ -4095,7 +3963,7 @@ const inner = props => ({
     const item = listRef.current[index];
     if (process.env.NODE_ENV !== "production") {
       if (!state.placement.startsWith('bottom')) {
-        warn('`placement` side must be "bottom" when using the `inner`', 'middleware.');
+        console.warn(['Floating UI: `placement` side must be "bottom" when using the', '`inner` middleware.'].join(' '));
       }
     }
     if (!item) {
@@ -4261,7 +4129,7 @@ function isInside(point, rect) {
 /**
  * Generates a safe polygon area that the user can traverse without closing the
  * floating element once leaving the reference element.
- * @see https://floating-ui.com/docs/useHover#safepolygon
+ * @see https://floating-ui.com/docs/useHover#safePolygon
  */
 function safePolygon(options) {
   if (options === void 0) {
@@ -4453,4 +4321,4 @@ function safePolygon(options) {
   return fn;
 }
 
-export { Composite, CompositeItem, FloatingArrow, FloatingDelayGroup, FloatingFocusManager, FloatingList, FloatingNode, FloatingOverlay, FloatingPortal, FloatingTree, inner, safePolygon, useClick, useClientPoint, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingRootContext, useFloatingTree, useFocus, useHover, useId, useInnerOffset, useInteractions, useListItem, useListNavigation, useMergeRefs, useRole, useTransitionStatus, useTransitionStyles, useTypeahead };
+export { Composite, CompositeItem, FloatingArrow, FloatingDelayGroup, FloatingFocusManager, FloatingList, FloatingNode, FloatingOverlay, FloatingPortal, FloatingTree, inner, safePolygon, useClick, useClientPoint, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingTree, useFocus, useHover, useId, useInnerOffset, useInteractions, useListItem, useListNavigation, useMergeRefs, useRole, useTransitionStatus, useTransitionStyles, useTypeahead };
diff --git a/node_modules/@floating-ui/react/dist/floating-ui.react.umd.js b/node_modules/@floating-ui/react/dist/floating-ui.react.umd.js
index ea70d84..48fa836 100644
--- a/node_modules/@floating-ui/react/dist/floating-ui.react.umd.js
+++ b/node_modules/@floating-ui/react/dist/floating-ui.react.umd.js
@@ -25,9 +25,10 @@
 
   /**
    * Merges an array of refs into a single memoized callback ref or `null`.
-   * @see https://floating-ui.com/docs/react-utils#usemergerefs
+   * @see https://floating-ui.com/docs/useMergeRefs
    */
   function useMergeRefs(refs) {
+    // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
     return React__namespace.useMemo(() => {
       if (refs.every(ref => ref == null)) {
         return null;
@@ -41,16 +42,11 @@
           }
         });
       };
-      // eslint-disable-next-line react-hooks/exhaustive-deps
     }, refs);
   }
 
-  // https://github.com/mui/material-ui/issues/41190#issuecomment-2040873379
-  const SafeReact = {
-    ...React__namespace
-  };
-
-  const useInsertionEffect = SafeReact.useInsertionEffect;
+  // `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`
+  const useInsertionEffect = React__namespace[/*#__PURE__*/'useInsertionEffect'.toString()];
   const useSafeInsertionEffect = useInsertionEffect || (fn => fn());
   function useEffectEvent(callback) {
     const ref = React__namespace.useRef(() => {
@@ -301,10 +297,14 @@
       amount = 1
     } = _temp === void 0 ? {} : _temp;
     const list = listRef.current;
+    const isDisabledIndex = disabledIndices ? index => disabledIndices.includes(index) : index => {
+      const element = list[index];
+      return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';
+    };
     let index = startingIndex;
     do {
       index += decrement ? -amount : amount;
-    } while (index >= 0 && index <= list.length - 1 && isDisabled(list, index, disabledIndices));
+    } while (index >= 0 && index <= list.length - 1 && isDisabledIndex(index));
     return index;
   }
   function getGridNavigatedIndex(elementsRef, _ref) {
@@ -400,8 +400,8 @@
         if (prevIndex % cols !== 0) {
           nextIndex = findNonDisabledIndex(elementsRef, {
             startingIndex: prevIndex,
-            decrement: true,
-            disabledIndices
+            disabledIndices,
+            decrement: true
           });
           if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
             nextIndex = findNonDisabledIndex(elementsRef, {
@@ -480,20 +480,13 @@
   function getCellIndexOfCorner(index, sizes, cellMap, cols, corner) {
     if (index === -1) return -1;
     const firstCellIndex = cellMap.indexOf(index);
-    const sizeItem = sizes[index];
     switch (corner) {
       case 'tl':
         return firstCellIndex;
       case 'tr':
-        if (!sizeItem) {
-          return firstCellIndex;
-        }
-        return firstCellIndex + sizeItem.width - 1;
+        return firstCellIndex + sizes[index].width - 1;
       case 'bl':
-        if (!sizeItem) {
-          return firstCellIndex;
-        }
-        return firstCellIndex + (sizeItem.height - 1) * cols;
+        return firstCellIndex + (sizes[index].height - 1) * cols;
       case 'br':
         return cellMap.lastIndexOf(index);
     }
@@ -503,13 +496,6 @@
   function getCellIndices(indices, cellMap) {
     return cellMap.flatMap((index, cellIndex) => indices.includes(index) ? [cellIndex] : []);
   }
-  function isDisabled(list, index, disabledIndices) {
-    if (disabledIndices) {
-      return disabledIndices.includes(index);
-    }
-    const element = list[index];
-    return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';
-  }
 
   let rafId = 0;
   function enqueueFocus(el, options) {
@@ -567,12 +553,12 @@
    * Provides context for a list of items within the floating element.
    * @see https://floating-ui.com/docs/FloatingList
    */
-  function FloatingList(props) {
-    const {
+  function FloatingList(_ref) {
+    let {
       children,
       elementsRef,
       labelsRef
-    } = props;
+    } = _ref;
     const [map, setMap] = React__namespace.useState(() => new Map());
     const register = React__namespace.useCallback(node => {
       setMap(prevMap => new Map(prevMap).set(node, null));
@@ -604,18 +590,12 @@
       }), [register, unregister, map, elementsRef, labelsRef])
     }, children);
   }
-  /**
-   * Used to register a list item and its index (DOM position) in the
-   * `FloatingList`.
-   * @see https://floating-ui.com/docs/FloatingList#uselistitem
-   */
-  function useListItem(props) {
-    if (props === void 0) {
-      props = {};
-    }
-    const {
+  function useListItem(_temp) {
+    let {
       label
-    } = props;
+    } = _temp === void 0 ? {} : _temp;
+    const [index$1, setIndex] = React__namespace.useState(null);
+    const componentRef = React__namespace.useRef(null);
     const {
       register,
       unregister,
@@ -623,8 +603,6 @@
       elementsRef,
       labelsRef
     } = React__namespace.useContext(FloatingListContext);
-    const [index$1, setIndex] = React__namespace.useState(null);
-    const componentRef = React__namespace.useRef(null);
     const ref = React__namespace.useCallback(node => {
       componentRef.current = node;
       if (index$1 !== null) {
@@ -673,29 +651,19 @@
   const horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];
   const verticalKeys = [ARROW_UP, ARROW_DOWN];
   const allKeys = [...horizontalKeys, ...verticalKeys];
-
-  /**
-   * Creates a single tab stop whose items are navigated by arrow keys, which
-   * provides list navigation outside of floating element contexts.
-   *
-   * This is useful to enable navigation of a list of items that aren’t part of a
-   * floating element. A menubar is an example of a composite, with each reference
-   * element being an item.
-   * @see https://floating-ui.com/docs/Composite
-   */
-  const Composite = /*#__PURE__*/React__namespace.forwardRef(function Composite(props, forwardedRef) {
-    const {
+  const Composite = /*#__PURE__*/React__namespace.forwardRef(function Composite(_ref, forwardedRef) {
+    let {
       render,
       orientation = 'both',
       loop = true,
       cols = 1,
-      disabledIndices,
+      disabledIndices = [],
       activeIndex: externalActiveIndex,
       onNavigate: externalSetActiveIndex,
       itemSizes,
       dense = false,
-      ...domProps
-    } = props;
+      ...props
+    } = _ref;
     const [internalActiveIndex, internalSetActiveIndex] = React__namespace.useState(0);
     const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;
     const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);
@@ -709,21 +677,17 @@
     function handleKeyDown(event) {
       if (!allKeys.includes(event.key)) return;
       let nextIndex = activeIndex;
-      const minIndex = getMinIndex(elementsRef, disabledIndices);
-      const maxIndex = getMaxIndex(elementsRef, disabledIndices);
       if (isGrid) {
-        const sizes = itemSizes || Array.from({
-          length: elementsRef.current.length
-        }, () => ({
+        const sizes = itemSizes != null ? itemSizes : Array.from(Array(elementsRef.current.length), () => ({
           width: 1,
           height: 1
         }));
         // To calculate movements on the grid, we use hypothetical cell indices
         // as if every item was 1x1, then convert back to real indices.
         const cellMap = buildCellMap(sizes, cols, dense);
-        const minGridIndex = cellMap.findIndex(index => index != null && !isDisabled(elementsRef.current, index, disabledIndices));
+        const minGridIndex = cellMap.findIndex(index => index != null && !disabledIndices.includes(index));
         // last enabled index
-        const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !isDisabled(elementsRef.current, index, disabledIndices) ? cellIndex : foundIndex, -1);
+        const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);
         nextIndex = cellMap[getGridNavigatedIndex({
           current: cellMap.map(itemIndex => itemIndex ? elementsRef.current[itemIndex] : null)
         }, {
@@ -733,16 +697,18 @@
           cols,
           // treat undefined (empty grid spaces) as disabled indices so we
           // don't end up in them
-          disabledIndices: getCellIndices([...(disabledIndices || elementsRef.current.map((_, index) => isDisabled(elementsRef.current, index) ? index : undefined)), undefined], cellMap),
+          disabledIndices: getCellIndices([...disabledIndices, undefined], cellMap),
           minIndex: minGridIndex,
           maxIndex: maxGridIndex,
-          prevIndex: getCellIndexOfCorner(activeIndex > maxIndex ? minIndex : activeIndex, sizes, cellMap, cols,
+          prevIndex: getCellIndexOfCorner(activeIndex, sizes, cellMap, cols,
           // use a corner matching the edge closest to the direction we're
           // moving in so we don't end up in the same item. Prefer
           // top/left over bottom/right.
           event.key === ARROW_DOWN ? 'bl' : event.key === ARROW_RIGHT ? 'tr' : 'tl')
         })]; // navigated cell will never be nullish
       }
+      const minIndex = getMinIndex(elementsRef, disabledIndices);
+      const maxIndex = getMaxIndex(elementsRef, disabledIndices);
       const toEndKeys = {
         horizontal: [ARROW_RIGHT],
         vertical: [ARROW_DOWN],
@@ -785,12 +751,12 @@
       }
     }
     const computedProps = {
-      ...domProps,
+      ...props,
       ...renderElementProps,
       ref: forwardedRef,
       'aria-orientation': orientation === 'both' ? undefined : orientation,
       onKeyDown(e) {
-        domProps.onKeyDown == null || domProps.onKeyDown(e);
+        props.onKeyDown == null || props.onKeyDown(e);
         renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);
         handleKeyDown(e);
       }
@@ -801,14 +767,11 @@
       elementsRef: elementsRef
     }, renderJsx(render, computedProps)));
   });
-  /**
-   * @see https://floating-ui.com/docs/Composite
-   */
-  const CompositeItem = /*#__PURE__*/React__namespace.forwardRef(function CompositeItem(props, forwardedRef) {
-    const {
+  const CompositeItem = /*#__PURE__*/React__namespace.forwardRef(function CompositeItem(_ref2, forwardedRef) {
+    let {
       render,
-      ...domProps
-    } = props;
+      ...props
+    } = _ref2;
     const renderElementProps = render && typeof render !== 'function' ? render.props : {};
     const {
       activeIndex,
@@ -821,13 +784,13 @@
     const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);
     const isActive = activeIndex === index;
     const computedProps = {
-      ...domProps,
+      ...props,
       ...renderElementProps,
       ref: mergedRef,
       tabIndex: isActive ? 0 : -1,
       'data-active': isActive ? '' : undefined,
       onFocus(e) {
-        domProps.onFocus == null || domProps.onFocus(e);
+        props.onFocus == null || props.onFocus(e);
         renderElementProps.onFocus == null || renderElementProps.onFocus(e);
         onNavigate(index);
       }
@@ -852,67 +815,41 @@
 
   let serverHandoffComplete = false;
   let count = 0;
-  const genId = () => // Ensure the id is unique with multiple independent versions of Floating UI
-  // on <React 18
-  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++;
+  const genId = () => "floating-ui-" + count++;
   function useFloatingId() {
     const [id, setId] = React__namespace.useState(() => serverHandoffComplete ? genId() : undefined);
+
+    // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
     index(() => {
       if (id == null) {
         setId(genId());
       }
-      // eslint-disable-next-line react-hooks/exhaustive-deps
     }, []);
     React__namespace.useEffect(() => {
-      serverHandoffComplete = true;
+      if (!serverHandoffComplete) {
+        serverHandoffComplete = true;
+      }
     }, []);
     return id;
   }
-  const useReactId = SafeReact.useId;
+
+  // `toString()` prevents bundlers from trying to `import { useId } from 'react'`
+  const useReactId = React__namespace[/*#__PURE__*/'useId'.toString()];
 
   /**
    * Uses React 18's built-in `useId()` when available, or falls back to a
    * slightly less performant (requiring a double render) implementation for
    * earlier React versions.
-   * @see https://floating-ui.com/docs/react-utils#useid
+   * @see https://floating-ui.com/docs/useId
    */
   const useId = useReactId || useFloatingId;
 
-  let devMessageSet;
-  {
-    devMessageSet = /*#__PURE__*/new Set();
-  }
-  function warn() {
-    var _devMessageSet;
-    for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
-      messages[_key] = arguments[_key];
-    }
-    const message = "Floating UI: " + messages.join(' ');
-    if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {
-      var _devMessageSet2;
-      (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);
-      console.warn(message);
-    }
-  }
-  function error() {
-    var _devMessageSet3;
-    for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
-      messages[_key2] = arguments[_key2];
-    }
-    const message = "Floating UI: " + messages.join(' ');
-    if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {
-      var _devMessageSet4;
-      (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);
-      console.error(message);
-    }
-  }
-
   /**
    * Renders a pointing arrow triangle.
    * @see https://floating-ui.com/docs/FloatingArrow
    */
-  const FloatingArrow = /*#__PURE__*/React__namespace.forwardRef(function FloatingArrow(props, ref) {
-    const {
+  const FloatingArrow = /*#__PURE__*/React__namespace.forwardRef(function FloatingArrow(_ref, ref) {
+    let {
       context: {
         placement,
         elements: {
@@ -934,10 +871,10 @@
         ...restStyle
       } = {},
       ...rest
-    } = props;
+    } = _ref;
     {
       if (!ref) {
-        warn('The `ref` prop is required for `FloatingArrow`.');
+        console.warn('Floating UI: The `ref` prop is required for the `FloatingArrow`', 'component.');
       }
     }
     const clipPathId = useId();
@@ -947,8 +884,8 @@
 
     // Strokes must be double the border width, this ensures the stroke's width
     // works as you'd expect.
-    const computedStrokeWidth = strokeWidth * 2;
-    const halfStrokeWidth = computedStrokeWidth / 2;
+    strokeWidth *= 2;
+    const halfStrokeWidth = strokeWidth / 2;
     const svgX = width / 2 * (tipRadius / -8 + 1);
     const svgY = height / 2 * tipRadius / 4;
     const [side, alignment] = placement.split('-');
@@ -962,7 +899,9 @@
     }
     const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : '';
     const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y : '';
-    const dValue = d || 'M0,0' + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + ' Z';
+    const dValue = d ||
+    // biome-ignore lint/style/useTemplate: readability
+    'M0,0' + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + ' Z';
     const rotation = {
       top: isCustomShape ? 'rotate(180deg)' : '',
       left: isCustomShape ? 'rotate(90deg)' : 'rotate(-90deg)',
@@ -972,7 +911,7 @@
     return /*#__PURE__*/React__namespace.createElement("svg", _extends({}, rest, {
       "aria-hidden": true,
       ref: ref,
-      width: isCustomShape ? width : width + computedStrokeWidth,
+      width: isCustomShape ? width : width + strokeWidth,
       height: width,
       viewBox: "0 0 " + width + " " + (height > width ? height : width),
       style: {
@@ -980,27 +919,27 @@
         pointerEvents: 'none',
         [xOffsetProp]: arrowX,
         [yOffsetProp]: arrowY,
-        [side]: isVerticalSide || isCustomShape ? '100%' : "calc(100% - " + computedStrokeWidth / 2 + "px)",
+        [side]: isVerticalSide || isCustomShape ? '100%' : "calc(100% - " + strokeWidth / 2 + "px)",
         transform: "" + rotation + (transform != null ? transform : ''),
         ...restStyle
       }
-    }), computedStrokeWidth > 0 && /*#__PURE__*/React__namespace.createElement("path", {
+    }), strokeWidth > 0 && /*#__PURE__*/React__namespace.createElement("path", {
       clipPath: "url(#" + clipPathId + ")",
       fill: "none",
       stroke: stroke
       // Account for the stroke on the fill path rendered below.
       ,
-      strokeWidth: computedStrokeWidth + (d ? 0 : 1),
+      strokeWidth: strokeWidth + (d ? 0 : 1),
       d: dValue
     }), /*#__PURE__*/React__namespace.createElement("path", {
-      stroke: computedStrokeWidth && !d ? rest.fill : 'none',
+      stroke: strokeWidth && !d ? rest.fill : 'none',
       d: dValue
     }), /*#__PURE__*/React__namespace.createElement("clipPath", {
       id: clipPathId
     }, /*#__PURE__*/React__namespace.createElement("rect", {
       x: -halfStrokeWidth,
       y: halfStrokeWidth * (isCustomShape ? -1 : 1),
-      width: width + computedStrokeWidth,
+      width: width + strokeWidth,
       height: width
     })));
   });
@@ -1024,24 +963,14 @@
 
   const FloatingNodeContext = /*#__PURE__*/React__namespace.createContext(null);
   const FloatingTreeContext = /*#__PURE__*/React__namespace.createContext(null);
-
-  /**
-   * Returns the parent node id for nested floating elements, if available.
-   * Returns `null` for top-level floating elements.
-   */
   const useFloatingParentNodeId = () => {
     var _React$useContext;
     return ((_React$useContext = React__namespace.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
   };
-
-  /**
-   * Returns the nearest floating tree context, if available.
-   */
   const useFloatingTree = () => React__namespace.useContext(FloatingTreeContext);
 
   /**
-   * Registers a node into the `FloatingTree`, returning its id.
-   * @see https://floating-ui.com/docs/FloatingTree
+   * Registers a node into the floating tree, returning its id.
    */
   function useFloatingNodeId(customParentId) {
     const id = useId();
@@ -1065,11 +994,11 @@
    * Provides parent node context for nested floating elements.
    * @see https://floating-ui.com/docs/FloatingTree
    */
-  function FloatingNode(props) {
-    const {
+  function FloatingNode(_ref) {
+    let {
       children,
       id
-    } = props;
+    } = _ref;
     const parentId = useFloatingParentNodeId();
     return /*#__PURE__*/React__namespace.createElement(FloatingNodeContext.Provider, {
       value: React__namespace.useMemo(() => ({
@@ -1081,18 +1010,14 @@
 
   /**
    * Provides context for nested floating elements when they are not children of
-   * each other on the DOM.
-   * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:
-   * - The `bubbles` option in the `useDismiss()` Hook
-   * - Nested virtual list navigation
-   * - Nested floating elements that each open on hover
-   * - Custom communication between parent and child floating elements
+   * each other on the DOM (i.e. portalled to a common node, rather than their
+   * respective parent).
    * @see https://floating-ui.com/docs/FloatingTree
    */
-  function FloatingTree(props) {
-    const {
+  function FloatingTree(_ref2) {
+    let {
       children
-    } = props;
+    } = _ref2;
     const nodesRef = React__namespace.useRef([]);
     const addNode = React__namespace.useCallback(node => {
       nodesRef.current = [...nodesRef.current, node];
@@ -1150,7 +1075,8 @@
       elements: {
         domReference,
         floating
-      }
+      },
+      refs
     } = context;
     const {
       enabled = true,
@@ -1165,9 +1091,9 @@
     const handleCloseRef = useLatestRef(handleClose);
     const delayRef = useLatestRef(delay);
     const pointerTypeRef = React__namespace.useRef();
-    const timeoutRef = React__namespace.useRef(-1);
+    const timeoutRef = React__namespace.useRef();
     const handlerRef = React__namespace.useRef();
-    const restTimeoutRef = React__namespace.useRef(-1);
+    const restTimeoutRef = React__namespace.useRef();
     const blockMouseMoveRef = React__namespace.useRef(true);
     const performedPointerEventsMutationRef = React__namespace.useRef(false);
     const unbindMouseMoveRef = React__namespace.useRef(() => {});
@@ -1223,24 +1149,24 @@
       const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);
       if (closeDelay && !handlerRef.current) {
         clearTimeout(timeoutRef.current);
-        timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);
+        timeoutRef.current = setTimeout(() => onOpenChange(false, event, reason), closeDelay);
       } else if (runElseBranch) {
         clearTimeout(timeoutRef.current);
         onOpenChange(false, event, reason);
       }
     }, [delayRef, onOpenChange]);
-    const cleanupMouseMoveHandler = useEffectEvent(() => {
+    const cleanupMouseMoveHandler = React__namespace.useCallback(() => {
       unbindMouseMoveRef.current();
       handlerRef.current = undefined;
-    });
-    const clearPointerEvents = useEffectEvent(() => {
+    }, []);
+    const clearPointerEvents = React__namespace.useCallback(() => {
       if (performedPointerEventsMutationRef.current) {
-        const body = getDocument(floating).body;
+        const body = getDocument(refs.floating.current).body;
         body.style.pointerEvents = '';
         body.removeAttribute(safePolygonIdentifier);
         performedPointerEventsMutationRef.current = false;
       }
-    });
+    }, [refs]);
 
     // Registering the mouse events on the reference directly to bypass React's
     // delegation system. If the cursor was on a disabled element and then entered
@@ -1255,12 +1181,12 @@
       function onMouseEnter(event) {
         clearTimeout(timeoutRef.current);
         blockMouseMoveRef.current = false;
-        if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && !getDelay(delayRef.current, 'open')) {
+        if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {
           return;
         }
         const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);
         if (openDelay) {
-          timeoutRef.current = window.setTimeout(() => {
+          timeoutRef.current = setTimeout(() => {
             onOpenChange(true, event, 'hover');
           }, openDelay);
         } else {
@@ -1268,17 +1194,19 @@
         }
       }
       function onMouseLeave(event) {
-        if (isClickLikeOpenEvent()) return;
+        if (isClickLikeOpenEvent()) {
+          return;
+        }
         unbindMouseMoveRef.current();
         const doc = getDocument(floating);
         clearTimeout(restTimeoutRef.current);
-        if (handleCloseRef.current && dataRef.current.floatingContext) {
+        if (handleCloseRef.current) {
           // Prevent clearing `onScrollMouseLeave` timeout.
           if (!open) {
             clearTimeout(timeoutRef.current);
           }
           handlerRef.current = handleCloseRef.current({
-            ...dataRef.current.floatingContext,
+            ...context,
             tree,
             x: event.clientX,
             y: event.clientY,
@@ -1309,10 +1237,11 @@
       // did not move.
       // https://github.com/floating-ui/floating-ui/discussions/1692
       function onScrollMouseLeave(event) {
-        if (isClickLikeOpenEvent()) return;
-        if (!dataRef.current.floatingContext) return;
+        if (isClickLikeOpenEvent()) {
+          return;
+        }
         handleCloseRef.current == null || handleCloseRef.current({
-          ...dataRef.current.floatingContext,
+          ...context,
           tree,
           x: event.clientX,
           y: event.clientY,
@@ -1379,6 +1308,8 @@
         clearPointerEvents();
       }
     }, [open, cleanupMouseMoveHandler, clearPointerEvents]);
+
+    // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
     React__namespace.useEffect(() => {
       return () => {
         cleanupMouseMoveHandler();
@@ -1399,23 +1330,15 @@
           onPointerDown: setPointerRef,
           onPointerEnter: setPointerRef,
           onMouseMove(event) {
-            function handleMouseMove() {
-              if (!blockMouseMoveRef.current) {
-                onOpenChange(true, event.nativeEvent, 'hover');
-              }
-            }
-            if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) {
-              return;
-            }
             if (open || restMs === 0) {
               return;
             }
             clearTimeout(restTimeoutRef.current);
-            if (pointerTypeRef.current === 'touch') {
-              handleMouseMove();
-            } else {
-              restTimeoutRef.current = window.setTimeout(handleMouseMove, restMs);
-            }
+            restTimeoutRef.current = setTimeout(() => {
+              if (!blockMouseMoveRef.current) {
+                onOpenChange(true, event.nativeEvent, 'hover');
+              }
+            }, restMs);
           }
         },
         floating: {
@@ -1427,36 +1350,30 @@
           }
         }
       };
-    }, [enabled, mouseOnly, open, restMs, onOpenChange, closeWithDelay]);
+    }, [enabled, restMs, open, onOpenChange, closeWithDelay]);
   }
 
-  const NOOP = () => {};
   const FloatingDelayGroupContext = /*#__PURE__*/React__namespace.createContext({
     delay: 0,
     initialDelay: 0,
     timeoutMs: 0,
     currentId: null,
-    setCurrentId: NOOP,
-    setState: NOOP,
+    setCurrentId: () => {},
+    setState: () => {},
     isInstantPhase: false
   });
-
-  /**
-   * @deprecated
-   * Use the return value of `useDelayGroup()` instead.
-   */
   const useDelayGroupContext = () => React__namespace.useContext(FloatingDelayGroupContext);
   /**
    * Provides context for a group of floating elements that should share a
    * `delay`.
    * @see https://floating-ui.com/docs/FloatingDelayGroup
    */
-  function FloatingDelayGroup(props) {
-    const {
+  const FloatingDelayGroup = _ref => {
+    let {
       children,
       delay,
       timeoutMs = 0
-    } = props;
+    } = _ref;
     const [state, setState] = React__namespace.useReducer((prev, next) => ({
       ...prev,
       ...next
@@ -1477,20 +1394,18 @@
       if (state.currentId) {
         if (initialCurrentIdRef.current === null) {
           initialCurrentIdRef.current = state.currentId;
-        } else if (!state.isInstantPhase) {
+        } else {
           setState({
             isInstantPhase: true
           });
         }
       } else {
-        if (state.isInstantPhase) {
-          setState({
-            isInstantPhase: false
-          });
-        }
+        setState({
+          isInstantPhase: false
+        });
         initialCurrentIdRef.current = null;
       }
-    }, [state.currentId, state.isInstantPhase]);
+    }, [state.currentId]);
     return /*#__PURE__*/React__namespace.createElement(FloatingDelayGroupContext.Provider, {
       value: React__namespace.useMemo(() => ({
         ...state,
@@ -1498,43 +1413,33 @@
         setCurrentId
       }), [state, setCurrentId])
     }, children);
-  }
-  /**
-   * Enables grouping when called inside a component that's a child of a
-   * `FloatingDelayGroup`.
-   * @see https://floating-ui.com/docs/FloatingDelayGroup
-   */
-  function useDelayGroup(context, options) {
-    if (options === void 0) {
-      options = {};
-    }
-    const {
+  };
+  const useDelayGroup = (_ref2, _ref3) => {
+    let {
       open,
-      onOpenChange,
-      floatingId
-    } = context;
-    const {
-      id: optionId
-    } = options;
-    const id = optionId != null ? optionId : floatingId;
-    const groupContext = useDelayGroupContext();
+      onOpenChange
+    } = _ref2;
+    let {
+      id
+    } = _ref3;
     const {
       currentId,
       setCurrentId,
       initialDelay,
       setState,
       timeoutMs
-    } = groupContext;
+    } = useDelayGroupContext();
     index(() => {
-      if (!currentId) return;
-      setState({
-        delay: {
-          open: 1,
-          close: getDelay(initialDelay, 'close')
+      if (currentId) {
+        setState({
+          delay: {
+            open: 1,
+            close: getDelay(initialDelay, 'close')
+          }
+        });
+        if (currentId !== id) {
+          onOpenChange(false);
         }
-      });
-      if (currentId !== id) {
-        onOpenChange(false);
       }
     }, [id, onOpenChange, setState, currentId, initialDelay]);
     index(() => {
@@ -1545,7 +1450,6 @@
           currentId: null
         });
       }
-      if (!currentId) return;
       if (!open && currentId === id) {
         if (timeoutMs) {
           const timeout = window.setTimeout(unset, timeoutMs);
@@ -1557,11 +1461,11 @@
       }
     }, [open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);
     index(() => {
-      if (setCurrentId === NOOP || !open) return;
-      setCurrentId(id);
+      if (open) {
+        setCurrentId(id);
+      }
     }, [open, setCurrentId, id]);
-    return groupContext;
-  }
+  };
 
   /*!
   * tabbable 6.2.0
@@ -2096,16 +2000,6 @@
     }
     return sortByOrder(candidates);
   };
-  var isTabbable = function isTabbable(node, options) {
-    options = options || {};
-    if (!node) {
-      throw new Error('No node provided');
-    }
-    if (matches.call(node, candidateSelector) === false) {
-      return false;
-    }
-    return isNodeMatchingSelectorTabbable(options, node);
-  };
 
   function getAncestors(nodes, id) {
     var _nodes$find;
@@ -2199,8 +2093,7 @@
       if (!parent || elementsToStop.has(parent)) {
         return;
       }
-      [].forEach.call(parent.children, node => {
-        if (getNodeName(node) === 'script') return;
+      Array.prototype.forEach.call(parent.children, node => {
         if (elementsToKeep.has(node)) {
           deep(node);
         } else {
@@ -2299,6 +2192,7 @@
     const elements = container.querySelectorAll('[data-tabindex]');
     elements.forEach(element => {
       const tabindex = element.dataset.tabindex;
+      // biome-ignore lint/performance/noDelete: purity
       delete element.dataset.tabindex;
       if (tabindex) {
         element.setAttribute('tabindex', tabindex);
@@ -2360,86 +2254,77 @@
   });
 
   const PortalContext = /*#__PURE__*/React__namespace.createContext(null);
-  const attr = /*#__PURE__*/createAttribute('portal');
-
-  /**
-   * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode
-   */
-  function useFloatingPortalNode(props) {
-    if (props === void 0) {
-      props = {};
-    }
-    const {
+  function useFloatingPortalNode(_temp) {
+    let {
       id,
       root
-    } = props;
+    } = _temp === void 0 ? {} : _temp;
+    const [portalNode, setPortalNode] = React__namespace.useState(null);
     const uniqueId = useId();
     const portalContext = usePortalContext();
-    const [portalNode, setPortalNode] = React__namespace.useState(null);
-    const portalNodeRef = React__namespace.useRef(null);
+    const data = React__namespace.useMemo(() => ({
+      id,
+      root,
+      portalContext,
+      uniqueId
+    }), [id, root, portalContext, uniqueId]);
+    const dataRef = React__namespace.useRef();
+
+    // biome-ignore lint/correctness/useExhaustiveDependencies: `data` is intentionally specified
     index(() => {
       return () => {
         portalNode == null || portalNode.remove();
-        // Allow the subsequent layout effects to create a new node on updates.
-        // The portal node will still be cleaned up on unmount.
-        // https://github.com/floating-ui/floating-ui/issues/2454
-        queueMicrotask(() => {
-          portalNodeRef.current = null;
-        });
       };
-    }, [portalNode]);
+    }, [portalNode, data]);
     index(() => {
-      // Wait for the uniqueId to be generated before creating the portal node in
-      // React <18 (using `useFloatingId` instead of the native `useId`).
-      // https://github.com/floating-ui/floating-ui/issues/2778
-      if (!uniqueId) return;
-      if (portalNodeRef.current) return;
+      if (dataRef.current === data) return;
+      dataRef.current = data;
+      const {
+        id,
+        root,
+        portalContext,
+        uniqueId
+      } = data;
       const existingIdRoot = id ? document.getElementById(id) : null;
-      if (!existingIdRoot) return;
-      const subRoot = document.createElement('div');
-      subRoot.id = uniqueId;
-      subRoot.setAttribute(attr, '');
-      existingIdRoot.appendChild(subRoot);
-      portalNodeRef.current = subRoot;
-      setPortalNode(subRoot);
-    }, [id, uniqueId]);
-    index(() => {
-      if (!uniqueId) return;
-      if (portalNodeRef.current) return;
-      let container = root || (portalContext == null ? void 0 : portalContext.portalNode);
-      if (container && !isElement(container)) container = container.current;
-      container = container || document.body;
-      let idWrapper = null;
-      if (id) {
-        idWrapper = document.createElement('div');
-        idWrapper.id = id;
-        container.appendChild(idWrapper);
-      }
-      const subRoot = document.createElement('div');
-      subRoot.id = uniqueId;
-      subRoot.setAttribute(attr, '');
-      container = idWrapper || container;
-      container.appendChild(subRoot);
-      portalNodeRef.current = subRoot;
-      setPortalNode(subRoot);
-    }, [id, root, uniqueId, portalContext]);
+      const attr = createAttribute('portal');
+      if (existingIdRoot) {
+        const subRoot = document.createElement('div');
+        subRoot.id = uniqueId;
+        subRoot.setAttribute(attr, '');
+        existingIdRoot.appendChild(subRoot);
+        setPortalNode(subRoot);
+      } else {
+        let container = root || (portalContext == null ? void 0 : portalContext.portalNode);
+        if (container && !isElement(container)) container = container.current;
+        container = container || document.body;
+        let idWrapper = null;
+        if (id) {
+          idWrapper = document.createElement('div');
+          idWrapper.id = id;
+          container.appendChild(idWrapper);
+        }
+        const subRoot = document.createElement('div');
+        subRoot.id = uniqueId;
+        subRoot.setAttribute(attr, '');
+        container = idWrapper || container;
+        container.appendChild(subRoot);
+        setPortalNode(subRoot);
+      }
+    }, [data]);
     return portalNode;
   }
   /**
    * Portals the floating element into a given container element — by default,
    * outside of the app root and into the body.
-   * This is necessary to ensure the floating element can appear outside any
-   * potential parent containers that cause clipping (such as `overflow: hidden`),
-   * while retaining its location in the React tree.
    * @see https://floating-ui.com/docs/FloatingPortal
    */
-  function FloatingPortal(props) {
-    const {
+  function FloatingPortal(_ref) {
+    let {
       children,
       id,
       root = null,
       preserveTabOrder = true
-    } = props;
+    } = _ref;
     const portalNode = useFloatingPortalNode({
       id,
       root
@@ -2529,18 +2414,12 @@
   let previouslyFocusedElements = [];
   function addPreviouslyFocusedElement(element) {
     previouslyFocusedElements = previouslyFocusedElements.filter(el => el.isConnected);
-    let tabbableEl = element;
-    if (!tabbableEl || getNodeName(tabbableEl) === 'body') return;
-    if (!isTabbable(tabbableEl, getTabbableOptions())) {
-      const tabbableChild = tabbable(tabbableEl, getTabbableOptions())[0];
-      if (tabbableChild) {
-        tabbableEl = tabbableChild;
+    if (element && getNodeName(element) !== 'body') {
+      previouslyFocusedElements.push(element);
+      if (previouslyFocusedElements.length > LIST_LIMIT) {
+        previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);
       }
     }
-    previouslyFocusedElements.push(tabbableEl);
-    if (previouslyFocusedElements.length > LIST_LIMIT) {
-      previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);
-    }
   }
   function getPreviouslyFocusedElement() {
     return previouslyFocusedElements.slice().reverse().find(el => el.isConnected);
@@ -2730,21 +2609,16 @@
       const doc = getDocument(floating);
       const previouslyFocusedElement = activeElement(doc);
       const contextData = dataRef.current;
-      let openEvent = contextData.openEvent;
       addPreviouslyFocusedElement(previouslyFocusedElement);
 
       // Dismissing via outside press should always ignore `returnFocus` to
       // prevent unwanted scrolling.
       function onOpenChange(_ref) {
         let {
-          open,
           reason,
           event,
           nested
         } = _ref;
-        if (open) {
-          openEvent = event;
-        }
         if (reason === 'escape-key' && refs.domReference.current) {
           addPreviouslyFocusedElement(refs.domReference.current);
         }
@@ -2767,14 +2641,12 @@
           var _node$context5;
           return contains((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);
         });
-        const shouldFocusReference = isFocusInsideFloatingTree || openEvent && ['click', 'mousedown'].includes(openEvent.type);
+        const shouldFocusReference = isFocusInsideFloatingTree || contextData.openEvent && ['click', 'mousedown'].includes(contextData.openEvent.type);
         if (shouldFocusReference && refs.domReference.current) {
           addPreviouslyFocusedElement(refs.domReference.current);
         }
         const returnElement = getPreviouslyFocusedElement();
-        if (
-        // eslint-disable-next-line react-hooks/exhaustive-deps
-        returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(returnElement) && (
+        if (returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(returnElement) && (
         // If the focus moved somewhere else after mount, avoid returning focus
         // since it likely entered a different element which should be
         // respected: https://github.com/floating-ui/floating-ui/issues/2607
@@ -2882,17 +2754,18 @@
   }
 
   const activeLocks = /*#__PURE__*/new Set();
+
   /**
    * Provides base styling for a fixed overlay element to dim content or block
    * pointer events behind a floating element.
    * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.
    * @see https://floating-ui.com/docs/FloatingOverlay
    */
-  const FloatingOverlay = /*#__PURE__*/React__namespace.forwardRef(function FloatingOverlay(props, ref) {
-    const {
+  const FloatingOverlay = /*#__PURE__*/React__namespace.forwardRef(function FloatingOverlay(_ref, ref) {
+    let {
       lockScroll = false,
       ...rest
-    } = props;
+    } = _ref;
     const lockId = useId();
     index(() => {
       if (!lockScroll) return;
@@ -3066,15 +2939,15 @@
     }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);
   }
 
-  function createVirtualElement(domElement, data) {
+  function createVirtualElement(domRef, data) {
     let offsetX = null;
     let offsetY = null;
     let isAutoUpdateEvent = false;
     return {
-      contextElement: domElement || undefined,
+      contextElement: domRef.current || undefined,
       getBoundingClientRect() {
-        var _data$dataRef$current;
-        const domRect = (domElement == null ? void 0 : domElement.getBoundingClientRect()) || {
+        var _domRef$current, _data$dataRef$current;
+        const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {
           width: 0,
           height: 0,
           x: 0,
@@ -3134,12 +3007,11 @@
     }
     const {
       open,
+      refs,
       dataRef,
       elements: {
-        floating,
-        domReference
-      },
-      refs
+        floating
+      }
     } = context;
     const {
       enabled = true,
@@ -3160,7 +3032,7 @@
       if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {
         return;
       }
-      refs.setPositionReference(createVirtualElement(domReference, {
+      refs.setPositionReference(createVirtualElement(refs.domReference, {
         x,
         y,
         axis,
@@ -3188,10 +3060,10 @@
     const addListener = React__namespace.useCallback(() => {
       // Explicitly specified `x`/`y` coordinates shouldn't add a listener.
       if (!openCheck || !enabled || x != null || y != null) return;
-      const win = getWindow(floating);
+      const win = getWindow(refs.floating.current);
       function handleMouseMove(event) {
         const target = getTarget(event);
-        if (!contains(floating, target)) {
+        if (!contains(refs.floating.current, target)) {
           setReference(event.clientX, event.clientY);
         } else {
           win.removeEventListener('mousemove', handleMouseMove);
@@ -3207,8 +3079,10 @@
         cleanupListenerRef.current = cleanup;
         return cleanup;
       }
-      refs.setPositionReference(domReference);
-    }, [openCheck, enabled, x, y, floating, dataRef, refs, domReference, setReference]);
+      refs.setPositionReference(refs.domReference.current);
+    }, [dataRef, enabled, openCheck, refs, setReference, x, y]);
+
+    // biome-ignore lint/correctness/useExhaustiveDependencies: intentionally specifying `reactive`
     React__namespace.useEffect(() => {
       return addListener();
     }, [addListener, reactive]);
@@ -3276,6 +3150,7 @@
     const {
       open,
       onOpenChange,
+      nodeId,
       elements: {
         reference,
         domReference,
@@ -3308,11 +3183,9 @@
       outsidePress: outsidePressCapture
     } = normalizeProp(capture);
     const closeOnEscapeKeyDown = useEffectEvent(event => {
-      var _dataRef$current$floa;
       if (!open || !enabled || !escapeKey || event.key !== 'Escape') {
         return;
       }
-      const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;
       const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
       if (!escapeKeyBubbles) {
         event.stopPropagation();
@@ -3342,7 +3215,6 @@
       (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener('keydown', callback);
     });
     const closeOnPressOutside = useEffectEvent(event => {
-      var _dataRef$current$floa2;
       // Given developers can stop the propagation of the synthetic event,
       // we can only be confident with a positive value.
       const insideReactTree = insideReactTreeRef.current;
@@ -3408,7 +3280,6 @@
           return;
         }
       }
-      const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId;
       const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {
         var _node$context;
         return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);
@@ -3484,6 +3355,8 @@
         });
       };
     }, [dataRef, floating, domReference, reference, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);
+
+    // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
     React__namespace.useEffect(() => {
       insideReactTreeRef.current = false;
     }, [outsidePress, outsidePressEvent]);
@@ -3516,50 +3389,9 @@
     }, [enabled, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);
   }
 
-  function useFloatingRootContext(options) {
-    const {
-      open = false,
-      onOpenChange: onOpenChangeProp,
-      elements: elementsProp
-    } = options;
-    const floatingId = useId();
-    const dataRef = React__namespace.useRef({});
-    const [events] = React__namespace.useState(() => createPubSub());
-    const nested = useFloatingParentNodeId() != null;
-    {
-      const optionDomReference = elementsProp.reference;
-      if (optionDomReference && !isElement(optionDomReference)) {
-        error('Cannot pass a virtual element to the `elements.reference` option,', 'as it must be a real DOM element. Use `refs.setPositionReference()`', 'instead.');
-      }
-    }
-    const [positionReference, setPositionReference] = React__namespace.useState(elementsProp.reference);
-    const onOpenChange = useEffectEvent((open, event, reason) => {
-      dataRef.current.openEvent = open ? event : undefined;
-      events.emit('openchange', {
-        open,
-        event,
-        reason,
-        nested
-      });
-      onOpenChangeProp == null || onOpenChangeProp(open, event, reason);
-    });
-    const refs = React__namespace.useMemo(() => ({
-      setPositionReference
-    }), []);
-    const elements = React__namespace.useMemo(() => ({
-      reference: positionReference || elementsProp.reference || null,
-      floating: elementsProp.floating || null,
-      domReference: elementsProp.reference
-    }), [positionReference, elementsProp.reference, elementsProp.floating]);
-    return React__namespace.useMemo(() => ({
-      dataRef,
-      open,
-      onOpenChange,
-      elements,
-      events,
-      floatingId,
-      refs
-    }), [open, onOpenChange, elements, events, floatingId, refs]);
+  let devMessageSet;
+  {
+    devMessageSet = /*#__PURE__*/new Set();
   }
 
   /**
@@ -3567,51 +3399,54 @@
    * @see https://floating-ui.com/docs/useFloating
    */
   function useFloating(options) {
+    var _options$elements2;
     if (options === void 0) {
       options = {};
     }
     const {
+      open = false,
+      onOpenChange: unstable_onOpenChange,
       nodeId
     } = options;
-    const internalRootContext = useFloatingRootContext({
-      ...options,
-      elements: {
-        reference: null,
-        floating: null,
-        ...options.elements
+    {
+      var _options$elements;
+      const err = 'Floating UI: Cannot pass a virtual element to the ' + '`elements.reference` option, as it must be a real DOM element. ' + 'Use `refs.setPositionReference` instead.';
+      if ((_options$elements = options.elements) != null && _options$elements.reference && !isElement(options.elements.reference)) {
+        var _devMessageSet;
+        if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(err))) {
+          var _devMessageSet2;
+          (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(err);
+          console.error(err);
+        }
       }
-    });
-    const rootContext = options.rootContext || internalRootContext;
-    const computedElements = rootContext.elements;
+    }
     const [_domReference, setDomReference] = React__namespace.useState(null);
-    const [positionReference, _setPositionReference] = React__namespace.useState(null);
-    const optionDomReference = computedElements == null ? void 0 : computedElements.reference;
-    const domReference = optionDomReference || _domReference;
-    const domReferenceRef = React__namespace.useRef(null);
+    const domReference = ((_options$elements2 = options.elements) == null ? void 0 : _options$elements2.reference) || _domReference;
+    const position = reactDom.useFloating(options);
     const tree = useFloatingTree();
-    index(() => {
-      if (domReference) {
-        domReferenceRef.current = domReference;
-      }
-    }, [domReference]);
-    const position = reactDom.useFloating({
-      ...options,
-      elements: {
-        ...computedElements,
-        ...(positionReference && {
-          reference: positionReference
-        })
+    const nested = useFloatingParentNodeId() != null;
+    const onOpenChange = useEffectEvent((open, event, reason) => {
+      if (open) {
+        dataRef.current.openEvent = event;
       }
+      events.emit('openchange', {
+        open,
+        event,
+        reason,
+        nested
+      });
+      unstable_onOpenChange == null || unstable_onOpenChange(open, event, reason);
     });
+    const domReferenceRef = React__namespace.useRef(null);
+    const dataRef = React__namespace.useRef({});
+    const events = React__namespace.useState(() => createPubSub())[0];
+    const floatingId = useId();
     const setPositionReference = React__namespace.useCallback(node => {
-      const computedPositionReference = isElement(node) ? {
+      const positionReference = isElement(node) ? {
         getBoundingClientRect: () => node.getBoundingClientRect(),
         contextElement: node
       } : node;
-      // Store the positionReference in state if the DOM reference is specified externally via the
-      // `elements.reference` option. This ensures that it won't be overridden on future renders.
-      _setPositionReference(computedPositionReference);
-      position.refs.setReference(computedPositionReference);
+      position.refs.setReference(positionReference);
     }, [position.refs]);
     const setReference = React__namespace.useCallback(node => {
       if (isElement(node) || node === null) {
@@ -3641,13 +3476,16 @@
     }), [position.elements, domReference]);
     const context = React__namespace.useMemo(() => ({
       ...position,
-      ...rootContext,
       refs,
       elements,
-      nodeId
-    }), [position, refs, elements, nodeId, rootContext]);
+      dataRef,
+      nodeId,
+      floatingId,
+      events,
+      open,
+      onOpenChange
+    }), [position, nodeId, floatingId, events, open, onOpenChange, refs, elements]);
     index(() => {
-      rootContext.dataRef.current.floatingContext = context;
       const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);
       if (node) {
         node.context = context;
@@ -3674,8 +3512,9 @@
       open,
       onOpenChange,
       events,
-      dataRef,
+      refs,
       elements: {
+        floating,
         domReference
       }
     } = context;
@@ -3774,7 +3613,6 @@
 
             // Wait for the window blur listener to fire.
             timeoutRef.current = window.setTimeout(() => {
-              var _dataRef$current$floa;
               const activeEl = activeElement(domReference ? domReference.ownerDocument : document);
 
               // Focus left the page, keep it open.
@@ -3783,11 +3621,7 @@
               // When focusing the reference element (e.g. regular click), then
               // clicking into the floating element, prevent it from hiding.
               // Note: it must be focusable, e.g. `tabindex="-1"`.
-              // We can not rely on relatedTarget to point to the correct element
-              // as it will only point to the shadow host of the newly focused element
-              // and not the element that actually has received focus if it is located
-              // inside a shadow root.
-              if (contains((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || contains(domReference, activeEl) || movedToFocusGuard) {
+              if (contains(refs.floating.current, relatedTarget) || contains(domReference, relatedTarget) || movedToFocusGuard) {
                 return;
               }
               onOpenChange(false, event.nativeEvent, 'focus');
@@ -3795,7 +3629,7 @@
           }
         }
       };
-    }, [enabled, visibleOnly, dataRef, domReference, onOpenChange]);
+    }, [enabled, visibleOnly, domReference, refs, onOpenChange]);
   }
 
   const ACTIVE_KEY = 'active';
@@ -3855,6 +3689,7 @@
       }, {})
     };
   }
+
   /**
    * Merges an array of interaction hooks' props into prop getters, allowing
    * event handler functions to be composed together without overwriting one
@@ -3868,18 +3703,19 @@
     // The dependencies are a dynamic array, so we can't use the linter's
     // suggestion to add it to the deps array.
     const deps = propsList;
-    const getReferenceProps = React__namespace.useCallback(userProps => mergeProps(userProps, propsList, 'reference'),
-    // eslint-disable-next-line react-hooks/exhaustive-deps
-    deps);
-    const getFloatingProps = React__namespace.useCallback(userProps => mergeProps(userProps, propsList, 'floating'),
-    // eslint-disable-next-line react-hooks/exhaustive-deps
-    deps);
+
+    // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
+    const getReferenceProps = React__namespace.useCallback(userProps => mergeProps(userProps, propsList, 'reference'), deps);
+
+    // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
+    const getFloatingProps = React__namespace.useCallback(userProps => mergeProps(userProps, propsList, 'floating'), deps);
+
+    // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
     const getItemProps = React__namespace.useCallback(userProps => mergeProps(userProps, propsList, 'item'),
     // Granularly check for `item` changes, because the `getItemProps` getter
     // should be as referentially stable as possible since it may be passed as
     // a prop to many components. All `item` key values must therefore be
     // memoized.
-    // eslint-disable-next-line react-hooks/exhaustive-deps
     propsList.map(key => key == null ? void 0 : key.item));
     return React__namespace.useMemo(() => ({
       getReferenceProps,
@@ -3928,6 +3764,7 @@
     const {
       open,
       onOpenChange,
+      refs,
       elements: {
         domReference,
         floating
@@ -3958,14 +3795,14 @@
     {
       if (allowEscape) {
         if (!loop) {
-          warn('`useListNavigation` looping must be enabled to allow escaping.');
+          console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));
         }
         if (!virtual) {
-          warn('`useListNavigation` must be virtual to allow escaping.');
+          console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));
         }
       }
       if (orientation === 'vertical' && cols > 1) {
-        warn('In grid list navigation mode (`cols` > 1), the `orientation` should', 'be either "horizontal" or "both".');
+        console.warn(['Floating UI: In grid list navigation mode (`cols` > 1), the', '`orientation` should be either "horizontal" or "both".'].join(' '));
       }
     }
     const parentId = useFloatingParentNodeId();
@@ -3982,52 +3819,41 @@
     const disabledIndicesRef = useLatestRef(disabledIndices);
     const latestOpenRef = useLatestRef(open);
     const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);
-    const floatingRef = useLatestRef(floating);
-    const selectedIndexRef = useLatestRef(selectedIndex);
     const [activeId, setActiveId] = React__namespace.useState();
     const [virtualId, setVirtualId] = React__namespace.useState();
     const focusItem = useEffectEvent(function (listRef, indexRef, forceScrollIntoView) {
       if (forceScrollIntoView === void 0) {
         forceScrollIntoView = false;
       }
-      function runFocus(item) {
-        if (virtual) {
-          setActiveId(item.id);
-          tree == null || tree.events.emit('virtualfocus', item);
-          if (virtualItemRef) {
-            virtualItemRef.current = item;
-          }
-        } else {
-          enqueueFocus(item, {
-            preventScroll: true,
-            // Mac Safari does not move the virtual cursor unless the focus call
-            // is sync. However, for the very first focus call, we need to wait
-            // for the position to be ready in order to prevent unwanted
-            // scrolling. This means the virtual cursor will not move to the first
-            // item when first opening the floating element, but will on
-            // subsequent calls. `preventScroll` is supported in modern Safari,
-            // so we can use that instead.
-            // iOS Safari must be async or the first item will not be focused.
-            sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false
-          });
+      const item = listRef.current[indexRef.current];
+      if (!item) return;
+      if (virtual) {
+        setActiveId(item.id);
+        tree == null || tree.events.emit('virtualfocus', item);
+        if (virtualItemRef) {
+          virtualItemRef.current = item;
         }
-      }
-      const initialItem = listRef.current[indexRef.current];
-      if (initialItem) {
-        runFocus(initialItem);
+      } else {
+        enqueueFocus(item, {
+          preventScroll: true,
+          // Mac Safari does not move the virtual cursor unless the focus call
+          // is sync. However, for the very first focus call, we need to wait
+          // for the position to be ready in order to prevent unwanted
+          // scrolling. This means the virtual cursor will not move to the first
+          // item when first opening the floating element, but will on
+          // subsequent calls. `preventScroll` is supported in modern Safari,
+          // so we can use that instead.
+          // iOS Safari must be async or the first item will not be focused.
+          sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false
+        });
       }
       requestAnimationFrame(() => {
-        const waitedItem = listRef.current[indexRef.current] || initialItem;
-        if (!waitedItem) return;
-        if (!initialItem) {
-          runFocus(waitedItem);
-        }
         const scrollIntoViewOptions = scrollItemIntoViewRef.current;
         const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);
         if (shouldScrollIntoView) {
           // JSDOM doesn't support `.scrollIntoView()` but it's widely supported
           // by all browsers.
-          waitedItem.scrollIntoView == null || waitedItem.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {
+          item.scrollIntoView == null || item.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {
             block: 'nearest',
             inline: 'nearest'
           } : scrollIntoViewOptions);
@@ -4075,7 +3901,7 @@
       if (open && floating) {
         if (activeIndex == null) {
           forceSyncFocus.current = false;
-          if (selectedIndexRef.current != null) {
+          if (selectedIndex != null) {
             return;
           }
 
@@ -4112,7 +3938,7 @@
           forceScrollIntoViewRef.current = false;
         }
       }
-    }, [enabled, open, floating, activeIndex, selectedIndexRef, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);
+    }, [enabled, open, floating, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);
 
     // Ensure the parent floating element has focus when a nested child closes
     // to allow arrow key navigation to work after the pointer leaves the child.
@@ -4196,7 +4022,7 @@
             focusItem(listRef, indexRef);
             onNavigate(null);
             if (!virtual) {
-              enqueueFocus(floatingRef.current, {
+              enqueueFocus(refs.floating.current, {
                 preventScroll: true
               });
             }
@@ -4204,7 +4030,7 @@
         })
       };
       return props;
-    }, [open, floatingRef, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);
+    }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);
     return React__namespace.useMemo(() => {
       if (!enabled) {
         return {};
@@ -4217,7 +4043,7 @@
         // If the floating element is animating out, ignore navigation. Otherwise,
         // the `activeIndex` gets set to 0 despite not being open so the next time
         // the user ArrowDowns, the first item won't be focused.
-        if (!latestOpenRef.current && event.currentTarget === floatingRef.current) {
+        if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {
           return;
         }
         if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {
@@ -4253,9 +4079,9 @@
           // To calculate movements on the grid, we use hypothetical cell indices
           // as if every item was 1x1, then convert back to real indices.
           const cellMap = buildCellMap(sizes, cols, dense);
-          const minGridIndex = cellMap.findIndex(index => index != null && !isDisabled(listRef.current, index, disabledIndices));
+          const minGridIndex = cellMap.findIndex(index => index != null && !(disabledIndices != null && disabledIndices.includes(index)));
           // last enabled index
-          const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !isDisabled(listRef.current, index, disabledIndices) ? cellIndex : foundIndex, -1);
+          const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);
           indexRef.current = cellMap[getGridNavigatedIndex({
             current: cellMap.map(itemIndex => itemIndex != null ? listRef.current[itemIndex] : null)
           }, {
@@ -4265,10 +4091,10 @@
             cols,
             // treat undefined (empty grid spaces) as disabled indices so we
             // don't end up in them
-            disabledIndices: getCellIndices([...(disabledIndices || listRef.current.map((_, index) => isDisabled(listRef.current, index) ? index : undefined)), undefined], cellMap),
+            disabledIndices: getCellIndices([...(disabledIndices || []), undefined], cellMap),
             minIndex: minGridIndex,
             maxIndex: maxGridIndex,
-            prevIndex: getCellIndexOfCorner(indexRef.current > maxIndex ? minIndex : indexRef.current, sizes, cellMap, cols,
+            prevIndex: getCellIndexOfCorner(indexRef.current, sizes, cellMap, cols,
             // use a corner matching the edge closest to the direction
             // we're moving in so we don't end up in the same item. Prefer
             // top/left over bottom/right.
@@ -4416,7 +4242,7 @@
             }
           },
           onFocus() {
-            if (open && !virtual) {
+            if (open) {
               onNavigate(null);
             }
           },
@@ -4434,7 +4260,7 @@
         },
         item
       };
-    }, [domReference, floatingRef, activeId, virtualId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item, tree, virtualItemRef, itemSizes, dense]);
+    }, [domReference, refs, activeId, virtualId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item, tree, virtualItemRef, itemSizes, dense]);
   }
 
   const componentRoleToAriaRoleMap = /*#__PURE__*/new Map([['select', 'listbox'], ['combobox', 'listbox'], ['label', false]]);
@@ -4553,11 +4379,11 @@
       setIsMounted(true);
     }
     React__namespace.useEffect(() => {
-      if (!open && isMounted) {
+      if (!open) {
         const timeout = setTimeout(() => setIsMounted(false), durationMs);
         return () => clearTimeout(timeout);
       }
-    }, [open, isMounted, durationMs]);
+    }, [open, durationMs]);
     return isMounted;
   }
   /**
@@ -4580,11 +4406,19 @@
     } = props;
     const isNumberDuration = typeof duration === 'number';
     const closeDuration = (isNumberDuration ? duration : duration.close) || 0;
+    const [initiated, setInitiated] = React__namespace.useState(false);
     const [status, setStatus] = React__namespace.useState('unmounted');
     const isMounted = useDelayUnmount(open, closeDuration);
-    if (!isMounted && status === 'close') {
-      setStatus('unmounted');
-    }
+
+    // `initiated` check prevents this `setState` call from breaking
+    // <FloatingPortal />. This call is necessary to ensure subsequent opens
+    // after the initial one allows the correct side animation to play when the
+    // placement has changed.
+    index(() => {
+      if (initiated && !isMounted) {
+        setStatus('unmounted');
+      }
+    }, [initiated, isMounted]);
     index(() => {
       if (!floating) return;
       if (open) {
@@ -4596,6 +4430,7 @@
           cancelAnimationFrame(frame);
         };
       }
+      setInitiated(true);
       setStatus('close');
     }, [open, floating]);
     return {
@@ -4856,7 +4691,7 @@
       const item = listRef.current[index];
       {
         if (!state.placement.startsWith('bottom')) {
-          warn('`placement` side must be "bottom" when using the `inner`', 'middleware.');
+          console.warn(['Floating UI: `placement` side must be "bottom" when using the', '`inner` middleware.'].join(' '));
         }
       }
       if (!item) {
@@ -5022,7 +4857,7 @@
   /**
    * Generates a safe polygon area that the user can traverse without closing the
    * floating element once leaving the reference element.
-   * @see https://floating-ui.com/docs/useHover#safepolygon
+   * @see https://floating-ui.com/docs/useHover#safePolygon
    */
   function safePolygon(options) {
     if (options === void 0) {
@@ -5291,7 +5126,6 @@
   exports.useFloatingNodeId = useFloatingNodeId;
   exports.useFloatingParentNodeId = useFloatingParentNodeId;
   exports.useFloatingPortalNode = useFloatingPortalNode;
-  exports.useFloatingRootContext = useFloatingRootContext;
   exports.useFloatingTree = useFloatingTree;
   exports.useFocus = useFocus;
   exports.useHover = useHover;
diff --git a/node_modules/@floating-ui/react/dist/floating-ui.react.umd.min.js b/node_modules/@floating-ui/react/dist/floating-ui.react.umd.min.js
index a5f69b7..00896b9 100644
--- a/node_modules/@floating-ui/react/dist/floating-ui.react.umd.min.js
+++ b/node_modules/@floating-ui/react/dist/floating-ui.react.umd.min.js
@@ -1,6 +1,6 @@
-!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("react"),require("@floating-ui/react-dom"),require("react-dom")):"function"==typeof define&&define.amd?define(["exports","react","@floating-ui/react-dom","react-dom"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).FloatingUIReact={},e.React,e.FloatingUIReactDOM,e.ReactDOM)}(this,(function(e,t,n,r){"use strict";function o(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var u=o(t);function i(e){return u.useMemo((()=>e.every((e=>null==e))?null:t=>{e.forEach((e=>{"function"==typeof e?e(t):null!=e&&(e.current=t)}))}),e)}const c={...u},l=c.useInsertionEffect||(e=>e());function s(e){const t=u.useRef((()=>{}));return l((()=>{t.current=e})),u.useCallback((function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return null==t.current?void 0:t.current(...n)}),[])}function a(e){return d(e)?(e.nodeName||"").toLowerCase():"#document"}function f(e){var t;return(null==e||null==(t=e.ownerDocument)?void 0:t.defaultView)||window}function d(e){return e instanceof Node||e instanceof f(e).Node}function v(e){return e instanceof Element||e instanceof f(e).Element}function m(e){return e instanceof HTMLElement||e instanceof f(e).HTMLElement}function p(e){return"undefined"!=typeof ShadowRoot&&(e instanceof ShadowRoot||e instanceof f(e).ShadowRoot)}function g(e){return["html","body","#document"].includes(a(e))}function h(e){if("html"===a(e))return e;const t=e.assignedSlot||e.parentNode||p(e)&&e.host||function(e){var t;return null==(t=(d(e)?e.ownerDocument:e.document)||window.document)?void 0:t.documentElement}(e);return p(t)?t.host:t}function y(e){let t=e.activeElement;for(;null!=(null==(n=t)||null==(n=n.shadowRoot)?void 0:n.activeElement);){var n;t=t.shadowRoot.activeElement}return t}function b(e,t){if(!e||!t)return!1;const n=null==t.getRootNode?void 0:t.getRootNode();if(e.contains(t))return!0;if(n&&p(n)){let n=t;for(;n;){if(e===n)return!0;n=n.parentNode||n.host}}return!1}function w(){const e=navigator.userAgentData;return null!=e&&e.platform?e.platform:navigator.platform}function E(){const e=navigator.userAgentData;return e&&Array.isArray(e.brands)?e.brands.map((e=>{let{brand:t,version:n}=e;return t+"/"+n})).join(" "):navigator.userAgent}function x(e){return!(0!==e.mozInputSource||!e.isTrusted)||(k()&&e.pointerType?"click"===e.type&&1===e.buttons:0===e.detail&&!e.pointerType)}function R(e){return!E().includes("jsdom/")&&(!k()&&0===e.width&&0===e.height||k()&&1===e.width&&1===e.height&&0===e.pressure&&0===e.detail&&"mouse"===e.pointerType||e.width<1&&e.height<1&&0===e.pressure&&0===e.detail&&"touch"===e.pointerType)}function I(){return/apple/i.test(navigator.vendor)}function k(){const e=/android/i;return e.test(w())||e.test(E())}function O(){return w().toLowerCase().startsWith("mac")&&!navigator.maxTouchPoints}function C(e,t){const n=["mouse","pen"];return t||n.push("",void 0),n.includes(e)}function M(e){return(null==e?void 0:e.ownerDocument)||document}function T(e,t){if(null==t)return!1;if("composedPath"in e)return e.composedPath().includes(t);const n=e;return null!=n.target&&t.contains(n.target)}function P(e){return"composedPath"in e?e.composedPath()[0]:e.target}const S="input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";function L(e){return m(e)&&e.matches(S)}function A(e){e.preventDefault(),e.stopPropagation()}function N(e){return!!e&&("combobox"===e.getAttribute("role")&&L(e))}const D=Math.floor,F="ArrowUp",j="ArrowDown",K="ArrowLeft",H="ArrowRight";function q(e,t,n){return Math.floor(e/t)!==n}function _(e,t){return t<0||t>=e.current.length}function B(e,t){return U(e,{disabledIndices:t})}function W(e,t){return U(e,{decrement:!0,startingIndex:e.current.length,disabledIndices:t})}function U(e,t){let{startingIndex:n=-1,decrement:r=!1,disabledIndices:o,amount:u=1}=void 0===t?{}:t;const i=e.current;let c=n;do{c+=r?-u:u}while(c>=0&&c<=i.length-1&&G(i,c,o));return c}function z(e,t){let{event:n,orientation:r,loop:o,cols:u,disabledIndices:i,minIndex:c,maxIndex:l,prevIndex:s,stopEvent:a=!1}=t,f=s;if(n.key===F){if(a&&A(n),-1===s)f=l;else if(f=U(e,{startingIndex:f,amount:u,decrement:!0,disabledIndices:i}),o&&(s-u<c||f<0)){const e=s%u,t=l%u,n=l-(t-e);f=t===e?l:t>e?n:n-u}_(e,f)&&(f=s)}if(n.key===j&&(a&&A(n),-1===s?f=c:(f=U(e,{startingIndex:s,amount:u,disabledIndices:i}),o&&s+u>l&&(f=U(e,{startingIndex:s%u-u,amount:u,disabledIndices:i}))),_(e,f)&&(f=s)),"both"===r){const t=D(s/u);n.key===H&&(a&&A(n),s%u!=u-1?(f=U(e,{startingIndex:s,disabledIndices:i}),o&&q(f,u,t)&&(f=U(e,{startingIndex:s-s%u-1,disabledIndices:i}))):o&&(f=U(e,{startingIndex:s-s%u-1,disabledIndices:i})),q(f,u,t)&&(f=s)),n.key===K&&(a&&A(n),s%u!=0?(f=U(e,{startingIndex:s,decrement:!0,disabledIndices:i}),o&&q(f,u,t)&&(f=U(e,{startingIndex:s+(u-s%u),decrement:!0,disabledIndices:i}))):o&&(f=U(e,{startingIndex:s+(u-s%u),decrement:!0,disabledIndices:i})),q(f,u,t)&&(f=s));const r=D(l/u)===t;_(e,f)&&(f=o&&r?n.key===K?l:U(e,{startingIndex:s-s%u-1,disabledIndices:i}):s)}return f}function X(e,t,n){const r=[];let o=0;return e.forEach(((e,u)=>{let{width:i,height:c}=e,l=!1;for(n&&(o=0);!l;){const e=[];for(let n=0;n<i;n++)for(let r=0;r<c;r++)e.push(o+n+r*t);o%t+i<=t&&e.every((e=>null==r[e]))?(e.forEach((e=>{r[e]=u})),l=!0):o++}})),[...r]}function Y(e,t,n,r,o){if(-1===e)return-1;const u=n.indexOf(e),i=t[e];switch(o){case"tl":return u;case"tr":return i?u+i.width-1:u;case"bl":return i?u+(i.height-1)*r:u;case"br":return n.lastIndexOf(e)}}function V(e,t){return t.flatMap(((t,n)=>e.includes(t)?[n]:[]))}function G(e,t,n){if(n)return n.includes(t);const r=e[t];return null==r||r.hasAttribute("disabled")||"true"===r.getAttribute("aria-disabled")}let Z=0;function $(e,t){void 0===t&&(t={});const{preventScroll:n=!1,cancelPrevious:r=!0,sync:o=!1}=t;r&&cancelAnimationFrame(Z);const u=()=>null==e?void 0:e.focus({preventScroll:n});o?u():Z=requestAnimationFrame(u)}var Q="undefined"!=typeof document?t.useLayoutEffect:t.useEffect;function J(e,t){const n=e.compareDocumentPosition(t);return n&Node.DOCUMENT_POSITION_FOLLOWING||n&Node.DOCUMENT_POSITION_CONTAINED_BY?-1:n&Node.DOCUMENT_POSITION_PRECEDING||n&Node.DOCUMENT_POSITION_CONTAINS?1:0}const ee=u.createContext({register:()=>{},unregister:()=>{},map:new Map,elementsRef:{current:[]}});function te(e){const{children:t,elementsRef:n,labelsRef:r}=e,[o,i]=u.useState((()=>new Map)),c=u.useCallback((e=>{i((t=>new Map(t).set(e,null)))}),[]),l=u.useCallback((e=>{i((t=>{const n=new Map(t);return n.delete(e),n}))}),[]);return Q((()=>{const e=new Map(o);Array.from(e.keys()).sort(J).forEach(((t,n)=>{e.set(t,n)})),function(e,t){if(e.size!==t.size)return!1;for(const[n,r]of e.entries())if(r!==t.get(n))return!1;return!0}(o,e)||i(e)}),[o]),u.createElement(ee.Provider,{value:u.useMemo((()=>({register:c,unregister:l,map:o,elementsRef:n,labelsRef:r})),[c,l,o,n,r])},t)}function ne(e){void 0===e&&(e={});const{label:t}=e,{register:n,unregister:r,map:o,elementsRef:i,labelsRef:c}=u.useContext(ee),[l,s]=u.useState(null),a=u.useRef(null),f=u.useCallback((e=>{if(a.current=e,null!==l&&(i.current[l]=e,c)){var n;const r=void 0!==t;c.current[l]=r?t:null!=(n=null==e?void 0:e.textContent)?n:null}}),[l,i,c,t]);return Q((()=>{const e=a.current;if(e)return n(e),()=>{r(e)}}),[n,r]),Q((()=>{const e=a.current?o.get(a.current):null;null!=e&&s(e)}),[o]),u.useMemo((()=>({ref:f,index:null==l?-1:l})),[l,f])}function re(e,t){return"function"==typeof e?e(t):e?u.cloneElement(e,t):u.createElement("div",t)}const oe=u.createContext({activeIndex:0,onNavigate:()=>{}}),ue=[K,H],ie=[F,j],ce=[...ue,...ie],le=u.forwardRef((function(e,t){const{render:n,orientation:r="both",loop:o=!0,cols:i=1,disabledIndices:c,activeIndex:l,onNavigate:a,itemSizes:f,dense:d=!1,...v}=e,[m,p]=u.useState(0),g=null!=l?l:m,h=s(null!=a?a:p),y=u.useRef([]),b=n&&"function"!=typeof n?n.props:{},w=u.useMemo((()=>({activeIndex:g,onNavigate:h})),[g,h]),E=i>1;const x={...v,...b,ref:t,"aria-orientation":"both"===r?void 0:r,onKeyDown(e){null==v.onKeyDown||v.onKeyDown(e),null==b.onKeyDown||b.onKeyDown(e),function(e){if(!ce.includes(e.key))return;let t=g;const n=B(y,c),u=W(y,c);if(E){const l=f||Array.from({length:y.current.length},(()=>({width:1,height:1}))),s=X(l,i,d),a=s.findIndex((e=>null!=e&&!G(y.current,e,c))),v=s.reduce(((e,t,n)=>null==t||G(y.current,t,c)?e:n),-1);t=s[z({current:s.map((e=>e?y.current[e]:null))},{event:e,orientation:r,loop:o,cols:i,disabledIndices:V([...c||y.current.map(((e,t)=>G(y.current,t)?t:void 0)),void 0],s),minIndex:a,maxIndex:v,prevIndex:Y(g>u?n:g,l,s,i,e.key===j?"bl":e.key===H?"tr":"tl")})]}const l={horizontal:[H],vertical:[j],both:[H,j]}[r],s={horizontal:[K],vertical:[F],both:[K,F]}[r],a=E?ce:{horizontal:ue,vertical:ie,both:ce}[r];t===g&&[...l,...s].includes(e.key)&&(t=o&&t===u&&l.includes(e.key)?n:o&&t===n&&s.includes(e.key)?u:U(y,{startingIndex:t,decrement:s.includes(e.key),disabledIndices:c})),t===g||_(y,t)||(e.stopPropagation(),a.includes(e.key)&&e.preventDefault(),h(t),queueMicrotask((()=>{$(y.current[t])})))}(e)}};return u.createElement(oe.Provider,{value:w},u.createElement(te,{elementsRef:y},re(n,x)))})),se=u.forwardRef((function(e,t){const{render:n,...r}=e,o=n&&"function"!=typeof n?n.props:{},{activeIndex:c,onNavigate:l}=u.useContext(oe),{ref:s,index:a}=ne(),f=i([s,t,o.ref]),d=c===a;return re(n,{...r,...o,ref:f,tabIndex:d?0:-1,"data-active":d?"":void 0,onFocus(e){null==r.onFocus||r.onFocus(e),null==o.onFocus||o.onFocus(e),l(a)}})}));function ae(){return ae=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},ae.apply(this,arguments)}let fe=!1,de=0;const ve=()=>"floating-ui-"+Math.random().toString(36).slice(2,6)+de++;const me=c.useId||function(){const[e,t]=u.useState((()=>fe?ve():void 0));return Q((()=>{null==e&&t(ve())}),[]),u.useEffect((()=>{fe=!0}),[]),e},pe=u.forwardRef((function(e,t){const{context:{placement:r,elements:{floating:o},middlewareData:{arrow:i}},width:c=14,height:l=7,tipRadius:s=0,strokeWidth:a=0,staticOffset:f,stroke:d,d:v,style:{transform:m,...p}={},...g}=e,h=me();if(!o)return null;const y=2*a,b=y/2,w=c/2*(s/-8+1),E=l/2*s/4,[x,R]=r.split("-"),I=n.platform.isRTL(o),k=!!v,O="top"===x||"bottom"===x,C=f&&"end"===R?"bottom":"top";let M=f&&"end"===R?"right":"left";f&&I&&(M="end"===R?"left":"right");const T=null!=(null==i?void 0:i.x)?f||i.x:"",P=null!=(null==i?void 0:i.y)?f||i.y:"",S=v||"M0,0 H"+c+" L"+(c-w)+","+(l-E)+" Q"+c/2+","+l+" "+w+","+(l-E)+" Z",L={top:k?"rotate(180deg)":"",left:k?"rotate(90deg)":"rotate(-90deg)",bottom:k?"":"rotate(180deg)",right:k?"rotate(-90deg)":"rotate(90deg)"}[x];return u.createElement("svg",ae({},g,{"aria-hidden":!0,ref:t,width:k?c:c+y,height:c,viewBox:"0 0 "+c+" "+(l>c?l:c),style:{position:"absolute",pointerEvents:"none",[M]:T,[C]:P,[x]:O||k?"100%":"calc(100% - "+y/2+"px)",transform:""+L+(null!=m?m:""),...p}}),y>0&&u.createElement("path",{clipPath:"url(#"+h+")",fill:"none",stroke:d,strokeWidth:y+(v?0:1),d:S}),u.createElement("path",{stroke:y&&!v?g.fill:"none",d:S}),u.createElement("clipPath",{id:h},u.createElement("rect",{x:-b,y:b*(k?-1:1),width:c+y,height:c})))}));function ge(){const e=new Map;return{emit(t,n){var r;null==(r=e.get(t))||r.forEach((e=>e(n)))},on(t,n){e.set(t,[...e.get(t)||[],n])},off(t,n){var r;e.set(t,(null==(r=e.get(t))?void 0:r.filter((e=>e!==n)))||[])}}}const he=u.createContext(null),ye=u.createContext(null),be=()=>{var e;return(null==(e=u.useContext(he))?void 0:e.id)||null},we=()=>u.useContext(ye);function Ee(e){return"data-floating-ui-"+e}function xe(e){const n=t.useRef(e);return Q((()=>{n.current=e})),n}const Re=Ee("safe-polygon");function Ie(e,t,n){return n&&!C(n)?0:"number"==typeof e?e:null==e?void 0:e[t]}const ke=()=>{},Oe=u.createContext({delay:0,initialDelay:0,timeoutMs:0,currentId:null,setCurrentId:ke,setState:ke,isInstantPhase:!1}),Ce=()=>u.useContext(Oe);
+!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("react"),require("@floating-ui/react-dom"),require("react-dom")):"function"==typeof define&&define.amd?define(["exports","react","@floating-ui/react-dom","react-dom"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).FloatingUIReact={},e.React,e.FloatingUIReactDOM,e.ReactDOM)}(this,(function(e,t,n,r){"use strict";function o(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var u=o(t);function i(e){return u.useMemo((()=>e.every((e=>null==e))?null:t=>{e.forEach((e=>{"function"==typeof e?e(t):null!=e&&(e.current=t)}))}),e)}const l=u["useInsertionEffect".toString()]||(e=>e());function c(e){const t=u.useRef((()=>{}));return l((()=>{t.current=e})),u.useCallback((function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return null==t.current?void 0:t.current(...n)}),[])}function s(e){return f(e)?(e.nodeName||"").toLowerCase():"#document"}function a(e){var t;return(null==e||null==(t=e.ownerDocument)?void 0:t.defaultView)||window}function f(e){return e instanceof Node||e instanceof a(e).Node}function d(e){return e instanceof Element||e instanceof a(e).Element}function v(e){return e instanceof HTMLElement||e instanceof a(e).HTMLElement}function m(e){return"undefined"!=typeof ShadowRoot&&(e instanceof ShadowRoot||e instanceof a(e).ShadowRoot)}function p(e){return["html","body","#document"].includes(s(e))}function g(e){if("html"===s(e))return e;const t=e.assignedSlot||e.parentNode||m(e)&&e.host||function(e){var t;return null==(t=(f(e)?e.ownerDocument:e.document)||window.document)?void 0:t.documentElement}(e);return m(t)?t.host:t}function h(e){let t=e.activeElement;for(;null!=(null==(n=t)||null==(n=n.shadowRoot)?void 0:n.activeElement);){var n;t=t.shadowRoot.activeElement}return t}function y(e,t){if(!e||!t)return!1;const n=null==t.getRootNode?void 0:t.getRootNode();if(e.contains(t))return!0;if(n&&m(n)){let n=t;for(;n;){if(e===n)return!0;n=n.parentNode||n.host}}return!1}function b(){const e=navigator.userAgentData;return null!=e&&e.platform?e.platform:navigator.platform}function E(){const e=navigator.userAgentData;return e&&Array.isArray(e.brands)?e.brands.map((e=>{let{brand:t,version:n}=e;return t+"/"+n})).join(" "):navigator.userAgent}function w(e){return!(0!==e.mozInputSource||!e.isTrusted)||(I()&&e.pointerType?"click"===e.type&&1===e.buttons:0===e.detail&&!e.pointerType)}function x(e){return!E().includes("jsdom/")&&(!I()&&0===e.width&&0===e.height||I()&&1===e.width&&1===e.height&&0===e.pressure&&0===e.detail&&"mouse"===e.pointerType||e.width<1&&e.height<1&&0===e.pressure&&0===e.detail&&"touch"===e.pointerType)}function R(){return/apple/i.test(navigator.vendor)}function I(){const e=/android/i;return e.test(b())||e.test(E())}function k(){return b().toLowerCase().startsWith("mac")&&!navigator.maxTouchPoints}function O(e,t){const n=["mouse","pen"];return t||n.push("",void 0),n.includes(e)}function C(e){return(null==e?void 0:e.ownerDocument)||document}function M(e,t){if(null==t)return!1;if("composedPath"in e)return e.composedPath().includes(t);const n=e;return null!=n.target&&t.contains(n.target)}function T(e){return"composedPath"in e?e.composedPath()[0]:e.target}const S="input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";function P(e){return v(e)&&e.matches(S)}function L(e){e.preventDefault(),e.stopPropagation()}function A(e){return!!e&&("combobox"===e.getAttribute("role")&&P(e))}const D=Math.floor,N="ArrowUp",F="ArrowDown",j="ArrowLeft",K="ArrowRight";function H(e,t,n){return Math.floor(e/t)!==n}function q(e,t){return t<0||t>=e.current.length}function _(e,t){return W(e,{disabledIndices:t})}function B(e,t){return W(e,{decrement:!0,startingIndex:e.current.length,disabledIndices:t})}function W(e,t){let{startingIndex:n=-1,decrement:r=!1,disabledIndices:o,amount:u=1}=void 0===t?{}:t;const i=e.current,l=o?e=>o.includes(e):e=>{const t=i[e];return null==t||t.hasAttribute("disabled")||"true"===t.getAttribute("aria-disabled")};let c=n;do{c+=r?-u:u}while(c>=0&&c<=i.length-1&&l(c));return c}function U(e,t){let{event:n,orientation:r,loop:o,cols:u,disabledIndices:i,minIndex:l,maxIndex:c,prevIndex:s,stopEvent:a=!1}=t,f=s;if(n.key===N){if(a&&L(n),-1===s)f=c;else if(f=W(e,{startingIndex:f,amount:u,decrement:!0,disabledIndices:i}),o&&(s-u<l||f<0)){const e=s%u,t=c%u,n=c-(t-e);f=t===e?c:t>e?n:n-u}q(e,f)&&(f=s)}if(n.key===F&&(a&&L(n),-1===s?f=l:(f=W(e,{startingIndex:s,amount:u,disabledIndices:i}),o&&s+u>c&&(f=W(e,{startingIndex:s%u-u,amount:u,disabledIndices:i}))),q(e,f)&&(f=s)),"both"===r){const t=D(s/u);n.key===K&&(a&&L(n),s%u!=u-1?(f=W(e,{startingIndex:s,disabledIndices:i}),o&&H(f,u,t)&&(f=W(e,{startingIndex:s-s%u-1,disabledIndices:i}))):o&&(f=W(e,{startingIndex:s-s%u-1,disabledIndices:i})),H(f,u,t)&&(f=s)),n.key===j&&(a&&L(n),s%u!=0?(f=W(e,{startingIndex:s,disabledIndices:i,decrement:!0}),o&&H(f,u,t)&&(f=W(e,{startingIndex:s+(u-s%u),decrement:!0,disabledIndices:i}))):o&&(f=W(e,{startingIndex:s+(u-s%u),decrement:!0,disabledIndices:i})),H(f,u,t)&&(f=s));const r=D(c/u)===t;q(e,f)&&(f=o&&r?n.key===j?c:W(e,{startingIndex:s-s%u-1,disabledIndices:i}):s)}return f}function z(e,t,n){const r=[];let o=0;return e.forEach(((e,u)=>{let{width:i,height:l}=e,c=!1;for(n&&(o=0);!c;){const e=[];for(let n=0;n<i;n++)for(let r=0;r<l;r++)e.push(o+n+r*t);o%t+i<=t&&e.every((e=>null==r[e]))?(e.forEach((e=>{r[e]=u})),c=!0):o++}})),[...r]}function X(e,t,n,r,o){if(-1===e)return-1;const u=n.indexOf(e);switch(o){case"tl":return u;case"tr":return u+t[e].width-1;case"bl":return u+(t[e].height-1)*r;case"br":return n.lastIndexOf(e)}}function Y(e,t){return t.flatMap(((t,n)=>e.includes(t)?[n]:[]))}let V=0;function G(e,t){void 0===t&&(t={});const{preventScroll:n=!1,cancelPrevious:r=!0,sync:o=!1}=t;r&&cancelAnimationFrame(V);const u=()=>null==e?void 0:e.focus({preventScroll:n});o?u():V=requestAnimationFrame(u)}var Z="undefined"!=typeof document?t.useLayoutEffect:t.useEffect;function $(e,t){const n=e.compareDocumentPosition(t);return n&Node.DOCUMENT_POSITION_FOLLOWING||n&Node.DOCUMENT_POSITION_CONTAINED_BY?-1:n&Node.DOCUMENT_POSITION_PRECEDING||n&Node.DOCUMENT_POSITION_CONTAINS?1:0}const Q=u.createContext({register:()=>{},unregister:()=>{},map:new Map,elementsRef:{current:[]}});function J(e){let{children:t,elementsRef:n,labelsRef:r}=e;const[o,i]=u.useState((()=>new Map)),l=u.useCallback((e=>{i((t=>new Map(t).set(e,null)))}),[]),c=u.useCallback((e=>{i((t=>{const n=new Map(t);return n.delete(e),n}))}),[]);return Z((()=>{const e=new Map(o);Array.from(e.keys()).sort($).forEach(((t,n)=>{e.set(t,n)})),function(e,t){if(e.size!==t.size)return!1;for(const[n,r]of e.entries())if(r!==t.get(n))return!1;return!0}(o,e)||i(e)}),[o]),u.createElement(Q.Provider,{value:u.useMemo((()=>({register:l,unregister:c,map:o,elementsRef:n,labelsRef:r})),[l,c,o,n,r])},t)}function ee(e){let{label:t}=void 0===e?{}:e;const[n,r]=u.useState(null),o=u.useRef(null),{register:i,unregister:l,map:c,elementsRef:s,labelsRef:a}=u.useContext(Q),f=u.useCallback((e=>{if(o.current=e,null!==n&&(s.current[n]=e,a)){var r;const o=void 0!==t;a.current[n]=o?t:null!=(r=null==e?void 0:e.textContent)?r:null}}),[n,s,a,t]);return Z((()=>{const e=o.current;if(e)return i(e),()=>{l(e)}}),[i,l]),Z((()=>{const e=o.current?c.get(o.current):null;null!=e&&r(e)}),[c]),u.useMemo((()=>({ref:f,index:null==n?-1:n})),[n,f])}function te(e,t){return"function"==typeof e?e(t):e?u.cloneElement(e,t):u.createElement("div",t)}const ne=u.createContext({activeIndex:0,onNavigate:()=>{}}),re=[j,K],oe=[N,F],ue=[...re,...oe],ie=u.forwardRef((function(e,t){let{render:n,orientation:r="both",loop:o=!0,cols:i=1,disabledIndices:l=[],activeIndex:s,onNavigate:a,itemSizes:f,dense:d=!1,...v}=e;const[m,p]=u.useState(0),g=null!=s?s:m,h=c(null!=a?a:p),y=u.useRef([]),b=n&&"function"!=typeof n?n.props:{},E=u.useMemo((()=>({activeIndex:g,onNavigate:h})),[g,h]),w=i>1;const x={...v,...b,ref:t,"aria-orientation":"both"===r?void 0:r,onKeyDown(e){null==v.onKeyDown||v.onKeyDown(e),null==b.onKeyDown||b.onKeyDown(e),function(e){if(!ue.includes(e.key))return;let t=g;if(w){const n=null!=f?f:Array.from(Array(y.current.length),(()=>({width:1,height:1}))),u=z(n,i,d),c=u.findIndex((e=>null!=e&&!l.includes(e))),s=u.reduce(((e,t,n)=>null==t||null!=l&&l.includes(t)?e:n),-1);t=u[U({current:u.map((e=>e?y.current[e]:null))},{event:e,orientation:r,loop:o,cols:i,disabledIndices:Y([...l,void 0],u),minIndex:c,maxIndex:s,prevIndex:X(g,n,u,i,e.key===F?"bl":e.key===K?"tr":"tl")})]}const n=_(y,l),u=B(y,l),c={horizontal:[K],vertical:[F],both:[K,F]}[r],s={horizontal:[j],vertical:[N],both:[j,N]}[r],a=w?ue:{horizontal:re,vertical:oe,both:ue}[r];t===g&&[...c,...s].includes(e.key)&&(t=o&&t===u&&c.includes(e.key)?n:o&&t===n&&s.includes(e.key)?u:W(y,{startingIndex:t,decrement:s.includes(e.key),disabledIndices:l})),t===g||q(y,t)||(e.stopPropagation(),a.includes(e.key)&&e.preventDefault(),h(t),queueMicrotask((()=>{G(y.current[t])})))}(e)}};return u.createElement(ne.Provider,{value:E},u.createElement(J,{elementsRef:y},te(n,x)))})),le=u.forwardRef((function(e,t){let{render:n,...r}=e;const o=n&&"function"!=typeof n?n.props:{},{activeIndex:l,onNavigate:c}=u.useContext(ne),{ref:s,index:a}=ee(),f=i([s,t,o.ref]),d=l===a;return te(n,{...r,...o,ref:f,tabIndex:d?0:-1,"data-active":d?"":void 0,onFocus(e){null==r.onFocus||r.onFocus(e),null==o.onFocus||o.onFocus(e),c(a)}})}));function ce(){return ce=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},ce.apply(this,arguments)}let se=!1,ae=0;const fe=()=>"floating-ui-"+ae++;const de=u["useId".toString()]||function(){const[e,t]=u.useState((()=>se?fe():void 0));return Z((()=>{null==e&&t(fe())}),[]),u.useEffect((()=>{se||(se=!0)}),[]),e},ve=u.forwardRef((function(e,t){let{context:{placement:r,elements:{floating:o},middlewareData:{arrow:i}},width:l=14,height:c=7,tipRadius:s=0,strokeWidth:a=0,staticOffset:f,stroke:d,d:v,style:{transform:m,...p}={},...g}=e;const h=de();if(!o)return null;a*=2;const y=a/2,b=l/2*(s/-8+1),E=c/2*s/4,[w,x]=r.split("-"),R=n.platform.isRTL(o),I=!!v,k="top"===w||"bottom"===w,O=f&&"end"===x?"bottom":"top";let C=f&&"end"===x?"right":"left";f&&R&&(C="end"===x?"left":"right");const M=null!=(null==i?void 0:i.x)?f||i.x:"",T=null!=(null==i?void 0:i.y)?f||i.y:"",S=v||"M0,0 H"+l+" L"+(l-b)+","+(c-E)+" Q"+l/2+","+c+" "+b+","+(c-E)+" Z",P={top:I?"rotate(180deg)":"",left:I?"rotate(90deg)":"rotate(-90deg)",bottom:I?"":"rotate(180deg)",right:I?"rotate(-90deg)":"rotate(90deg)"}[w];return u.createElement("svg",ce({},g,{"aria-hidden":!0,ref:t,width:I?l:l+a,height:l,viewBox:"0 0 "+l+" "+(c>l?c:l),style:{position:"absolute",pointerEvents:"none",[C]:M,[O]:T,[w]:k||I?"100%":"calc(100% - "+a/2+"px)",transform:""+P+(null!=m?m:""),...p}}),a>0&&u.createElement("path",{clipPath:"url(#"+h+")",fill:"none",stroke:d,strokeWidth:a+(v?0:1),d:S}),u.createElement("path",{stroke:a&&!v?g.fill:"none",d:S}),u.createElement("clipPath",{id:h},u.createElement("rect",{x:-y,y:y*(I?-1:1),width:l+a,height:l})))}));function me(){const e=new Map;return{emit(t,n){var r;null==(r=e.get(t))||r.forEach((e=>e(n)))},on(t,n){e.set(t,[...e.get(t)||[],n])},off(t,n){var r;e.set(t,(null==(r=e.get(t))?void 0:r.filter((e=>e!==n)))||[])}}}const pe=u.createContext(null),ge=u.createContext(null),he=()=>{var e;return(null==(e=u.useContext(pe))?void 0:e.id)||null},ye=()=>u.useContext(ge);function be(e){return"data-floating-ui-"+e}function Ee(e){const n=t.useRef(e);return Z((()=>{n.current=e})),n}const we=be("safe-polygon");function xe(e,t,n){return n&&!O(n)?0:"number"==typeof e?e:null==e?void 0:e[t]}const Re=u.createContext({delay:0,initialDelay:0,timeoutMs:0,currentId:null,setCurrentId:()=>{},setState:()=>{},isInstantPhase:!1}),Ie=()=>u.useContext(Re);
 /*!
   * tabbable 6.2.0
   * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
   */
-var Me=["input:not([inert])","select:not([inert])","textarea:not([inert])","a[href]:not([inert])","button:not([inert])","[tabindex]:not(slot):not([inert])","audio[controls]:not([inert])","video[controls]:not([inert])",'[contenteditable]:not([contenteditable="false"]):not([inert])',"details>summary:first-of-type:not([inert])","details:not([inert])"].join(","),Te="undefined"==typeof Element,Pe=Te?function(){}:Element.prototype.matches||Element.prototype.msMatchesSelector||Element.prototype.webkitMatchesSelector,Se=!Te&&Element.prototype.getRootNode?function(e){var t;return null==e||null===(t=e.getRootNode)||void 0===t?void 0:t.call(e)}:function(e){return null==e?void 0:e.ownerDocument},Le=function e(t,n){var r;void 0===n&&(n=!0);var o=null==t||null===(r=t.getAttribute)||void 0===r?void 0:r.call(t,"inert");return""===o||"true"===o||n&&t&&e(t.parentNode)},Ae=function e(t,n,r){for(var o=[],u=Array.from(t);u.length;){var i=u.shift();if(!Le(i,!1))if("SLOT"===i.tagName){var c=i.assignedElements(),l=e(c.length?c:i.children,!0,r);r.flatten?o.push.apply(o,l):o.push({scopeParent:i,candidates:l})}else{Pe.call(i,Me)&&r.filter(i)&&(n||!t.includes(i))&&o.push(i);var s=i.shadowRoot||"function"==typeof r.getShadowRoot&&r.getShadowRoot(i),a=!Le(s,!1)&&(!r.shadowRootFilter||r.shadowRootFilter(i));if(s&&a){var f=e(!0===s?i.children:s.children,!0,r);r.flatten?o.push.apply(o,f):o.push({scopeParent:i,candidates:f})}else u.unshift.apply(u,i.children)}}return o},Ne=function(e){return!isNaN(parseInt(e.getAttribute("tabindex"),10))},De=function(e){if(!e)throw new Error("No node provided");return e.tabIndex<0&&(/^(AUDIO|VIDEO|DETAILS)$/.test(e.tagName)||function(e){var t,n=null==e||null===(t=e.getAttribute)||void 0===t?void 0:t.call(e,"contenteditable");return""===n||"true"===n}(e))&&!Ne(e)?0:e.tabIndex},Fe=function(e,t){return e.tabIndex===t.tabIndex?e.documentOrder-t.documentOrder:e.tabIndex-t.tabIndex},je=function(e){return"INPUT"===e.tagName},Ke=function(e){return function(e){return je(e)&&"radio"===e.type}(e)&&!function(e){if(!e.name)return!0;var t,n=e.form||Se(e),r=function(e){return n.querySelectorAll('input[type="radio"][name="'+e+'"]')};if("undefined"!=typeof window&&void 0!==window.CSS&&"function"==typeof window.CSS.escape)t=r(window.CSS.escape(e.name));else try{t=r(e.name)}catch(e){return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s",e.message),!1}var o=function(e,t){for(var n=0;n<e.length;n++)if(e[n].checked&&e[n].form===t)return e[n]}(t,e.form);return!o||o===e}(e)},He=function(e){var t=e.getBoundingClientRect(),n=t.width,r=t.height;return 0===n&&0===r},qe=function(e,t){var n=t.displayCheck,r=t.getShadowRoot;if("hidden"===getComputedStyle(e).visibility)return!0;var o=Pe.call(e,"details>summary:first-of-type")?e.parentElement:e;if(Pe.call(o,"details:not([open]) *"))return!0;if(n&&"full"!==n&&"legacy-full"!==n){if("non-zero-area"===n)return He(e)}else{if("function"==typeof r){for(var u=e;e;){var i=e.parentElement,c=Se(e);if(i&&!i.shadowRoot&&!0===r(i))return He(e);e=e.assignedSlot?e.assignedSlot:i||c===e.ownerDocument?i:c.host}e=u}if(function(e){var t,n,r,o,u=e&&Se(e),i=null===(t=u)||void 0===t?void 0:t.host,c=!1;if(u&&u!==e)for(c=!!(null!==(n=i)&&void 0!==n&&null!==(r=n.ownerDocument)&&void 0!==r&&r.contains(i)||null!=e&&null!==(o=e.ownerDocument)&&void 0!==o&&o.contains(e));!c&&i;){var l,s,a;c=!(null===(s=i=null===(l=u=Se(i))||void 0===l?void 0:l.host)||void 0===s||null===(a=s.ownerDocument)||void 0===a||!a.contains(i))}return c}(e))return!e.getClientRects().length;if("legacy-full"!==n)return!0}return!1},_e=function(e,t){return!(t.disabled||Le(t)||function(e){return je(e)&&"hidden"===e.type}(t)||qe(t,e)||function(e){return"DETAILS"===e.tagName&&Array.prototype.slice.apply(e.children).some((function(e){return"SUMMARY"===e.tagName}))}(t)||function(e){if(/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(e.tagName))for(var t=e.parentElement;t;){if("FIELDSET"===t.tagName&&t.disabled){for(var n=0;n<t.children.length;n++){var r=t.children.item(n);if("LEGEND"===r.tagName)return!!Pe.call(t,"fieldset[disabled] *")||!r.contains(e)}return!0}t=t.parentElement}return!1}(t))},Be=function(e,t){return!(Ke(t)||De(t)<0||!_e(e,t))},We=function(e){var t=parseInt(e.getAttribute("tabindex"),10);return!!(isNaN(t)||t>=0)},Ue=function e(t){var n=[],r=[];return t.forEach((function(t,o){var u=!!t.scopeParent,i=u?t.scopeParent:t,c=function(e,t){var n=De(e);return n<0&&t&&!Ne(e)?0:n}(i,u),l=u?e(t.candidates):i;0===c?u?n.push.apply(n,l):n.push(i):r.push({documentOrder:o,tabIndex:c,item:t,isScope:u,content:l})})),r.sort(Fe).reduce((function(e,t){return t.isScope?e.push.apply(e,t.content):e.push(t.content),e}),[]).concat(n)},ze=function(e,t){var n;return n=(t=t||{}).getShadowRoot?Ae([e],t.includeContainer,{filter:Be.bind(null,t),flatten:!1,getShadowRoot:t.getShadowRoot,shadowRootFilter:We}):function(e,t,n){if(Le(e))return[];var r=Array.prototype.slice.apply(e.querySelectorAll(Me));return t&&Pe.call(e,Me)&&r.unshift(e),r.filter(n)}(e,t.includeContainer,Be.bind(null,t)),Ue(n)},Xe=function(e,t){if(t=t||{},!e)throw new Error("No node provided");return!1!==Pe.call(e,Me)&&Be(t,e)};function Ye(e,t){let n=e.filter((e=>{var n;return e.parentId===t&&(null==(n=e.context)?void 0:n.open)})),r=n;for(;r.length;)r=e.filter((e=>{var t;return null==(t=r)?void 0:t.some((t=>{var n;return e.parentId===t.id&&(null==(n=e.context)?void 0:n.open)}))})),n=n.concat(r);return n}let Ve=new WeakMap,Ge=new WeakSet,Ze={},$e=0;const Qe=e=>e&&(e.host||Qe(e.parentNode)),Je=(e,t)=>t.map((t=>{if(e.contains(t))return t;const n=Qe(t);return e.contains(n)?n:null})).filter((e=>null!=e));function et(e,t,n){void 0===t&&(t=!1),void 0===n&&(n=!1);const r=M(e[0]).body;return function(e,t,n,r){const o="data-floating-ui-inert",u=r?"inert":n?"aria-hidden":null,i=Je(t,e),c=new Set,l=new Set(i),s=[];Ze[o]||(Ze[o]=new WeakMap);const f=Ze[o];return i.forEach((function e(t){t&&!c.has(t)&&(c.add(t),t.parentNode&&e(t.parentNode))})),function e(t){t&&!l.has(t)&&[].forEach.call(t.children,(t=>{if("script"!==a(t))if(c.has(t))e(t);else{const e=u?t.getAttribute(u):null,n=null!==e&&"false"!==e,r=(Ve.get(t)||0)+1,i=(f.get(t)||0)+1;Ve.set(t,r),f.set(t,i),s.push(t),1===r&&n&&Ge.add(t),1===i&&t.setAttribute(o,""),!n&&u&&t.setAttribute(u,"true")}}))}(t),c.clear(),$e++,()=>{s.forEach((e=>{const t=(Ve.get(e)||0)-1,n=(f.get(e)||0)-1;Ve.set(e,t),f.set(e,n),t||(!Ge.has(e)&&u&&e.removeAttribute(u),Ge.delete(e)),n||e.removeAttribute(o)})),$e--,$e||(Ve=new WeakMap,Ve=new WeakMap,Ge=new WeakSet,Ze={})}}(e.concat(Array.from(r.querySelectorAll("[aria-live]"))),r,t,n)}const tt=()=>({getShadowRoot:!0,displayCheck:"function"==typeof ResizeObserver&&ResizeObserver.toString().includes("[native code]")?"full":"none"});function nt(e,t){const n=ze(e,tt());"prev"===t&&n.reverse();const r=n.indexOf(y(M(e)));return n.slice(r+1)[0]}function rt(){return nt(document.body,"next")}function ot(){return nt(document.body,"prev")}function ut(e,t){const n=t||e.currentTarget,r=e.relatedTarget;return!r||!b(n,r)}function it(e){ze(e,tt()).forEach((e=>{e.dataset.tabindex=e.getAttribute("tabindex")||"",e.setAttribute("tabindex","-1")}))}function ct(e){e.querySelectorAll("[data-tabindex]").forEach((e=>{const t=e.dataset.tabindex;delete e.dataset.tabindex,t?e.setAttribute("tabindex",t):e.removeAttribute("tabindex")}))}const lt={border:0,clip:"rect(0 0 0 0)",height:"1px",margin:"-1px",overflow:"hidden",padding:0,position:"fixed",whiteSpace:"nowrap",width:"1px",top:0,left:0};function st(e){"Tab"===e.key&&(e.target,clearTimeout(undefined))}const at=u.forwardRef((function(e,t){const[n,r]=u.useState();Q((()=>(I()&&r("button"),document.addEventListener("keydown",st),()=>{document.removeEventListener("keydown",st)})),[]);const o={ref:t,tabIndex:0,role:n,"aria-hidden":!n||void 0,[Ee("focus-guard")]:"",style:lt};return u.createElement("span",ae({},e,o))})),ft=u.createContext(null),dt=Ee("portal");function vt(e){void 0===e&&(e={});const{id:t,root:n}=e,r=me(),o=mt(),[i,c]=u.useState(null),l=u.useRef(null);return Q((()=>()=>{null==i||i.remove(),queueMicrotask((()=>{l.current=null}))}),[i]),Q((()=>{if(!r)return;if(l.current)return;const e=t?document.getElementById(t):null;if(!e)return;const n=document.createElement("div");n.id=r,n.setAttribute(dt,""),e.appendChild(n),l.current=n,c(n)}),[t,r]),Q((()=>{if(!r)return;if(l.current)return;let e=n||(null==o?void 0:o.portalNode);e&&!v(e)&&(e=e.current),e=e||document.body;let u=null;t&&(u=document.createElement("div"),u.id=t,e.appendChild(u));const i=document.createElement("div");i.id=r,i.setAttribute(dt,""),e=u||e,e.appendChild(i),l.current=i,c(i)}),[t,n,r,o]),i}const mt=()=>u.useContext(ft),pt=20;let gt=[];function ht(e){gt=gt.filter((e=>e.isConnected));let t=e;if(t&&"body"!==a(t)){if(!Xe(t,tt())){const e=ze(t,tt())[0];e&&(t=e)}gt.push(t),gt.length>pt&&(gt=gt.slice(-pt))}}function yt(){return gt.slice().reverse().find((e=>e.isConnected))}const bt=u.forwardRef((function(e,t){return u.createElement("button",ae({},e,{type:"button",ref:t,tabIndex:-1,style:lt}))}));const wt=new Set,Et=u.forwardRef((function(e,t){const{lockScroll:n=!1,...r}=e,o=me();return Q((()=>{if(!n)return;wt.add(o);const e=/iP(hone|ad|od)|iOS/.test(w()),t=document.body.style,r=Math.round(document.documentElement.getBoundingClientRect().left)+document.documentElement.scrollLeft?"paddingLeft":"paddingRight",u=window.innerWidth-document.documentElement.clientWidth,i=t.left?parseFloat(t.left):window.pageXOffset,c=t.top?parseFloat(t.top):window.pageYOffset;if(t.overflow="hidden",u&&(t[r]=u+"px"),e){var l,s;const e=(null==(l=window.visualViewport)?void 0:l.offsetLeft)||0,n=(null==(s=window.visualViewport)?void 0:s.offsetTop)||0;Object.assign(t,{position:"fixed",top:-(c-Math.floor(n))+"px",left:-(i-Math.floor(e))+"px",right:"0"})}return()=>{wt.delete(o),0===wt.size&&(Object.assign(t,{overflow:"",[r]:""}),e&&(Object.assign(t,{position:"",top:"",left:"",right:""}),window.scrollTo(i,c)))}}),[o,n]),u.createElement("div",ae({ref:t},r,{style:{position:"fixed",overflow:"auto",top:0,right:0,bottom:0,left:0,...r.style}}))}));function xt(e){return m(e.target)&&"BUTTON"===e.target.tagName}function Rt(e){return L(e)}function It(e){return null!=e&&null!=e.clientX}const kt={pointerdown:"onPointerDown",mousedown:"onMouseDown",click:"onClick"},Ot={pointerdown:"onPointerDownCapture",mousedown:"onMouseDownCapture",click:"onClickCapture"},Ct=e=>{var t,n;return{escapeKey:"boolean"==typeof e?e:null!=(t=null==e?void 0:e.escapeKey)&&t,outsidePress:"boolean"==typeof e?e:null==(n=null==e?void 0:e.outsidePress)||n}};function Mt(e){const{open:t=!1,onOpenChange:n,elements:r}=e,o=me(),i=u.useRef({}),[c]=u.useState((()=>ge())),l=null!=be(),[a,f]=u.useState(r.reference),d=s(((e,t,r)=>{i.current.openEvent=e?t:void 0,c.emit("openchange",{open:e,event:t,reason:r,nested:l}),null==n||n(e,t,r)})),v=u.useMemo((()=>({setPositionReference:f})),[]),m=u.useMemo((()=>({reference:a||r.reference||null,floating:r.floating||null,domReference:r.reference})),[a,r.reference,r.floating]);return u.useMemo((()=>({dataRef:i,open:t,onOpenChange:d,elements:m,events:c,floatingId:o,refs:v})),[t,d,m,c,o,v])}const Tt="active",Pt="selected";function St(e,t,n){const r=new Map,o="item"===n;let u=e;if(o&&e){const{[Tt]:t,[Pt]:n,...r}=e;u=r}return{..."floating"===n&&{tabIndex:-1},...u,...t.map((t=>{const r=t?t[n]:null;return"function"==typeof r?e?r(e):null:r})).concat(e).reduce(((e,t)=>t?(Object.entries(t).forEach((t=>{let[n,u]=t;var i;o&&[Tt,Pt].includes(n)||(0===n.indexOf("on")?(r.has(n)||r.set(n,[]),"function"==typeof u&&(null==(i=r.get(n))||i.push(u),e[n]=function(){for(var e,t=arguments.length,o=new Array(t),u=0;u<t;u++)o[u]=arguments[u];return null==(e=r.get(n))?void 0:e.map((e=>e(...o))).find((e=>void 0!==e))})):e[n]=u)})),e):e),{})}}let Lt=!1;function At(e,t,n){switch(e){case"vertical":return t;case"horizontal":return n;default:return t||n}}function Nt(e,t){return At(t,e===F||e===j,e===K||e===H)}function Dt(e,t,n){return At(t,e===j,n?e===K:e===H)||"Enter"===e||" "===e||""===e}function Ft(e,t,n){return At(t,n?e===H:e===K,e===F)}const jt=new Map([["select","listbox"],["combobox","listbox"],["label",!1]]);const Kt=e=>e.replace(/[A-Z]+(?![a-z])|[A-Z]/g,((e,t)=>(t?"-":"")+e.toLowerCase()));function Ht(e,t){return"function"==typeof e?e(t):e}function qt(e,t){void 0===t&&(t={});const{open:n,elements:{floating:r}}=e,{duration:o=250}=t,i=("number"==typeof o?o:o.close)||0,[c,l]=u.useState("unmounted"),s=function(e,t){const[n,r]=u.useState(e);return e&&!n&&r(!0),u.useEffect((()=>{if(!e&&n){const e=setTimeout((()=>r(!1)),t);return()=>clearTimeout(e)}}),[e,n,t]),n}(n,i);return s||"close"!==c||l("unmounted"),Q((()=>{if(r){if(n){l("initial");const e=requestAnimationFrame((()=>{l("open")}));return()=>{cancelAnimationFrame(e)}}l("close")}}),[n,r]),{isMounted:s,status:c}}function _t(e,t){return{...e,rects:{...e.rects,floating:{...e.rects.floating,height:t}}}}function Bt(e,t){const[n,r]=e;let o=!1;const u=t.length;for(let e=0,i=u-1;e<u;i=e++){const[u,c]=t[e]||[0,0],[l,s]=t[i]||[0,0];c>=r!=s>=r&&n<=(l-u)*(r-c)/(s-c)+u&&(o=!o)}return o}Object.defineProperty(e,"arrow",{enumerable:!0,get:function(){return n.arrow}}),Object.defineProperty(e,"autoPlacement",{enumerable:!0,get:function(){return n.autoPlacement}}),Object.defineProperty(e,"autoUpdate",{enumerable:!0,get:function(){return n.autoUpdate}}),Object.defineProperty(e,"computePosition",{enumerable:!0,get:function(){return n.computePosition}}),Object.defineProperty(e,"detectOverflow",{enumerable:!0,get:function(){return n.detectOverflow}}),Object.defineProperty(e,"flip",{enumerable:!0,get:function(){return n.flip}}),Object.defineProperty(e,"getOverflowAncestors",{enumerable:!0,get:function(){return n.getOverflowAncestors}}),Object.defineProperty(e,"hide",{enumerable:!0,get:function(){return n.hide}}),Object.defineProperty(e,"inline",{enumerable:!0,get:function(){return n.inline}}),Object.defineProperty(e,"limitShift",{enumerable:!0,get:function(){return n.limitShift}}),Object.defineProperty(e,"offset",{enumerable:!0,get:function(){return n.offset}}),Object.defineProperty(e,"platform",{enumerable:!0,get:function(){return n.platform}}),Object.defineProperty(e,"shift",{enumerable:!0,get:function(){return n.shift}}),Object.defineProperty(e,"size",{enumerable:!0,get:function(){return n.size}}),e.Composite=le,e.CompositeItem=se,e.FloatingArrow=pe,e.FloatingDelayGroup=function(e){const{children:t,delay:n,timeoutMs:r=0}=e,[o,i]=u.useReducer(((e,t)=>({...e,...t})),{delay:n,timeoutMs:r,initialDelay:n,currentId:null,isInstantPhase:!1}),c=u.useRef(null),l=u.useCallback((e=>{i({currentId:e})}),[]);return Q((()=>{o.currentId?null===c.current?c.current=o.currentId:o.isInstantPhase||i({isInstantPhase:!0}):(o.isInstantPhase&&i({isInstantPhase:!1}),c.current=null)}),[o.currentId,o.isInstantPhase]),u.createElement(Oe.Provider,{value:u.useMemo((()=>({...o,setState:i,setCurrentId:l})),[o,l])},t)},e.FloatingFocusManager=function(e){const{context:t,children:n,disabled:r=!1,order:o=["content"],guards:i=!0,initialFocus:c=0,returnFocus:l=!0,modal:s=!0,visuallyHiddenDismiss:a=!1,closeOnFocusOut:f=!0}=e,{open:d,refs:v,nodeId:p,onOpenChange:g,events:h,dataRef:w,elements:{domReference:E,floating:I}}=t,k="number"==typeof c&&c<0,O=N(E)&&k,C="undefined"==typeof HTMLElement||!("inert"in HTMLElement.prototype)||i,T=xe(o),S=xe(c),L=xe(l),D=we(),F=mt(),j=u.useRef(null),K=u.useRef(null),H=u.useRef(!1),q=u.useRef(!1),_=null!=F,B=u.useCallback((function(e){return void 0===e&&(e=I),e?ze(e,tt()):[]}),[I]),W=u.useCallback((e=>{const t=B(e);return T.current.map((e=>E&&"reference"===e?E:I&&"floating"===e?I:t)).filter(Boolean).flat()}),[E,I,T,B]);function U(e){return!r&&a&&s?u.createElement(bt,{ref:"start"===e?j:K,onClick:e=>g(!1,e.nativeEvent)},"string"==typeof a?a:"Dismiss"):null}u.useEffect((()=>{if(r||!s)return;function e(e){if("Tab"===e.key){b(I,y(M(I)))&&0===B().length&&!O&&A(e);const t=W(),n=P(e);"reference"===T.current[0]&&n===E&&(A(e),e.shiftKey?$(t[t.length-1]):$(t[1])),"floating"===T.current[1]&&n===I&&e.shiftKey&&(A(e),$(t[0]))}}const t=M(I);return t.addEventListener("keydown",e),()=>{t.removeEventListener("keydown",e)}}),[r,E,I,s,T,O,B,W]),u.useEffect((()=>{if(!r&&f)return I&&m(E)?(E.addEventListener("focusout",t),E.addEventListener("pointerdown",e),!s&&I.addEventListener("focusout",t),()=>{E.removeEventListener("focusout",t),E.removeEventListener("pointerdown",e),!s&&I.removeEventListener("focusout",t)}):void 0;function e(){q.current=!0,setTimeout((()=>{q.current=!1}))}function t(e){const t=e.relatedTarget;queueMicrotask((()=>{const n=!(b(E,t)||b(I,t)||b(t,I)||b(null==F?void 0:F.portalNode,t)||null!=t&&t.hasAttribute(Ee("focus-guard"))||D&&(Ye(D.nodesRef.current,p).find((e=>{var n,r;return b(null==(n=e.context)?void 0:n.elements.floating,t)||b(null==(r=e.context)?void 0:r.elements.domReference,t)}))||function(e,t){var n;let r=[],o=null==(n=e.find((e=>e.id===t)))?void 0:n.parentId;for(;o;){const t=e.find((e=>e.id===o));o=null==t?void 0:t.parentId,t&&(r=r.concat(t))}return r}(D.nodesRef.current,p).find((e=>{var n,r;return(null==(n=e.context)?void 0:n.elements.floating)===t||(null==(r=e.context)?void 0:r.elements.domReference)===t}))));t&&n&&!q.current&&t!==yt()&&(H.current=!0,g(!1,e))}))}}),[r,E,I,s,p,D,F,g,f]),u.useEffect((()=>{var e;if(r)return;const t=Array.from((null==F||null==(e=F.portalNode)?void 0:e.querySelectorAll("["+Ee("portal")+"]"))||[]);if(I){const e=[I,...t,j.current,K.current,T.current.includes("reference")||O?E:null].filter((e=>null!=e)),n=s||O?et(e,C,!C):et(e);return()=>{n()}}}),[r,E,I,s,T,F,O,C]),Q((()=>{if(r||!I)return;const e=y(M(I));queueMicrotask((()=>{const t=W(I),n=S.current,r=("number"==typeof n?t[n]:n.current)||I,o=b(I,e);k||o||!d||$(r,{preventScroll:r===I})}))}),[r,d,I,k,W,S]),Q((()=>{if(r||!I)return;let e=!1;const t=M(I),n=y(t);let o=w.current.openEvent;function u(t){let{open:n,reason:r,event:u,nested:i}=t;n&&(o=u),"escape-key"===r&&v.domReference.current&&ht(v.domReference.current),"hover"===r&&"mouseleave"===u.type&&(H.current=!0),"outside-press"===r&&(i?(H.current=!1,e=!0):H.current=!(x(u)||R(u)))}return ht(n),h.on("openchange",u),()=>{h.off("openchange",u);const n=y(t),r=b(I,n)||D&&Ye(D.nodesRef.current,p).some((e=>{var t;return b(null==(t=e.context)?void 0:t.elements.floating,n)}));(r||o&&["click","mousedown"].includes(o.type))&&v.domReference.current&&ht(v.domReference.current);const i=yt();L.current&&!H.current&&m(i)&&(i===n||n===t.body||r)&&$(i,{cancelPrevious:!1,preventScroll:e})}}),[r,I,L,w,v,h,D,p]),Q((()=>{if(!r&&F)return F.setFocusManagerState({modal:s,closeOnFocusOut:f,open:d,onOpenChange:g,refs:v}),()=>{F.setFocusManagerState(null)}}),[r,F,s,d,g,v,f]),Q((()=>{if(r||!I||"function"!=typeof MutationObserver||k)return;const e=()=>{const e=I.getAttribute("tabindex");T.current.includes("floating")||y(M(I))!==v.domReference.current&&0===B().length?"0"!==e&&I.setAttribute("tabindex","0"):"-1"!==e&&I.setAttribute("tabindex","-1")};e();const t=new MutationObserver(e);return t.observe(I,{childList:!0,subtree:!0,attributes:!0}),()=>{t.disconnect()}}),[r,I,v,T,B,k]);const z=!r&&C&&(_||s);return u.createElement(u.Fragment,null,z&&u.createElement(at,{"data-type":"inside",ref:null==F?void 0:F.beforeInsideRef,onFocus:e=>{if(s){const e=W();$("reference"===o[0]?e[0]:e[e.length-1])}else if(null!=F&&F.preserveTabOrder&&F.portalNode)if(H.current=!1,ut(e,F.portalNode)){const e=rt()||E;null==e||e.focus()}else{var t;null==(t=F.beforeOutsideRef.current)||t.focus()}}}),!O&&U("start"),n,U("end"),z&&u.createElement(at,{"data-type":"inside",ref:null==F?void 0:F.afterInsideRef,onFocus:e=>{if(s)$(W()[0]);else if(null!=F&&F.preserveTabOrder&&F.portalNode)if(f&&(H.current=!0),ut(e,F.portalNode)){const e=ot()||E;null==e||e.focus()}else{var t;null==(t=F.afterOutsideRef.current)||t.focus()}}}))},e.FloatingList=te,e.FloatingNode=function(e){const{children:t,id:n}=e,r=be();return u.createElement(he.Provider,{value:u.useMemo((()=>({id:n,parentId:r})),[n,r])},t)},e.FloatingOverlay=Et,e.FloatingPortal=function(e){const{children:t,id:n,root:o=null,preserveTabOrder:i=!0}=e,c=vt({id:n,root:o}),[l,s]=u.useState(null),a=u.useRef(null),f=u.useRef(null),d=u.useRef(null),v=u.useRef(null),m=!!l&&!l.modal&&l.open&&i&&!(!o&&!c);return u.useEffect((()=>{if(c&&i&&(null==l||!l.modal))return c.addEventListener("focusin",e,!0),c.addEventListener("focusout",e,!0),()=>{c.removeEventListener("focusin",e,!0),c.removeEventListener("focusout",e,!0)};function e(e){if(c&&ut(e)){("focusin"===e.type?ct:it)(c)}}}),[c,i,null==l?void 0:l.modal]),u.createElement(ft.Provider,{value:u.useMemo((()=>({preserveTabOrder:i,beforeOutsideRef:a,afterOutsideRef:f,beforeInsideRef:d,afterInsideRef:v,portalNode:c,setFocusManagerState:s})),[i,c])},m&&c&&u.createElement(at,{"data-type":"outside",ref:a,onFocus:e=>{if(ut(e,c)){var t;null==(t=d.current)||t.focus()}else{const e=ot()||(null==l?void 0:l.refs.domReference.current);null==e||e.focus()}}}),m&&c&&u.createElement("span",{"aria-owns":c.id,style:lt}),c&&r.createPortal(t,c),m&&c&&u.createElement(at,{"data-type":"outside",ref:f,onFocus:e=>{if(ut(e,c)){var t;null==(t=v.current)||t.focus()}else{const t=rt()||(null==l?void 0:l.refs.domReference.current);null==t||t.focus(),(null==l?void 0:l.closeOnFocusOut)&&(null==l||l.onOpenChange(!1,e.nativeEvent))}}}))},e.FloatingTree=function(e){const{children:t}=e,n=u.useRef([]),r=u.useCallback((e=>{n.current=[...n.current,e]}),[]),o=u.useCallback((e=>{n.current=n.current.filter((t=>t!==e))}),[]),i=u.useState((()=>ge()))[0];return u.createElement(ye.Provider,{value:u.useMemo((()=>({nodesRef:n,addNode:r,removeNode:o,events:i})),[r,o,i])},t)},e.inner=e=>({name:"inner",options:e,async fn(t){const{listRef:o,overflowRef:u,onFallbackChange:i,offset:c=0,index:l=0,minItemsVisible:s=4,referenceOverflowThreshold:a=0,scrollRef:f,...d}=e,{rects:v,elements:{floating:m}}=t,p=o.current[l];if(!p)return{};const g={...t,...await n.offset(-p.offsetTop-m.clientTop-v.reference.height/2-p.offsetHeight/2-c).fn(t)},h=(null==f?void 0:f.current)||m,y=await n.detectOverflow(_t(g,h.scrollHeight),d),b=await n.detectOverflow(g,{...d,elementContext:"reference"}),w=Math.max(0,y.top),E=g.y+w,x=Math.max(0,h.scrollHeight-w-Math.max(0,y.bottom));return h.style.maxHeight=x+"px",h.scrollTop=w,i&&(h.offsetHeight<p.offsetHeight*Math.min(s,o.current.length-1)-1||b.top>=-a||b.bottom>=-a?r.flushSync((()=>i(!0))):r.flushSync((()=>i(!1)))),u&&(u.current=await n.detectOverflow(_t({...g,y:E},h.offsetHeight),d)),{y:E}}}),e.safePolygon=function(e){void 0===e&&(e={});const{buffer:t=.5,blockPointerEvents:n=!1,requireIntent:r=!0}=e;let o,u=!1,i=null,c=null,l=performance.now();const s=e=>{let{x:n,y:s,placement:a,elements:f,onClose:d,nodeId:m,tree:p}=e;return function(e){function g(){clearTimeout(o),d()}if(clearTimeout(o),!f.domReference||!f.floating||null==a||null==n||null==s)return;const{clientX:h,clientY:y}=e,w=[h,y],E=P(e),x="mouseleave"===e.type,R=b(f.floating,E),I=b(f.domReference,E),k=f.domReference.getBoundingClientRect(),O=f.floating.getBoundingClientRect(),C=a.split("-")[0],M=n>O.right-O.width/2,T=s>O.bottom-O.height/2,S=function(e,t){return e[0]>=t.x&&e[0]<=t.x+t.width&&e[1]>=t.y&&e[1]<=t.y+t.height}(w,k),L=O.width>k.width,A=O.height>k.height,N=(L?k:O).left,D=(L?k:O).right,F=(A?k:O).top,j=(A?k:O).bottom;if(R&&(u=!0,!x))return;if(I&&(u=!1),I&&!x)return void(u=!0);if(x&&v(e.relatedTarget)&&b(f.floating,e.relatedTarget))return;if(p&&Ye(p.nodesRef.current,m).some((e=>{let{context:t}=e;return null==t?void 0:t.open})))return;if("top"===C&&s>=k.bottom-1||"bottom"===C&&s<=k.top+1||"left"===C&&n>=k.right-1||"right"===C&&n<=k.left+1)return g();let K=[];switch(C){case"top":K=[[N,k.top+1],[N,O.bottom-1],[D,O.bottom-1],[D,k.top+1]];break;case"bottom":K=[[N,O.top+1],[N,k.bottom-1],[D,k.bottom-1],[D,O.top+1]];break;case"left":K=[[O.right-1,j],[O.right-1,F],[k.left+1,F],[k.left+1,j]];break;case"right":K=[[k.right-1,j],[k.right-1,F],[O.left+1,F],[O.left+1,j]]}if(!Bt([h,y],K)){if(u&&!S)return g();if(!x&&r){const t=function(e,t){const n=performance.now(),r=n-l;if(null===i||null===c||0===r)return i=e,c=t,l=n,null;const o=e-i,u=t-c,s=Math.sqrt(o*o+u*u);return i=e,c=t,l=n,s/r}(e.clientX,e.clientY);if(null!==t&&t<.1)return g()}Bt([h,y],function(e){let[n,r]=e;switch(C){case"top":return[[L?n+t/2:M?n+4*t:n-4*t,r+t+1],[L?n-t/2:M?n+4*t:n-4*t,r+t+1],...[[O.left,M||L?O.bottom-t:O.top],[O.right,M?L?O.bottom-t:O.top:O.bottom-t]]];case"bottom":return[[L?n+t/2:M?n+4*t:n-4*t,r-t],[L?n-t/2:M?n+4*t:n-4*t,r-t],...[[O.left,M||L?O.top+t:O.bottom],[O.right,M?L?O.top+t:O.bottom:O.top+t]]];case"left":{const e=[n+t+1,A?r+t/2:T?r+4*t:r-4*t],o=[n+t+1,A?r-t/2:T?r+4*t:r-4*t];return[...[[T||A?O.right-t:O.left,O.top],[T?A?O.right-t:O.left:O.right-t,O.bottom]],e,o]}case"right":return[[n-t,A?r+t/2:T?r+4*t:r-4*t],[n-t,A?r-t/2:T?r+4*t:r-4*t],...[[T||A?O.left+t:O.right,O.top],[T?A?O.left+t:O.right:O.left+t,O.bottom]]]}}([n,s]))?!u&&r&&(o=window.setTimeout(g,40)):g()}}};return s.__options={blockPointerEvents:n},s},e.useClick=function(e,t){void 0===t&&(t={});const{open:n,onOpenChange:r,dataRef:o,elements:{domReference:i}}=e,{enabled:c=!0,event:l="click",toggle:s=!0,ignoreMouse:a=!1,keyboardHandlers:f=!0}=t,d=u.useRef(),v=u.useRef(!1);return u.useMemo((()=>c?{reference:{onPointerDown(e){d.current=e.pointerType},onMouseDown(e){0===e.button&&(C(d.current,!0)&&a||"click"!==l&&(!n||!s||o.current.openEvent&&"mousedown"!==o.current.openEvent.type?(e.preventDefault(),r(!0,e.nativeEvent,"click")):r(!1,e.nativeEvent,"click")))},onClick(e){"mousedown"===l&&d.current?d.current=void 0:C(d.current,!0)&&a||(!n||!s||o.current.openEvent&&"click"!==o.current.openEvent.type?r(!0,e.nativeEvent,"click"):r(!1,e.nativeEvent,"click"))},onKeyDown(e){d.current=void 0,e.defaultPrevented||!f||xt(e)||(" "!==e.key||Rt(i)||(e.preventDefault(),v.current=!0),"Enter"===e.key&&r(!n||!s,e.nativeEvent,"click"))},onKeyUp(e){e.defaultPrevented||!f||xt(e)||Rt(i)||" "===e.key&&v.current&&(v.current=!1,r(!n||!s,e.nativeEvent,"click"))}}}:{}),[c,o,l,a,f,i,s,n,r])},e.useClientPoint=function(e,t){void 0===t&&(t={});const{open:n,dataRef:r,elements:{floating:o,domReference:i},refs:c}=e,{enabled:l=!0,axis:a="both",x:d=null,y:v=null}=t,m=u.useRef(!1),p=u.useRef(null),[g,h]=u.useState(),[y,w]=u.useState([]),E=s(((e,t)=>{m.current||r.current.openEvent&&!It(r.current.openEvent)||c.setPositionReference(function(e,t){let n=null,r=null,o=!1;return{contextElement:e||void 0,getBoundingClientRect(){var u;const i=(null==e?void 0:e.getBoundingClientRect())||{width:0,height:0,x:0,y:0},c="x"===t.axis||"both"===t.axis,l="y"===t.axis||"both"===t.axis,s=["mouseenter","mousemove"].includes((null==(u=t.dataRef.current.openEvent)?void 0:u.type)||"")&&"touch"!==t.pointerType;let a=i.width,f=i.height,d=i.x,v=i.y;return null==n&&t.x&&c&&(n=i.x-t.x),null==r&&t.y&&l&&(r=i.y-t.y),d-=n||0,v-=r||0,a=0,f=0,!o||s?(a="y"===t.axis?i.width:0,f="x"===t.axis?i.height:0,d=c&&null!=t.x?t.x:d,v=l&&null!=t.y?t.y:v):o&&!s&&(f="x"===t.axis?i.height:f,a="y"===t.axis?i.width:a),o=!0,{width:a,height:f,x:d,y:v,top:v,right:d+a,bottom:v+f,left:d}}}}(i,{x:e,y:t,axis:a,dataRef:r,pointerType:g}))})),x=s((e=>{null==d&&null==v&&(n?p.current||w([]):E(e.clientX,e.clientY))})),R=C(g)?o:n,I=u.useCallback((()=>{if(!R||!l||null!=d||null!=v)return;const e=f(o);function t(n){const r=P(n);b(o,r)?(e.removeEventListener("mousemove",t),p.current=null):E(n.clientX,n.clientY)}if(!r.current.openEvent||It(r.current.openEvent)){e.addEventListener("mousemove",t);const n=()=>{e.removeEventListener("mousemove",t),p.current=null};return p.current=n,n}c.setPositionReference(i)}),[R,l,d,v,o,r,c,i,E]);return u.useEffect((()=>I()),[I,y]),u.useEffect((()=>{l&&!o&&(m.current=!1)}),[l,o]),u.useEffect((()=>{!l&&n&&(m.current=!0)}),[l,n]),Q((()=>{!l||null==d&&null==v||(m.current=!1,E(d,v))}),[l,d,v,E]),u.useMemo((()=>{if(!l)return{};function e(e){let{pointerType:t}=e;h(t)}return{reference:{onPointerDown:e,onPointerEnter:e,onMouseMove:x,onMouseEnter:x}}}),[l,x])},e.useDelayGroup=function(e,t){void 0===t&&(t={});const{open:n,onOpenChange:r,floatingId:o}=e,{id:u}=t,i=null!=u?u:o,c=Ce(),{currentId:l,setCurrentId:s,initialDelay:a,setState:f,timeoutMs:d}=c;return Q((()=>{l&&(f({delay:{open:1,close:Ie(a,"close")}}),l!==i&&r(!1))}),[i,r,f,l,a]),Q((()=>{function e(){r(!1),f({delay:a,currentId:null})}if(l&&!n&&l===i){if(d){const t=window.setTimeout(e,d);return()=>{clearTimeout(t)}}e()}}),[n,f,l,i,r,a,d]),Q((()=>{s!==ke&&n&&s(i)}),[n,s,i]),c},e.useDelayGroupContext=Ce,e.useDismiss=function(e,t){void 0===t&&(t={});const{open:r,onOpenChange:o,elements:{reference:i,domReference:c,floating:l},dataRef:a}=e,{enabled:d=!0,escapeKey:p=!0,outsidePress:y=!0,outsidePressEvent:w="pointerdown",referencePress:E=!1,referencePressEvent:x="pointerdown",ancestorScroll:R=!1,bubbles:I,capture:k}=t,O=we(),C=s("function"==typeof y?y:()=>!1),S="function"==typeof y?C:y,L=u.useRef(!1),A=u.useRef(!1),{escapeKey:N,outsidePress:D}=Ct(I),{escapeKey:F,outsidePress:j}=Ct(k),K=s((e=>{var t;if(!r||!d||!p||"Escape"!==e.key)return;const n=null==(t=a.current.floatingContext)?void 0:t.nodeId,u=O?Ye(O.nodesRef.current,n):[];if(!N&&(e.stopPropagation(),u.length>0)){let e=!0;if(u.forEach((t=>{var n;null==(n=t.context)||!n.open||t.context.dataRef.current.__escapeKeyBubbles||(e=!1)})),!e)return}o(!1,function(e){return"nativeEvent"in e}(e)?e.nativeEvent:e,"escape-key")})),H=s((e=>{var t;const n=()=>{var t;K(e),null==(t=P(e))||t.removeEventListener("keydown",n)};null==(t=P(e))||t.addEventListener("keydown",n)})),q=s((e=>{var t;const n=L.current;L.current=!1;const r=A.current;if(A.current=!1,"click"===w&&r)return;if(n)return;if("function"==typeof S&&!S(e))return;const u=P(e),i="["+Ee("inert")+"]",s=M(l).querySelectorAll(i);let d=v(u)?u:null;for(;d&&!g(d);){const e=h(d);if(g(e)||!v(e))break;d=e}if(s.length&&v(u)&&!u.matches("html,body")&&!b(u,l)&&Array.from(s).every((e=>!b(d,e))))return;if(m(u)&&l){const t=u.clientWidth>0&&u.scrollWidth>u.clientWidth,n=u.clientHeight>0&&u.scrollHeight>u.clientHeight;let r=n&&e.offsetX>u.clientWidth;if(n){const t="rtl"===function(e){return f(e).getComputedStyle(e)}(u).direction;t&&(r=e.offsetX<=u.offsetWidth-u.clientWidth)}if(r||t&&e.offsetY>u.clientHeight)return}const p=null==(t=a.current.floatingContext)?void 0:t.nodeId,y=O&&Ye(O.nodesRef.current,p).some((t=>{var n;return T(e,null==(n=t.context)?void 0:n.elements.floating)}));if(T(e,l)||T(e,c)||y)return;const E=O?Ye(O.nodesRef.current,p):[];if(E.length>0){let e=!0;if(E.forEach((t=>{var n;null==(n=t.context)||!n.open||t.context.dataRef.current.__outsidePressBubbles||(e=!1)})),!e)return}o(!1,e,"outside-press")})),_=s((e=>{var t;const n=()=>{var t;q(e),null==(t=P(e))||t.removeEventListener(w,n)};null==(t=P(e))||t.addEventListener(w,n)}));return u.useEffect((()=>{if(!r||!d)return;function e(e){o(!1,e,"ancestor-scroll")}a.current.__escapeKeyBubbles=N,a.current.__outsidePressBubbles=D;const t=M(l);p&&t.addEventListener("keydown",F?H:K,F),S&&t.addEventListener(w,j?_:q,j);let u=[];return R&&(v(c)&&(u=n.getOverflowAncestors(c)),v(l)&&(u=u.concat(n.getOverflowAncestors(l))),!v(i)&&i&&i.contextElement&&(u=u.concat(n.getOverflowAncestors(i.contextElement)))),u=u.filter((e=>{var n;return e!==(null==(n=t.defaultView)?void 0:n.visualViewport)})),u.forEach((t=>{t.addEventListener("scroll",e,{passive:!0})})),()=>{p&&t.removeEventListener("keydown",F?H:K,F),S&&t.removeEventListener(w,j?_:q,j),u.forEach((t=>{t.removeEventListener("scroll",e)}))}}),[a,l,c,i,p,S,w,r,o,R,d,N,D,K,F,H,q,j,_]),u.useEffect((()=>{L.current=!1}),[S,w]),u.useMemo((()=>d?{reference:{onKeyDown:K,[kt[x]]:e=>{E&&o(!1,e.nativeEvent,"reference-press")}},floating:{onKeyDown:K,onMouseDown(){A.current=!0},onMouseUp(){A.current=!0},[Ot[w]]:()=>{L.current=!0}}}:{}),[d,E,w,x,o,K])},e.useFloating=function(e){void 0===e&&(e={});const{nodeId:t}=e,r=Mt({...e,elements:{reference:null,floating:null,...e.elements}}),o=e.rootContext||r,i=o.elements,[c,l]=u.useState(null),[s,a]=u.useState(null),f=(null==i?void 0:i.reference)||c,d=u.useRef(null),m=we();Q((()=>{f&&(d.current=f)}),[f]);const p=n.useFloating({...e,elements:{...i,...s&&{reference:s}}}),g=u.useCallback((e=>{const t=v(e)?{getBoundingClientRect:()=>e.getBoundingClientRect(),contextElement:e}:e;a(t),p.refs.setReference(t)}),[p.refs]),h=u.useCallback((e=>{(v(e)||null===e)&&(d.current=e,l(e)),(v(p.refs.reference.current)||null===p.refs.reference.current||null!==e&&!v(e))&&p.refs.setReference(e)}),[p.refs]),y=u.useMemo((()=>({...p.refs,setReference:h,setPositionReference:g,domReference:d})),[p.refs,h,g]),b=u.useMemo((()=>({...p.elements,domReference:f})),[p.elements,f]),w=u.useMemo((()=>({...p,...o,refs:y,elements:b,nodeId:t})),[p,y,b,t,o]);return Q((()=>{o.dataRef.current.floatingContext=w;const e=null==m?void 0:m.nodesRef.current.find((e=>e.id===t));e&&(e.context=w)})),u.useMemo((()=>({...p,context:w,refs:y,elements:b})),[p,y,b,w])},e.useFloatingNodeId=function(e){const t=me(),n=we(),r=be(),o=e||r;return Q((()=>{const e={id:t,parentId:o};return null==n||n.addNode(e),()=>{null==n||n.removeNode(e)}}),[n,t,o]),t},e.useFloatingParentNodeId=be,e.useFloatingPortalNode=vt,e.useFloatingRootContext=Mt,e.useFloatingTree=we,e.useFocus=function(e,t){void 0===t&&(t={});const{open:n,onOpenChange:r,events:o,dataRef:i,elements:{domReference:c}}=e,{enabled:l=!0,visibleOnly:s=!0}=t,a=u.useRef(!1),d=u.useRef(),p=u.useRef(!0);return u.useEffect((()=>{if(!l)return;const e=f(c);function t(){!n&&m(c)&&c===y(M(c))&&(a.current=!0)}function r(){p.current=!0}return e.addEventListener("blur",t),e.addEventListener("keydown",r,!0),()=>{e.removeEventListener("blur",t),e.removeEventListener("keydown",r,!0)}}),[c,n,l]),u.useEffect((()=>{if(l)return o.on("openchange",e),()=>{o.off("openchange",e)};function e(e){let{reason:t}=e;"reference-press"!==t&&"escape-key"!==t||(a.current=!0)}}),[o,l]),u.useEffect((()=>()=>{clearTimeout(d.current)}),[]),u.useMemo((()=>l?{reference:{onPointerDown(e){R(e.nativeEvent)||(p.current=!1)},onMouseLeave(){a.current=!1},onFocus(e){if(a.current)return;const t=P(e.nativeEvent);if(s&&v(t))try{if(I()&&O())throw Error();if(!t.matches(":focus-visible"))return}catch(e){if(!p.current&&!L(t))return}r(!0,e.nativeEvent,"focus")},onBlur(e){a.current=!1;const t=e.relatedTarget,n=v(t)&&t.hasAttribute(Ee("focus-guard"))&&"outside"===t.getAttribute("data-type");d.current=window.setTimeout((()=>{var o;const u=y(c?c.ownerDocument:document);(t||u!==c)&&(b(null==(o=i.current.floatingContext)?void 0:o.refs.floating.current,u)||b(c,u)||n||r(!1,e.nativeEvent,"focus"))}))}}}:{}),[l,s,i,c,r])},e.useHover=function(e,t){void 0===t&&(t={});const{open:n,onOpenChange:r,dataRef:o,events:i,elements:{domReference:c,floating:l}}=e,{enabled:a=!0,delay:f=0,handleClose:d=null,mouseOnly:m=!1,restMs:p=0,move:g=!0}=t,h=we(),y=be(),w=xe(d),E=xe(f),x=u.useRef(),R=u.useRef(-1),I=u.useRef(),k=u.useRef(-1),O=u.useRef(!0),T=u.useRef(!1),P=u.useRef((()=>{})),S=u.useCallback((()=>{var e;const t=null==(e=o.current.openEvent)?void 0:e.type;return(null==t?void 0:t.includes("mouse"))&&"mousedown"!==t}),[o]);u.useEffect((()=>{if(a)return i.on("openchange",e),()=>{i.off("openchange",e)};function e(e){let{open:t}=e;t||(clearTimeout(R.current),clearTimeout(k.current),O.current=!0)}}),[a,i]),u.useEffect((()=>{if(!a||!w.current||!n)return;function e(e){S()&&r(!1,e,"hover")}const t=M(l).documentElement;return t.addEventListener("mouseleave",e),()=>{t.removeEventListener("mouseleave",e)}}),[l,n,r,a,w,S]);const L=u.useCallback((function(e,t,n){void 0===t&&(t=!0),void 0===n&&(n="hover");const o=Ie(E.current,"close",x.current);o&&!I.current?(clearTimeout(R.current),R.current=window.setTimeout((()=>r(!1,e,n)),o)):t&&(clearTimeout(R.current),r(!1,e,n))}),[E,r]),A=s((()=>{P.current(),I.current=void 0})),N=s((()=>{if(T.current){const e=M(l).body;e.style.pointerEvents="",e.removeAttribute(Re),T.current=!1}}));return u.useEffect((()=>{if(a&&v(c)){const e=c;return n&&e.addEventListener("mouseleave",i),null==l||l.addEventListener("mouseleave",i),g&&e.addEventListener("mousemove",t,{once:!0}),e.addEventListener("mouseenter",t),e.addEventListener("mouseleave",u),()=>{n&&e.removeEventListener("mouseleave",i),null==l||l.removeEventListener("mouseleave",i),g&&e.removeEventListener("mousemove",t),e.removeEventListener("mouseenter",t),e.removeEventListener("mouseleave",u)}}function e(){return!!o.current.openEvent&&["click","mousedown"].includes(o.current.openEvent.type)}function t(e){if(clearTimeout(R.current),O.current=!1,m&&!C(x.current)||p>0&&!Ie(E.current,"open"))return;const t=Ie(E.current,"open",x.current);t?R.current=window.setTimeout((()=>{r(!0,e,"hover")}),t):r(!0,e,"hover")}function u(t){if(e())return;P.current();const r=M(l);if(clearTimeout(k.current),w.current&&o.current.floatingContext){n||clearTimeout(R.current),I.current=w.current({...o.current.floatingContext,tree:h,x:t.clientX,y:t.clientY,onClose(){N(),A(),L(t,!0,"safe-polygon")}});const e=I.current;return r.addEventListener("mousemove",e),void(P.current=()=>{r.removeEventListener("mousemove",e)})}("touch"!==x.current||!b(l,t.relatedTarget))&&L(t)}function i(t){e()||o.current.floatingContext&&(null==w.current||w.current({...o.current.floatingContext,tree:h,x:t.clientX,y:t.clientY,onClose(){N(),A(),L(t)}})(t))}}),[c,l,a,e,m,p,g,L,A,N,r,n,h,E,w,o]),Q((()=>{var e;if(a&&n&&null!=(e=w.current)&&e.__options.blockPointerEvents&&S()){const e=M(l).body;if(e.setAttribute(Re,""),e.style.pointerEvents="none",T.current=!0,v(c)&&l){var t;const e=c,n=null==h||null==(t=h.nodesRef.current.find((e=>e.id===y)))||null==(t=t.context)?void 0:t.elements.floating;return n&&(n.style.pointerEvents=""),e.style.pointerEvents="auto",l.style.pointerEvents="auto",()=>{e.style.pointerEvents="",l.style.pointerEvents=""}}}}),[a,n,y,l,c,h,w,S]),Q((()=>{n||(x.current=void 0,A(),N())}),[n,A,N]),u.useEffect((()=>()=>{A(),clearTimeout(R.current),clearTimeout(k.current),N()}),[a,c,A,N]),u.useMemo((()=>{if(!a)return{};function e(e){x.current=e.pointerType}return{reference:{onPointerDown:e,onPointerEnter:e,onMouseMove(e){function t(){O.current||r(!0,e.nativeEvent,"hover")}m&&!C(x.current)||n||0===p||(clearTimeout(k.current),"touch"===x.current?t():k.current=window.setTimeout(t,p))}},floating:{onMouseEnter(){clearTimeout(R.current)},onMouseLeave(e){L(e.nativeEvent,!1)}}}}),[a,m,n,p,r,L])},e.useId=me,e.useInnerOffset=function(e,t){const{open:n,elements:o}=e,{enabled:i=!0,overflowRef:c,scrollRef:l,onChange:a}=t,f=s(a),d=u.useRef(!1),v=u.useRef(null),m=u.useRef(null);return u.useEffect((()=>{if(!i)return;function e(e){if(e.ctrlKey||!t||null==c.current)return;const n=e.deltaY,o=c.current.top>=-.5,u=c.current.bottom>=-.5,i=t.scrollHeight-t.clientHeight,l=n<0?-1:1,s=n<0?"max":"min";t.scrollHeight<=t.clientHeight||(!o&&n>0||!u&&n<0?(e.preventDefault(),r.flushSync((()=>{f((e=>e+Math[s](n,i*l)))}))):/firefox/i.test(E())&&(t.scrollTop+=n))}const t=(null==l?void 0:l.current)||o.floating;return n&&t?(t.addEventListener("wheel",e),requestAnimationFrame((()=>{v.current=t.scrollTop,null!=c.current&&(m.current={...c.current})})),()=>{v.current=null,m.current=null,t.removeEventListener("wheel",e)}):void 0}),[i,n,o.floating,c,l,f]),u.useMemo((()=>i?{floating:{onKeyDown(){d.current=!0},onWheel(){d.current=!1},onPointerMove(){d.current=!1},onScroll(){const e=(null==l?void 0:l.current)||o.floating;if(c.current&&e&&d.current){if(null!==v.current){const t=e.scrollTop-v.current;(c.current.bottom<-.5&&t<-1||c.current.top<-.5&&t>1)&&r.flushSync((()=>f((e=>e+t))))}requestAnimationFrame((()=>{v.current=e.scrollTop}))}}}}:{}),[i,c,o.floating,l,f])},e.useInteractions=function(e){void 0===e&&(e=[]);const t=e,n=u.useCallback((t=>St(t,e,"reference")),t),r=u.useCallback((t=>St(t,e,"floating")),t),o=u.useCallback((t=>St(t,e,"item")),e.map((e=>null==e?void 0:e.item)));return u.useMemo((()=>({getReferenceProps:n,getFloatingProps:r,getItemProps:o})),[n,r,o])},e.useListItem=ne,e.useListNavigation=function(e,t){const{open:n,onOpenChange:r,elements:{domReference:o,floating:i}}=e,{listRef:c,activeIndex:l,onNavigate:a=(()=>{}),enabled:f=!0,selectedIndex:d=null,allowEscape:v=!1,loop:p=!1,nested:g=!1,rtl:h=!1,virtual:w=!1,focusItemOnOpen:E="auto",focusItemOnHover:k=!0,openOnArrowKeyDown:C=!0,disabledIndices:T,orientation:P="vertical",cols:S=1,scrollItemIntoView:L=!0,virtualItemRef:D,itemSizes:F,dense:q=!1}=t,Z=be(),J=we(),ee=s(a),te=u.useRef(E),ne=u.useRef(null!=d?d:-1),re=u.useRef(null),oe=u.useRef(!0),ue=u.useRef(ee),ie=u.useRef(!!i),ce=u.useRef(!1),le=u.useRef(!1),se=xe(T),ae=xe(n),fe=xe(L),de=xe(i),ve=xe(d),[me,pe]=u.useState(),[ge,he]=u.useState(),ye=s((function(e,t,n){function r(e){w?(pe(e.id),null==J||J.events.emit("virtualfocus",e),D&&(D.current=e)):$(e,{preventScroll:!0,sync:!(!O()||!I())&&(Lt||ce.current)})}void 0===n&&(n=!1);const o=e.current[t.current];o&&r(o),requestAnimationFrame((()=>{const u=e.current[t.current]||o;if(!u)return;o||r(u);const i=fe.current;i&&Re&&(n||!oe.current)&&(null==u.scrollIntoView||u.scrollIntoView("boolean"==typeof i?{block:"nearest",inline:"nearest"}:i))}))}));Q((()=>{document.createElement("div").focus({get preventScroll(){return Lt=!0,!1}})}),[]),Q((()=>{f&&(n&&i?te.current&&null!=d&&(le.current=!0,ne.current=d,ee(d)):ie.current&&(ne.current=-1,ue.current(null)))}),[f,n,i,d,ee]),Q((()=>{if(f&&n&&i)if(null==l){if(ce.current=!1,null!=ve.current)return;if(ie.current&&(ne.current=-1,ye(c,ne)),!ie.current&&te.current&&(null!=re.current||!0===te.current&&null==re.current)){let e=0;const t=()=>{if(null==c.current[0]){if(e<2){(e?requestAnimationFrame:queueMicrotask)(t)}e++}else ne.current=null==re.current||Dt(re.current,P,h)||g?B(c,se.current):W(c,se.current),re.current=null,ee(ne.current)};t()}}else _(c,l)||(ne.current=l,ye(c,ne,le.current),le.current=!1)}),[f,n,i,l,ve,g,c,P,h,ee,ye,se]),Q((()=>{var e;if(!f||i||!J||w||!ie.current)return;const t=J.nodesRef.current,n=null==(e=t.find((e=>e.id===Z)))||null==(e=e.context)?void 0:e.elements.floating,r=y(M(i)),o=t.some((e=>e.context&&b(e.context.elements.floating,r)));n&&!o&&oe.current&&n.focus({preventScroll:!0})}),[f,i,J,Z,w]),Q((()=>{if(f&&J&&w&&!Z)return J.events.on("virtualfocus",e),()=>{J.events.off("virtualfocus",e)};function e(e){he(e.id),D&&(D.current=e)}}),[f,J,w,Z,D]),Q((()=>{ue.current=ee,ie.current=!!i})),Q((()=>{n||(re.current=null)}),[n]);const Ee=null!=l,Re=u.useMemo((()=>{function e(e){if(!n)return;const t=c.current.indexOf(e);-1!==t&&ee(t)}return{onFocus(t){let{currentTarget:n}=t;e(n)},onClick:e=>{let{currentTarget:t}=e;return t.focus({preventScroll:!0})},...k&&{onMouseMove(t){let{currentTarget:n}=t;e(n)},onPointerLeave(e){let{pointerType:t}=e;oe.current&&"touch"!==t&&(ne.current=-1,ye(c,ne),ee(null),w||$(de.current,{preventScroll:!0}))}}}}),[n,de,ye,k,c,ee,w]);return u.useMemo((()=>{if(!f)return{};const e=se.current;function t(t){if(oe.current=!1,ce.current=!0,!ae.current&&t.currentTarget===de.current)return;if(g&&Ft(t.key,P,h))return A(t),r(!1,t.nativeEvent,"list-navigation"),void(m(o)&&!w&&o.focus());const u=ne.current,i=B(c,e),l=W(c,e);if("Home"===t.key&&(A(t),ne.current=i,ee(ne.current)),"End"===t.key&&(A(t),ne.current=l,ee(ne.current)),S>1){const n=F||Array.from({length:c.current.length},(()=>({width:1,height:1}))),r=X(n,S,q),o=r.findIndex((t=>null!=t&&!G(c.current,t,e))),u=r.reduce(((t,n,r)=>null==n||G(c.current,n,e)?t:r),-1);if(ne.current=r[z({current:r.map((e=>null!=e?c.current[e]:null))},{event:t,orientation:P,loop:p,cols:S,disabledIndices:V([...e||c.current.map(((e,t)=>G(c.current,t)?t:void 0)),void 0],r),minIndex:o,maxIndex:u,prevIndex:Y(ne.current>l?i:ne.current,n,r,S,t.key===j?"bl":t.key===H?"tr":"tl"),stopEvent:!0})],ee(ne.current),"both"===P)return}if(Nt(t.key,P)){if(A(t),n&&!w&&y(t.currentTarget.ownerDocument)===t.currentTarget)return ne.current=Dt(t.key,P,h)?i:l,void ee(ne.current);Dt(t.key,P,h)?ne.current=p?u>=l?v&&u!==c.current.length?-1:i:U(c,{startingIndex:u,disabledIndices:e}):Math.min(l,U(c,{startingIndex:u,disabledIndices:e})):ne.current=p?u<=i?v&&-1!==u?c.current.length:l:U(c,{startingIndex:u,decrement:!0,disabledIndices:e}):Math.max(i,U(c,{startingIndex:u,decrement:!0,disabledIndices:e})),_(c,ne.current)?ee(null):ee(ne.current)}}function u(e){"auto"===E&&x(e.nativeEvent)&&(te.current=!0)}const i=w&&n&&Ee&&{"aria-activedescendant":ge||me},l=c.current.find((e=>(null==e?void 0:e.id)===me));return{reference:{...i,onKeyDown(o){oe.current=!1;const u=0===o.key.indexOf("Arrow"),i=function(e,t,n){return At(t,n?e===K:e===H,e===j)}(o.key,P,h),s=Ft(o.key,P,h),a=Nt(o.key,P),f=(g?i:a)||"Enter"===o.key||""===o.key.trim();if(w&&n){const e=null==J?void 0:J.nodesRef.current.find((e=>null==e.parentId)),n=J&&e?function(e,t){let n,r=-1;return function t(o,u){u>r&&(n=o,r=u),Ye(e,o).forEach((e=>{t(e.id,u+1)}))}(t,0),e.find((e=>e.id===n))}(J.nodesRef.current,e.id):null;if(u&&n&&D){const e=new KeyboardEvent("keydown",{key:o.key,bubbles:!0});if(i||s){var v,m;const t=(null==(v=n.context)?void 0:v.elements.domReference)===o.currentTarget,r=s&&!t?null==(m=n.context)?void 0:m.elements.domReference:i?l:null;r&&(A(o),r.dispatchEvent(e),he(void 0))}var p;if(a&&n.context)if(n.context.open&&n.parentId&&o.currentTarget!==n.context.elements.domReference)return A(o),void(null==(p=n.context.elements.domReference)||p.dispatchEvent(e))}return t(o)}(n||C||!u)&&(f&&(re.current=g&&a?null:o.key),g?i&&(A(o),n?(ne.current=B(c,e),ee(ne.current)):r(!0,o.nativeEvent,"list-navigation")):a&&(null!=d&&(ne.current=d),A(o),!n&&C?r(!0,o.nativeEvent,"list-navigation"):t(o),n&&ee(ne.current)))},onFocus(){n&&!w&&ee(null)},onPointerDown:function(e){te.current=E,"auto"===E&&R(e.nativeEvent)&&(te.current=!0)},onMouseDown:u,onClick:u},floating:{"aria-orientation":"both"===P?void 0:P,...!N(o)&&i,onKeyDown:t,onPointerMove(){oe.current=!0}},item:Re}}),[o,de,me,ge,se,ae,c,f,P,h,w,n,Ee,g,d,C,v,S,p,E,ee,r,Re,J,D,F,q])},e.useMergeRefs=i,e.useRole=function(e,t){var n;void 0===t&&(t={});const{open:r,floatingId:o}=e,{enabled:i=!0,role:c="dialog"}=t,l=null!=(n=jt.get(c))?n:c,s=me(),a=null!=be();return u.useMemo((()=>{if(!i)return{};const e={id:o,...l&&{role:l}};return"tooltip"===l||"label"===c?{reference:{["aria-"+("label"===c?"labelledby":"describedby")]:r?o:void 0},floating:e}:{reference:{"aria-expanded":r?"true":"false","aria-haspopup":"alertdialog"===l?"dialog":l,"aria-controls":r?o:void 0,..."listbox"===l&&{role:"combobox"},..."menu"===l&&{id:s},..."menu"===l&&a&&{role:"menuitem"},..."select"===c&&{"aria-autocomplete":"none"},..."combobox"===c&&{"aria-autocomplete":"list"}},floating:{...e,..."menu"===l&&{"aria-labelledby":s}},item(e){let{active:t,selected:n}=e;const r={role:"option",...t&&{id:o+"-option"}};switch(c){case"select":return{...r,"aria-selected":t&&n};case"combobox":return{...r,...t&&{"aria-selected":!0}}}return{}}}}),[i,c,l,r,o,s,a])},e.useTransitionStatus=qt,e.useTransitionStyles=function(e,t){void 0===t&&(t={});const{initial:n={opacity:0},open:r,close:o,common:i,duration:c=250}=t,l=e.placement,s=l.split("-")[0],a=u.useMemo((()=>({side:s,placement:l})),[s,l]),f="number"==typeof c,d=(f?c:c.open)||0,v=(f?c:c.close)||0,[m,p]=u.useState((()=>({...Ht(i,a),...Ht(n,a)}))),{isMounted:g,status:h}=qt(e,{duration:c}),y=xe(n),b=xe(r),w=xe(o),E=xe(i);return Q((()=>{const e=Ht(y.current,a),t=Ht(w.current,a),n=Ht(E.current,a),r=Ht(b.current,a)||Object.keys(e).reduce(((e,t)=>(e[t]="",e)),{});if("initial"===h&&p((t=>({transitionProperty:t.transitionProperty,...n,...e}))),"open"===h&&p({transitionProperty:Object.keys(r).map(Kt).join(","),transitionDuration:d+"ms",...n,...r}),"close"===h){const r=t||e;p({transitionProperty:Object.keys(r).map(Kt).join(","),transitionDuration:v+"ms",...n,...r})}}),[v,w,y,b,E,d,h,a]),{isMounted:g,styles:m}},e.useTypeahead=function(e,t){var n;const{open:r,dataRef:o}=e,{listRef:i,activeIndex:c,onMatch:l,onTypingChange:a,enabled:f=!0,findMatch:d=null,resetMs:v=750,ignoreKeys:m=[],selectedIndex:p=null}=t,g=u.useRef(),h=u.useRef(""),y=u.useRef(null!=(n=null!=p?p:c)?n:-1),b=u.useRef(null),w=s(l),E=s(a),x=xe(d),R=xe(m);return Q((()=>{r&&(clearTimeout(g.current),b.current=null,h.current="")}),[r]),Q((()=>{var e;r&&""===h.current&&(y.current=null!=(e=null!=p?p:c)?e:-1)}),[r,p,c]),u.useMemo((()=>{if(!f)return{};function e(e){e?o.current.typing||(o.current.typing=e,E(e)):o.current.typing&&(o.current.typing=e,E(e))}function t(e,t,n){const r=x.current?x.current(t,n):t.find((e=>0===(null==e?void 0:e.toLocaleLowerCase().indexOf(n.toLocaleLowerCase()))));return r?e.indexOf(r):-1}function n(n){const o=i.current;if(h.current.length>0&&" "!==h.current[0]&&(-1===t(o,o,h.current)?e(!1):" "===n.key&&A(n)),null==o||R.current.includes(n.key)||1!==n.key.length||n.ctrlKey||n.metaKey||n.altKey)return;r&&" "!==n.key&&(A(n),e(!0));o.every((e=>{var t,n;return!e||(null==(t=e[0])?void 0:t.toLocaleLowerCase())!==(null==(n=e[1])?void 0:n.toLocaleLowerCase())}))&&h.current===n.key&&(h.current="",y.current=b.current),h.current+=n.key,clearTimeout(g.current),g.current=setTimeout((()=>{h.current="",y.current=b.current,e(!1)}),v);const u=y.current,c=t(o,[...o.slice((u||0)+1),...o.slice(0,(u||0)+1)],h.current);-1!==c?(w(c),b.current=c):" "!==n.key&&(h.current="",e(!1))}return{reference:{onKeyDown:n},floating:{onKeyDown:n,onKeyUp(t){" "===t.key&&e(!1)}}}}),[f,r,o,i,v,R,x,w,E])}}));
+var ke=["input:not([inert])","select:not([inert])","textarea:not([inert])","a[href]:not([inert])","button:not([inert])","[tabindex]:not(slot):not([inert])","audio[controls]:not([inert])","video[controls]:not([inert])",'[contenteditable]:not([contenteditable="false"]):not([inert])',"details>summary:first-of-type:not([inert])","details:not([inert])"].join(","),Oe="undefined"==typeof Element,Ce=Oe?function(){}:Element.prototype.matches||Element.prototype.msMatchesSelector||Element.prototype.webkitMatchesSelector,Me=!Oe&&Element.prototype.getRootNode?function(e){var t;return null==e||null===(t=e.getRootNode)||void 0===t?void 0:t.call(e)}:function(e){return null==e?void 0:e.ownerDocument},Te=function e(t,n){var r;void 0===n&&(n=!0);var o=null==t||null===(r=t.getAttribute)||void 0===r?void 0:r.call(t,"inert");return""===o||"true"===o||n&&t&&e(t.parentNode)},Se=function e(t,n,r){for(var o=[],u=Array.from(t);u.length;){var i=u.shift();if(!Te(i,!1))if("SLOT"===i.tagName){var l=i.assignedElements(),c=e(l.length?l:i.children,!0,r);r.flatten?o.push.apply(o,c):o.push({scopeParent:i,candidates:c})}else{Ce.call(i,ke)&&r.filter(i)&&(n||!t.includes(i))&&o.push(i);var s=i.shadowRoot||"function"==typeof r.getShadowRoot&&r.getShadowRoot(i),a=!Te(s,!1)&&(!r.shadowRootFilter||r.shadowRootFilter(i));if(s&&a){var f=e(!0===s?i.children:s.children,!0,r);r.flatten?o.push.apply(o,f):o.push({scopeParent:i,candidates:f})}else u.unshift.apply(u,i.children)}}return o},Pe=function(e){return!isNaN(parseInt(e.getAttribute("tabindex"),10))},Le=function(e){if(!e)throw new Error("No node provided");return e.tabIndex<0&&(/^(AUDIO|VIDEO|DETAILS)$/.test(e.tagName)||function(e){var t,n=null==e||null===(t=e.getAttribute)||void 0===t?void 0:t.call(e,"contenteditable");return""===n||"true"===n}(e))&&!Pe(e)?0:e.tabIndex},Ae=function(e,t){return e.tabIndex===t.tabIndex?e.documentOrder-t.documentOrder:e.tabIndex-t.tabIndex},De=function(e){return"INPUT"===e.tagName},Ne=function(e){return function(e){return De(e)&&"radio"===e.type}(e)&&!function(e){if(!e.name)return!0;var t,n=e.form||Me(e),r=function(e){return n.querySelectorAll('input[type="radio"][name="'+e+'"]')};if("undefined"!=typeof window&&void 0!==window.CSS&&"function"==typeof window.CSS.escape)t=r(window.CSS.escape(e.name));else try{t=r(e.name)}catch(e){return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s",e.message),!1}var o=function(e,t){for(var n=0;n<e.length;n++)if(e[n].checked&&e[n].form===t)return e[n]}(t,e.form);return!o||o===e}(e)},Fe=function(e){var t=e.getBoundingClientRect(),n=t.width,r=t.height;return 0===n&&0===r},je=function(e,t){var n=t.displayCheck,r=t.getShadowRoot;if("hidden"===getComputedStyle(e).visibility)return!0;var o=Ce.call(e,"details>summary:first-of-type")?e.parentElement:e;if(Ce.call(o,"details:not([open]) *"))return!0;if(n&&"full"!==n&&"legacy-full"!==n){if("non-zero-area"===n)return Fe(e)}else{if("function"==typeof r){for(var u=e;e;){var i=e.parentElement,l=Me(e);if(i&&!i.shadowRoot&&!0===r(i))return Fe(e);e=e.assignedSlot?e.assignedSlot:i||l===e.ownerDocument?i:l.host}e=u}if(function(e){var t,n,r,o,u=e&&Me(e),i=null===(t=u)||void 0===t?void 0:t.host,l=!1;if(u&&u!==e)for(l=!!(null!==(n=i)&&void 0!==n&&null!==(r=n.ownerDocument)&&void 0!==r&&r.contains(i)||null!=e&&null!==(o=e.ownerDocument)&&void 0!==o&&o.contains(e));!l&&i;){var c,s,a;l=!(null===(s=i=null===(c=u=Me(i))||void 0===c?void 0:c.host)||void 0===s||null===(a=s.ownerDocument)||void 0===a||!a.contains(i))}return l}(e))return!e.getClientRects().length;if("legacy-full"!==n)return!0}return!1},Ke=function(e,t){return!(t.disabled||Te(t)||function(e){return De(e)&&"hidden"===e.type}(t)||je(t,e)||function(e){return"DETAILS"===e.tagName&&Array.prototype.slice.apply(e.children).some((function(e){return"SUMMARY"===e.tagName}))}(t)||function(e){if(/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(e.tagName))for(var t=e.parentElement;t;){if("FIELDSET"===t.tagName&&t.disabled){for(var n=0;n<t.children.length;n++){var r=t.children.item(n);if("LEGEND"===r.tagName)return!!Ce.call(t,"fieldset[disabled] *")||!r.contains(e)}return!0}t=t.parentElement}return!1}(t))},He=function(e,t){return!(Ne(t)||Le(t)<0||!Ke(e,t))},qe=function(e){var t=parseInt(e.getAttribute("tabindex"),10);return!!(isNaN(t)||t>=0)},_e=function e(t){var n=[],r=[];return t.forEach((function(t,o){var u=!!t.scopeParent,i=u?t.scopeParent:t,l=function(e,t){var n=Le(e);return n<0&&t&&!Pe(e)?0:n}(i,u),c=u?e(t.candidates):i;0===l?u?n.push.apply(n,c):n.push(i):r.push({documentOrder:o,tabIndex:l,item:t,isScope:u,content:c})})),r.sort(Ae).reduce((function(e,t){return t.isScope?e.push.apply(e,t.content):e.push(t.content),e}),[]).concat(n)},Be=function(e,t){var n;return n=(t=t||{}).getShadowRoot?Se([e],t.includeContainer,{filter:He.bind(null,t),flatten:!1,getShadowRoot:t.getShadowRoot,shadowRootFilter:qe}):function(e,t,n){if(Te(e))return[];var r=Array.prototype.slice.apply(e.querySelectorAll(ke));return t&&Ce.call(e,ke)&&r.unshift(e),r.filter(n)}(e,t.includeContainer,He.bind(null,t)),_e(n)};function We(e,t){let n=e.filter((e=>{var n;return e.parentId===t&&(null==(n=e.context)?void 0:n.open)})),r=n;for(;r.length;)r=e.filter((e=>{var t;return null==(t=r)?void 0:t.some((t=>{var n;return e.parentId===t.id&&(null==(n=e.context)?void 0:n.open)}))})),n=n.concat(r);return n}let Ue=new WeakMap,ze=new WeakSet,Xe={},Ye=0;const Ve=e=>e&&(e.host||Ve(e.parentNode)),Ge=(e,t)=>t.map((t=>{if(e.contains(t))return t;const n=Ve(t);return e.contains(n)?n:null})).filter((e=>null!=e));function Ze(e,t,n){void 0===t&&(t=!1),void 0===n&&(n=!1);const r=C(e[0]).body;return function(e,t,n,r){const o="data-floating-ui-inert",u=r?"inert":n?"aria-hidden":null,i=Ge(t,e),l=new Set,c=new Set(i),s=[];Xe[o]||(Xe[o]=new WeakMap);const a=Xe[o];return i.forEach((function e(t){t&&!l.has(t)&&(l.add(t),t.parentNode&&e(t.parentNode))})),function e(t){t&&!c.has(t)&&Array.prototype.forEach.call(t.children,(t=>{if(l.has(t))e(t);else{const e=u?t.getAttribute(u):null,n=null!==e&&"false"!==e,r=(Ue.get(t)||0)+1,i=(a.get(t)||0)+1;Ue.set(t,r),a.set(t,i),s.push(t),1===r&&n&&ze.add(t),1===i&&t.setAttribute(o,""),!n&&u&&t.setAttribute(u,"true")}}))}(t),l.clear(),Ye++,()=>{s.forEach((e=>{const t=(Ue.get(e)||0)-1,n=(a.get(e)||0)-1;Ue.set(e,t),a.set(e,n),t||(!ze.has(e)&&u&&e.removeAttribute(u),ze.delete(e)),n||e.removeAttribute(o)})),Ye--,Ye||(Ue=new WeakMap,Ue=new WeakMap,ze=new WeakSet,Xe={})}}(e.concat(Array.from(r.querySelectorAll("[aria-live]"))),r,t,n)}const $e=()=>({getShadowRoot:!0,displayCheck:"function"==typeof ResizeObserver&&ResizeObserver.toString().includes("[native code]")?"full":"none"});function Qe(e,t){const n=Be(e,$e());"prev"===t&&n.reverse();const r=n.indexOf(h(C(e)));return n.slice(r+1)[0]}function Je(){return Qe(document.body,"next")}function et(){return Qe(document.body,"prev")}function tt(e,t){const n=t||e.currentTarget,r=e.relatedTarget;return!r||!y(n,r)}function nt(e){Be(e,$e()).forEach((e=>{e.dataset.tabindex=e.getAttribute("tabindex")||"",e.setAttribute("tabindex","-1")}))}function rt(e){e.querySelectorAll("[data-tabindex]").forEach((e=>{const t=e.dataset.tabindex;delete e.dataset.tabindex,t?e.setAttribute("tabindex",t):e.removeAttribute("tabindex")}))}const ot={border:0,clip:"rect(0 0 0 0)",height:"1px",margin:"-1px",overflow:"hidden",padding:0,position:"fixed",whiteSpace:"nowrap",width:"1px",top:0,left:0};function ut(e){"Tab"===e.key&&(e.target,clearTimeout(undefined))}const it=u.forwardRef((function(e,t){const[n,r]=u.useState();Z((()=>(R()&&r("button"),document.addEventListener("keydown",ut),()=>{document.removeEventListener("keydown",ut)})),[]);const o={ref:t,tabIndex:0,role:n,"aria-hidden":!n||void 0,[be("focus-guard")]:"",style:ot};return u.createElement("span",ce({},e,o))})),lt=u.createContext(null);function ct(e){let{id:t,root:n}=void 0===e?{}:e;const[r,o]=u.useState(null),i=de(),l=st(),c=u.useMemo((()=>({id:t,root:n,portalContext:l,uniqueId:i})),[t,n,l,i]),s=u.useRef();return Z((()=>()=>{null==r||r.remove()}),[r,c]),Z((()=>{if(s.current===c)return;s.current=c;const{id:e,root:t,portalContext:n,uniqueId:r}=c,u=e?document.getElementById(e):null,i=be("portal");if(u){const e=document.createElement("div");e.id=r,e.setAttribute(i,""),u.appendChild(e),o(e)}else{let u=t||(null==n?void 0:n.portalNode);u&&!d(u)&&(u=u.current),u=u||document.body;let l=null;e&&(l=document.createElement("div"),l.id=e,u.appendChild(l));const c=document.createElement("div");c.id=r,c.setAttribute(i,""),u=l||u,u.appendChild(c),o(c)}}),[c]),r}const st=()=>u.useContext(lt),at=20;let ft=[];function dt(e){ft=ft.filter((e=>e.isConnected)),e&&"body"!==s(e)&&(ft.push(e),ft.length>at&&(ft=ft.slice(-at)))}function vt(){return ft.slice().reverse().find((e=>e.isConnected))}const mt=u.forwardRef((function(e,t){return u.createElement("button",ce({},e,{type:"button",ref:t,tabIndex:-1,style:ot}))}));const pt=new Set,gt=u.forwardRef((function(e,t){let{lockScroll:n=!1,...r}=e;const o=de();return Z((()=>{if(!n)return;pt.add(o);const e=/iP(hone|ad|od)|iOS/.test(b()),t=document.body.style,r=Math.round(document.documentElement.getBoundingClientRect().left)+document.documentElement.scrollLeft?"paddingLeft":"paddingRight",u=window.innerWidth-document.documentElement.clientWidth,i=t.left?parseFloat(t.left):window.pageXOffset,l=t.top?parseFloat(t.top):window.pageYOffset;if(t.overflow="hidden",u&&(t[r]=u+"px"),e){var c,s;const e=(null==(c=window.visualViewport)?void 0:c.offsetLeft)||0,n=(null==(s=window.visualViewport)?void 0:s.offsetTop)||0;Object.assign(t,{position:"fixed",top:-(l-Math.floor(n))+"px",left:-(i-Math.floor(e))+"px",right:"0"})}return()=>{pt.delete(o),0===pt.size&&(Object.assign(t,{overflow:"",[r]:""}),e&&(Object.assign(t,{position:"",top:"",left:"",right:""}),window.scrollTo(i,l)))}}),[o,n]),u.createElement("div",ce({ref:t},r,{style:{position:"fixed",overflow:"auto",top:0,right:0,bottom:0,left:0,...r.style}}))}));function ht(e){return v(e.target)&&"BUTTON"===e.target.tagName}function yt(e){return P(e)}function bt(e){return null!=e&&null!=e.clientX}const Et={pointerdown:"onPointerDown",mousedown:"onMouseDown",click:"onClick"},wt={pointerdown:"onPointerDownCapture",mousedown:"onMouseDownCapture",click:"onClickCapture"},xt=e=>{var t,n;return{escapeKey:"boolean"==typeof e?e:null!=(t=null==e?void 0:e.escapeKey)&&t,outsidePress:"boolean"==typeof e?e:null==(n=null==e?void 0:e.outsidePress)||n}};const Rt="active",It="selected";function kt(e,t,n){const r=new Map,o="item"===n;let u=e;if(o&&e){const{[Rt]:t,[It]:n,...r}=e;u=r}return{..."floating"===n&&{tabIndex:-1},...u,...t.map((t=>{const r=t?t[n]:null;return"function"==typeof r?e?r(e):null:r})).concat(e).reduce(((e,t)=>t?(Object.entries(t).forEach((t=>{let[n,u]=t;var i;o&&[Rt,It].includes(n)||(0===n.indexOf("on")?(r.has(n)||r.set(n,[]),"function"==typeof u&&(null==(i=r.get(n))||i.push(u),e[n]=function(){for(var e,t=arguments.length,o=new Array(t),u=0;u<t;u++)o[u]=arguments[u];return null==(e=r.get(n))?void 0:e.map((e=>e(...o))).find((e=>void 0!==e))})):e[n]=u)})),e):e),{})}}let Ot=!1;function Ct(e,t,n){switch(e){case"vertical":return t;case"horizontal":return n;default:return t||n}}function Mt(e,t){return Ct(t,e===N||e===F,e===j||e===K)}function Tt(e,t,n){return Ct(t,e===F,n?e===j:e===K)||"Enter"===e||" "===e||""===e}function St(e,t,n){return Ct(t,n?e===K:e===j,e===N)}const Pt=new Map([["select","listbox"],["combobox","listbox"],["label",!1]]);const Lt=e=>e.replace(/[A-Z]+(?![a-z])|[A-Z]/g,((e,t)=>(t?"-":"")+e.toLowerCase()));function At(e,t){return"function"==typeof e?e(t):e}function Dt(e,t){void 0===t&&(t={});const{open:n,elements:{floating:r}}=e,{duration:o=250}=t,i=("number"==typeof o?o:o.close)||0,[l,c]=u.useState(!1),[s,a]=u.useState("unmounted"),f=function(e,t){const[n,r]=u.useState(e);return e&&!n&&r(!0),u.useEffect((()=>{if(!e){const e=setTimeout((()=>r(!1)),t);return()=>clearTimeout(e)}}),[e,t]),n}(n,i);return Z((()=>{l&&!f&&a("unmounted")}),[l,f]),Z((()=>{if(r){if(n){a("initial");const e=requestAnimationFrame((()=>{a("open")}));return()=>{cancelAnimationFrame(e)}}c(!0),a("close")}}),[n,r]),{isMounted:f,status:s}}function Nt(e,t){return{...e,rects:{...e.rects,floating:{...e.rects.floating,height:t}}}}function Ft(e,t){const[n,r]=e;let o=!1;const u=t.length;for(let e=0,i=u-1;e<u;i=e++){const[u,l]=t[e]||[0,0],[c,s]=t[i]||[0,0];l>=r!=s>=r&&n<=(c-u)*(r-l)/(s-l)+u&&(o=!o)}return o}Object.defineProperty(e,"arrow",{enumerable:!0,get:function(){return n.arrow}}),Object.defineProperty(e,"autoPlacement",{enumerable:!0,get:function(){return n.autoPlacement}}),Object.defineProperty(e,"autoUpdate",{enumerable:!0,get:function(){return n.autoUpdate}}),Object.defineProperty(e,"computePosition",{enumerable:!0,get:function(){return n.computePosition}}),Object.defineProperty(e,"detectOverflow",{enumerable:!0,get:function(){return n.detectOverflow}}),Object.defineProperty(e,"flip",{enumerable:!0,get:function(){return n.flip}}),Object.defineProperty(e,"getOverflowAncestors",{enumerable:!0,get:function(){return n.getOverflowAncestors}}),Object.defineProperty(e,"hide",{enumerable:!0,get:function(){return n.hide}}),Object.defineProperty(e,"inline",{enumerable:!0,get:function(){return n.inline}}),Object.defineProperty(e,"limitShift",{enumerable:!0,get:function(){return n.limitShift}}),Object.defineProperty(e,"offset",{enumerable:!0,get:function(){return n.offset}}),Object.defineProperty(e,"platform",{enumerable:!0,get:function(){return n.platform}}),Object.defineProperty(e,"shift",{enumerable:!0,get:function(){return n.shift}}),Object.defineProperty(e,"size",{enumerable:!0,get:function(){return n.size}}),e.Composite=ie,e.CompositeItem=le,e.FloatingArrow=ve,e.FloatingDelayGroup=e=>{let{children:t,delay:n,timeoutMs:r=0}=e;const[o,i]=u.useReducer(((e,t)=>({...e,...t})),{delay:n,timeoutMs:r,initialDelay:n,currentId:null,isInstantPhase:!1}),l=u.useRef(null),c=u.useCallback((e=>{i({currentId:e})}),[]);return Z((()=>{o.currentId?null===l.current?l.current=o.currentId:i({isInstantPhase:!0}):(i({isInstantPhase:!1}),l.current=null)}),[o.currentId]),u.createElement(Re.Provider,{value:u.useMemo((()=>({...o,setState:i,setCurrentId:c})),[o,c])},t)},e.FloatingFocusManager=function(e){const{context:t,children:n,disabled:r=!1,order:o=["content"],guards:i=!0,initialFocus:l=0,returnFocus:c=!0,modal:s=!0,visuallyHiddenDismiss:a=!1,closeOnFocusOut:f=!0}=e,{open:d,refs:m,nodeId:p,onOpenChange:g,events:b,dataRef:E,elements:{domReference:R,floating:I}}=t,k="number"==typeof l&&l<0,O=A(R)&&k,M="undefined"==typeof HTMLElement||!("inert"in HTMLElement.prototype)||i,S=Ee(o),P=Ee(l),D=Ee(c),N=ye(),F=st(),j=u.useRef(null),K=u.useRef(null),H=u.useRef(!1),q=u.useRef(!1),_=null!=F,B=u.useCallback((function(e){return void 0===e&&(e=I),e?Be(e,$e()):[]}),[I]),W=u.useCallback((e=>{const t=B(e);return S.current.map((e=>R&&"reference"===e?R:I&&"floating"===e?I:t)).filter(Boolean).flat()}),[R,I,S,B]);function U(e){return!r&&a&&s?u.createElement(mt,{ref:"start"===e?j:K,onClick:e=>g(!1,e.nativeEvent)},"string"==typeof a?a:"Dismiss"):null}u.useEffect((()=>{if(r||!s)return;function e(e){if("Tab"===e.key){y(I,h(C(I)))&&0===B().length&&!O&&L(e);const t=W(),n=T(e);"reference"===S.current[0]&&n===R&&(L(e),e.shiftKey?G(t[t.length-1]):G(t[1])),"floating"===S.current[1]&&n===I&&e.shiftKey&&(L(e),G(t[0]))}}const t=C(I);return t.addEventListener("keydown",e),()=>{t.removeEventListener("keydown",e)}}),[r,R,I,s,S,O,B,W]),u.useEffect((()=>{if(!r&&f)return I&&v(R)?(R.addEventListener("focusout",t),R.addEventListener("pointerdown",e),!s&&I.addEventListener("focusout",t),()=>{R.removeEventListener("focusout",t),R.removeEventListener("pointerdown",e),!s&&I.removeEventListener("focusout",t)}):void 0;function e(){q.current=!0,setTimeout((()=>{q.current=!1}))}function t(e){const t=e.relatedTarget;queueMicrotask((()=>{const n=!(y(R,t)||y(I,t)||y(t,I)||y(null==F?void 0:F.portalNode,t)||null!=t&&t.hasAttribute(be("focus-guard"))||N&&(We(N.nodesRef.current,p).find((e=>{var n,r;return y(null==(n=e.context)?void 0:n.elements.floating,t)||y(null==(r=e.context)?void 0:r.elements.domReference,t)}))||function(e,t){var n;let r=[],o=null==(n=e.find((e=>e.id===t)))?void 0:n.parentId;for(;o;){const t=e.find((e=>e.id===o));o=null==t?void 0:t.parentId,t&&(r=r.concat(t))}return r}(N.nodesRef.current,p).find((e=>{var n,r;return(null==(n=e.context)?void 0:n.elements.floating)===t||(null==(r=e.context)?void 0:r.elements.domReference)===t}))));t&&n&&!q.current&&t!==vt()&&(H.current=!0,g(!1,e))}))}}),[r,R,I,s,p,N,F,g,f]),u.useEffect((()=>{var e;if(r)return;const t=Array.from((null==F||null==(e=F.portalNode)?void 0:e.querySelectorAll("["+be("portal")+"]"))||[]);if(I){const e=[I,...t,j.current,K.current,S.current.includes("reference")||O?R:null].filter((e=>null!=e)),n=s||O?Ze(e,M,!M):Ze(e);return()=>{n()}}}),[r,R,I,s,S,F,O,M]),Z((()=>{if(r||!I)return;const e=h(C(I));queueMicrotask((()=>{const t=W(I),n=P.current,r=("number"==typeof n?t[n]:n.current)||I,o=y(I,e);k||o||!d||G(r,{preventScroll:r===I})}))}),[r,d,I,k,W,P]),Z((()=>{if(r||!I)return;let e=!1;const t=C(I),n=h(t),o=E.current;function u(t){let{reason:n,event:r,nested:o}=t;"escape-key"===n&&m.domReference.current&&dt(m.domReference.current),"hover"===n&&"mouseleave"===r.type&&(H.current=!0),"outside-press"===n&&(o?(H.current=!1,e=!0):H.current=!(w(r)||x(r)))}return dt(n),b.on("openchange",u),()=>{b.off("openchange",u);const n=h(t),r=y(I,n)||N&&We(N.nodesRef.current,p).some((e=>{var t;return y(null==(t=e.context)?void 0:t.elements.floating,n)}));(r||o.openEvent&&["click","mousedown"].includes(o.openEvent.type))&&m.domReference.current&&dt(m.domReference.current);const i=vt();D.current&&!H.current&&v(i)&&(i===n||n===t.body||r)&&G(i,{cancelPrevious:!1,preventScroll:e})}}),[r,I,D,E,m,b,N,p]),Z((()=>{if(!r&&F)return F.setFocusManagerState({modal:s,closeOnFocusOut:f,open:d,onOpenChange:g,refs:m}),()=>{F.setFocusManagerState(null)}}),[r,F,s,d,g,m,f]),Z((()=>{if(r||!I||"function"!=typeof MutationObserver||k)return;const e=()=>{const e=I.getAttribute("tabindex");S.current.includes("floating")||h(C(I))!==m.domReference.current&&0===B().length?"0"!==e&&I.setAttribute("tabindex","0"):"-1"!==e&&I.setAttribute("tabindex","-1")};e();const t=new MutationObserver(e);return t.observe(I,{childList:!0,subtree:!0,attributes:!0}),()=>{t.disconnect()}}),[r,I,m,S,B,k]);const z=!r&&M&&(_||s);return u.createElement(u.Fragment,null,z&&u.createElement(it,{"data-type":"inside",ref:null==F?void 0:F.beforeInsideRef,onFocus:e=>{if(s){const e=W();G("reference"===o[0]?e[0]:e[e.length-1])}else if(null!=F&&F.preserveTabOrder&&F.portalNode)if(H.current=!1,tt(e,F.portalNode)){const e=Je()||R;null==e||e.focus()}else{var t;null==(t=F.beforeOutsideRef.current)||t.focus()}}}),!O&&U("start"),n,U("end"),z&&u.createElement(it,{"data-type":"inside",ref:null==F?void 0:F.afterInsideRef,onFocus:e=>{if(s)G(W()[0]);else if(null!=F&&F.preserveTabOrder&&F.portalNode)if(f&&(H.current=!0),tt(e,F.portalNode)){const e=et()||R;null==e||e.focus()}else{var t;null==(t=F.afterOutsideRef.current)||t.focus()}}}))},e.FloatingList=J,e.FloatingNode=function(e){let{children:t,id:n}=e;const r=he();return u.createElement(pe.Provider,{value:u.useMemo((()=>({id:n,parentId:r})),[n,r])},t)},e.FloatingOverlay=gt,e.FloatingPortal=function(e){let{children:t,id:n,root:o=null,preserveTabOrder:i=!0}=e;const l=ct({id:n,root:o}),[c,s]=u.useState(null),a=u.useRef(null),f=u.useRef(null),d=u.useRef(null),v=u.useRef(null),m=!!c&&!c.modal&&c.open&&i&&!(!o&&!l);return u.useEffect((()=>{if(l&&i&&(null==c||!c.modal))return l.addEventListener("focusin",e,!0),l.addEventListener("focusout",e,!0),()=>{l.removeEventListener("focusin",e,!0),l.removeEventListener("focusout",e,!0)};function e(e){if(l&&tt(e)){("focusin"===e.type?rt:nt)(l)}}}),[l,i,null==c?void 0:c.modal]),u.createElement(lt.Provider,{value:u.useMemo((()=>({preserveTabOrder:i,beforeOutsideRef:a,afterOutsideRef:f,beforeInsideRef:d,afterInsideRef:v,portalNode:l,setFocusManagerState:s})),[i,l])},m&&l&&u.createElement(it,{"data-type":"outside",ref:a,onFocus:e=>{if(tt(e,l)){var t;null==(t=d.current)||t.focus()}else{const e=et()||(null==c?void 0:c.refs.domReference.current);null==e||e.focus()}}}),m&&l&&u.createElement("span",{"aria-owns":l.id,style:ot}),l&&r.createPortal(t,l),m&&l&&u.createElement(it,{"data-type":"outside",ref:f,onFocus:e=>{if(tt(e,l)){var t;null==(t=v.current)||t.focus()}else{const t=Je()||(null==c?void 0:c.refs.domReference.current);null==t||t.focus(),(null==c?void 0:c.closeOnFocusOut)&&(null==c||c.onOpenChange(!1,e.nativeEvent))}}}))},e.FloatingTree=function(e){let{children:t}=e;const n=u.useRef([]),r=u.useCallback((e=>{n.current=[...n.current,e]}),[]),o=u.useCallback((e=>{n.current=n.current.filter((t=>t!==e))}),[]),i=u.useState((()=>me()))[0];return u.createElement(ge.Provider,{value:u.useMemo((()=>({nodesRef:n,addNode:r,removeNode:o,events:i})),[r,o,i])},t)},e.inner=e=>({name:"inner",options:e,async fn(t){const{listRef:o,overflowRef:u,onFallbackChange:i,offset:l=0,index:c=0,minItemsVisible:s=4,referenceOverflowThreshold:a=0,scrollRef:f,...d}=e,{rects:v,elements:{floating:m}}=t,p=o.current[c];if(!p)return{};const g={...t,...await n.offset(-p.offsetTop-m.clientTop-v.reference.height/2-p.offsetHeight/2-l).fn(t)},h=(null==f?void 0:f.current)||m,y=await n.detectOverflow(Nt(g,h.scrollHeight),d),b=await n.detectOverflow(g,{...d,elementContext:"reference"}),E=Math.max(0,y.top),w=g.y+E,x=Math.max(0,h.scrollHeight-E-Math.max(0,y.bottom));return h.style.maxHeight=x+"px",h.scrollTop=E,i&&(h.offsetHeight<p.offsetHeight*Math.min(s,o.current.length-1)-1||b.top>=-a||b.bottom>=-a?r.flushSync((()=>i(!0))):r.flushSync((()=>i(!1)))),u&&(u.current=await n.detectOverflow(Nt({...g,y:w},h.offsetHeight),d)),{y:w}}}),e.safePolygon=function(e){void 0===e&&(e={});const{buffer:t=.5,blockPointerEvents:n=!1,requireIntent:r=!0}=e;let o,u=!1,i=null,l=null,c=performance.now();const s=e=>{let{x:n,y:s,placement:a,elements:f,onClose:v,nodeId:m,tree:p}=e;return function(e){function g(){clearTimeout(o),v()}if(clearTimeout(o),!f.domReference||!f.floating||null==a||null==n||null==s)return;const{clientX:h,clientY:b}=e,E=[h,b],w=T(e),x="mouseleave"===e.type,R=y(f.floating,w),I=y(f.domReference,w),k=f.domReference.getBoundingClientRect(),O=f.floating.getBoundingClientRect(),C=a.split("-")[0],M=n>O.right-O.width/2,S=s>O.bottom-O.height/2,P=function(e,t){return e[0]>=t.x&&e[0]<=t.x+t.width&&e[1]>=t.y&&e[1]<=t.y+t.height}(E,k),L=O.width>k.width,A=O.height>k.height,D=(L?k:O).left,N=(L?k:O).right,F=(A?k:O).top,j=(A?k:O).bottom;if(R&&(u=!0,!x))return;if(I&&(u=!1),I&&!x)return void(u=!0);if(x&&d(e.relatedTarget)&&y(f.floating,e.relatedTarget))return;if(p&&We(p.nodesRef.current,m).some((e=>{let{context:t}=e;return null==t?void 0:t.open})))return;if("top"===C&&s>=k.bottom-1||"bottom"===C&&s<=k.top+1||"left"===C&&n>=k.right-1||"right"===C&&n<=k.left+1)return g();let K=[];switch(C){case"top":K=[[D,k.top+1],[D,O.bottom-1],[N,O.bottom-1],[N,k.top+1]];break;case"bottom":K=[[D,O.top+1],[D,k.bottom-1],[N,k.bottom-1],[N,O.top+1]];break;case"left":K=[[O.right-1,j],[O.right-1,F],[k.left+1,F],[k.left+1,j]];break;case"right":K=[[k.right-1,j],[k.right-1,F],[O.left+1,F],[O.left+1,j]]}if(!Ft([h,b],K)){if(u&&!P)return g();if(!x&&r){const t=function(e,t){const n=performance.now(),r=n-c;if(null===i||null===l||0===r)return i=e,l=t,c=n,null;const o=e-i,u=t-l,s=Math.sqrt(o*o+u*u);return i=e,l=t,c=n,s/r}(e.clientX,e.clientY);if(null!==t&&t<.1)return g()}Ft([h,b],function(e){let[n,r]=e;switch(C){case"top":return[[L?n+t/2:M?n+4*t:n-4*t,r+t+1],[L?n-t/2:M?n+4*t:n-4*t,r+t+1],...[[O.left,M||L?O.bottom-t:O.top],[O.right,M?L?O.bottom-t:O.top:O.bottom-t]]];case"bottom":return[[L?n+t/2:M?n+4*t:n-4*t,r-t],[L?n-t/2:M?n+4*t:n-4*t,r-t],...[[O.left,M||L?O.top+t:O.bottom],[O.right,M?L?O.top+t:O.bottom:O.top+t]]];case"left":{const e=[n+t+1,A?r+t/2:S?r+4*t:r-4*t],o=[n+t+1,A?r-t/2:S?r+4*t:r-4*t];return[...[[S||A?O.right-t:O.left,O.top],[S?A?O.right-t:O.left:O.right-t,O.bottom]],e,o]}case"right":return[[n-t,A?r+t/2:S?r+4*t:r-4*t],[n-t,A?r-t/2:S?r+4*t:r-4*t],...[[S||A?O.left+t:O.right,O.top],[S?A?O.left+t:O.right:O.left+t,O.bottom]]]}}([n,s]))?!u&&r&&(o=window.setTimeout(g,40)):g()}}};return s.__options={blockPointerEvents:n},s},e.useClick=function(e,t){void 0===t&&(t={});const{open:n,onOpenChange:r,dataRef:o,elements:{domReference:i}}=e,{enabled:l=!0,event:c="click",toggle:s=!0,ignoreMouse:a=!1,keyboardHandlers:f=!0}=t,d=u.useRef(),v=u.useRef(!1);return u.useMemo((()=>l?{reference:{onPointerDown(e){d.current=e.pointerType},onMouseDown(e){0===e.button&&(O(d.current,!0)&&a||"click"!==c&&(!n||!s||o.current.openEvent&&"mousedown"!==o.current.openEvent.type?(e.preventDefault(),r(!0,e.nativeEvent,"click")):r(!1,e.nativeEvent,"click")))},onClick(e){"mousedown"===c&&d.current?d.current=void 0:O(d.current,!0)&&a||(!n||!s||o.current.openEvent&&"click"!==o.current.openEvent.type?r(!0,e.nativeEvent,"click"):r(!1,e.nativeEvent,"click"))},onKeyDown(e){d.current=void 0,e.defaultPrevented||!f||ht(e)||(" "!==e.key||yt(i)||(e.preventDefault(),v.current=!0),"Enter"===e.key&&r(!n||!s,e.nativeEvent,"click"))},onKeyUp(e){e.defaultPrevented||!f||ht(e)||yt(i)||" "===e.key&&v.current&&(v.current=!1,r(!n||!s,e.nativeEvent,"click"))}}}:{}),[l,o,c,a,f,i,s,n,r])},e.useClientPoint=function(e,t){void 0===t&&(t={});const{open:n,refs:r,dataRef:o,elements:{floating:i}}=e,{enabled:l=!0,axis:s="both",x:f=null,y:d=null}=t,v=u.useRef(!1),m=u.useRef(null),[p,g]=u.useState(),[h,b]=u.useState([]),E=c(((e,t)=>{v.current||o.current.openEvent&&!bt(o.current.openEvent)||r.setPositionReference(function(e,t){let n=null,r=null,o=!1;return{contextElement:e.current||void 0,getBoundingClientRect(){var u,i;const l=(null==(u=e.current)?void 0:u.getBoundingClientRect())||{width:0,height:0,x:0,y:0},c="x"===t.axis||"both"===t.axis,s="y"===t.axis||"both"===t.axis,a=["mouseenter","mousemove"].includes((null==(i=t.dataRef.current.openEvent)?void 0:i.type)||"")&&"touch"!==t.pointerType;let f=l.width,d=l.height,v=l.x,m=l.y;return null==n&&t.x&&c&&(n=l.x-t.x),null==r&&t.y&&s&&(r=l.y-t.y),v-=n||0,m-=r||0,f=0,d=0,!o||a?(f="y"===t.axis?l.width:0,d="x"===t.axis?l.height:0,v=c&&null!=t.x?t.x:v,m=s&&null!=t.y?t.y:m):o&&!a&&(d="x"===t.axis?l.height:d,f="y"===t.axis?l.width:f),o=!0,{width:f,height:d,x:v,y:m,top:m,right:v+f,bottom:m+d,left:v}}}}(r.domReference,{x:e,y:t,axis:s,dataRef:o,pointerType:p}))})),w=c((e=>{null==f&&null==d&&(n?m.current||b([]):E(e.clientX,e.clientY))})),x=O(p)?i:n,R=u.useCallback((()=>{if(!x||!l||null!=f||null!=d)return;const e=a(r.floating.current);function t(n){const o=T(n);y(r.floating.current,o)?(e.removeEventListener("mousemove",t),m.current=null):E(n.clientX,n.clientY)}if(!o.current.openEvent||bt(o.current.openEvent)){e.addEventListener("mousemove",t);const n=()=>{e.removeEventListener("mousemove",t),m.current=null};return m.current=n,n}r.setPositionReference(r.domReference.current)}),[o,l,x,r,E,f,d]);return u.useEffect((()=>R()),[R,h]),u.useEffect((()=>{l&&!i&&(v.current=!1)}),[l,i]),u.useEffect((()=>{!l&&n&&(v.current=!0)}),[l,n]),Z((()=>{!l||null==f&&null==d||(v.current=!1,E(f,d))}),[l,f,d,E]),u.useMemo((()=>{if(!l)return{};function e(e){let{pointerType:t}=e;g(t)}return{reference:{onPointerDown:e,onPointerEnter:e,onMouseMove:w,onMouseEnter:w}}}),[l,w])},e.useDelayGroup=(e,t)=>{let{open:n,onOpenChange:r}=e,{id:o}=t;const{currentId:u,setCurrentId:i,initialDelay:l,setState:c,timeoutMs:s}=Ie();Z((()=>{u&&(c({delay:{open:1,close:xe(l,"close")}}),u!==o&&r(!1))}),[o,r,c,u,l]),Z((()=>{function e(){r(!1),c({delay:l,currentId:null})}if(!n&&u===o){if(s){const t=window.setTimeout(e,s);return()=>{clearTimeout(t)}}e()}}),[n,c,u,o,r,l,s]),Z((()=>{n&&i(o)}),[n,i,o])},e.useDelayGroupContext=Ie,e.useDismiss=function(e,t){void 0===t&&(t={});const{open:r,onOpenChange:o,nodeId:i,elements:{reference:l,domReference:s,floating:f},dataRef:m}=e,{enabled:h=!0,escapeKey:b=!0,outsidePress:E=!0,outsidePressEvent:w="pointerdown",referencePress:x=!1,referencePressEvent:R="pointerdown",ancestorScroll:I=!1,bubbles:k,capture:O}=t,S=ye(),P=c("function"==typeof E?E:()=>!1),L="function"==typeof E?P:E,A=u.useRef(!1),D=u.useRef(!1),{escapeKey:N,outsidePress:F}=xt(k),{escapeKey:j,outsidePress:K}=xt(O),H=c((e=>{if(!r||!h||!b||"Escape"!==e.key)return;const t=S?We(S.nodesRef.current,i):[];if(!N&&(e.stopPropagation(),t.length>0)){let e=!0;if(t.forEach((t=>{var n;null==(n=t.context)||!n.open||t.context.dataRef.current.__escapeKeyBubbles||(e=!1)})),!e)return}o(!1,function(e){return"nativeEvent"in e}(e)?e.nativeEvent:e,"escape-key")})),q=c((e=>{var t;const n=()=>{var t;H(e),null==(t=T(e))||t.removeEventListener("keydown",n)};null==(t=T(e))||t.addEventListener("keydown",n)})),_=c((e=>{const t=A.current;A.current=!1;const n=D.current;if(D.current=!1,"click"===w&&n)return;if(t)return;if("function"==typeof L&&!L(e))return;const r=T(e),u="["+be("inert")+"]",l=C(f).querySelectorAll(u);let c=d(r)?r:null;for(;c&&!p(c);){const e=g(c);if(p(e)||!d(e))break;c=e}if(l.length&&d(r)&&!r.matches("html,body")&&!y(r,f)&&Array.from(l).every((e=>!y(c,e))))return;if(v(r)&&f){const t=r.clientWidth>0&&r.scrollWidth>r.clientWidth,n=r.clientHeight>0&&r.scrollHeight>r.clientHeight;let o=n&&e.offsetX>r.clientWidth;if(n){const t="rtl"===function(e){return a(e).getComputedStyle(e)}(r).direction;t&&(o=e.offsetX<=r.offsetWidth-r.clientWidth)}if(o||t&&e.offsetY>r.clientHeight)return}const m=S&&We(S.nodesRef.current,i).some((t=>{var n;return M(e,null==(n=t.context)?void 0:n.elements.floating)}));if(M(e,f)||M(e,s)||m)return;const h=S?We(S.nodesRef.current,i):[];if(h.length>0){let e=!0;if(h.forEach((t=>{var n;null==(n=t.context)||!n.open||t.context.dataRef.current.__outsidePressBubbles||(e=!1)})),!e)return}o(!1,e,"outside-press")})),B=c((e=>{var t;const n=()=>{var t;_(e),null==(t=T(e))||t.removeEventListener(w,n)};null==(t=T(e))||t.addEventListener(w,n)}));return u.useEffect((()=>{if(!r||!h)return;function e(e){o(!1,e,"ancestor-scroll")}m.current.__escapeKeyBubbles=N,m.current.__outsidePressBubbles=F;const t=C(f);b&&t.addEventListener("keydown",j?q:H,j),L&&t.addEventListener(w,K?B:_,K);let u=[];return I&&(d(s)&&(u=n.getOverflowAncestors(s)),d(f)&&(u=u.concat(n.getOverflowAncestors(f))),!d(l)&&l&&l.contextElement&&(u=u.concat(n.getOverflowAncestors(l.contextElement)))),u=u.filter((e=>{var n;return e!==(null==(n=t.defaultView)?void 0:n.visualViewport)})),u.forEach((t=>{t.addEventListener("scroll",e,{passive:!0})})),()=>{b&&t.removeEventListener("keydown",j?q:H,j),L&&t.removeEventListener(w,K?B:_,K),u.forEach((t=>{t.removeEventListener("scroll",e)}))}}),[m,f,s,l,b,L,w,r,o,I,h,N,F,H,j,q,_,K,B]),u.useEffect((()=>{A.current=!1}),[L,w]),u.useMemo((()=>h?{reference:{onKeyDown:H,[Et[R]]:e=>{x&&o(!1,e.nativeEvent,"reference-press")}},floating:{onKeyDown:H,onMouseDown(){D.current=!0},onMouseUp(){D.current=!0},[wt[w]]:()=>{A.current=!0}}}:{}),[h,x,w,R,o,H])},e.useFloating=function(e){var t;void 0===e&&(e={});const{open:r=!1,onOpenChange:o,nodeId:i}=e,[l,s]=u.useState(null),a=(null==(t=e.elements)?void 0:t.reference)||l,f=n.useFloating(e),v=ye(),m=null!=he(),p=c(((e,t,n)=>{e&&(h.current.openEvent=t),y.emit("openchange",{open:e,event:t,reason:n,nested:m}),null==o||o(e,t,n)})),g=u.useRef(null),h=u.useRef({}),y=u.useState((()=>me()))[0],b=de(),E=u.useCallback((e=>{const t=d(e)?{getBoundingClientRect:()=>e.getBoundingClientRect(),contextElement:e}:e;f.refs.setReference(t)}),[f.refs]),w=u.useCallback((e=>{(d(e)||null===e)&&(g.current=e,s(e)),(d(f.refs.reference.current)||null===f.refs.reference.current||null!==e&&!d(e))&&f.refs.setReference(e)}),[f.refs]),x=u.useMemo((()=>({...f.refs,setReference:w,setPositionReference:E,domReference:g})),[f.refs,w,E]),R=u.useMemo((()=>({...f.elements,domReference:a})),[f.elements,a]),I=u.useMemo((()=>({...f,refs:x,elements:R,dataRef:h,nodeId:i,floatingId:b,events:y,open:r,onOpenChange:p})),[f,i,b,y,r,p,x,R]);return Z((()=>{const e=null==v?void 0:v.nodesRef.current.find((e=>e.id===i));e&&(e.context=I)})),u.useMemo((()=>({...f,context:I,refs:x,elements:R})),[f,x,R,I])},e.useFloatingNodeId=function(e){const t=de(),n=ye(),r=he(),o=e||r;return Z((()=>{const e={id:t,parentId:o};return null==n||n.addNode(e),()=>{null==n||n.removeNode(e)}}),[n,t,o]),t},e.useFloatingParentNodeId=he,e.useFloatingPortalNode=ct,e.useFloatingTree=ye,e.useFocus=function(e,t){void 0===t&&(t={});const{open:n,onOpenChange:r,events:o,refs:i,elements:{floating:l,domReference:c}}=e,{enabled:s=!0,visibleOnly:f=!0}=t,m=u.useRef(!1),p=u.useRef(),g=u.useRef(!0);return u.useEffect((()=>{if(!s)return;const e=a(c);function t(){!n&&v(c)&&c===h(C(c))&&(m.current=!0)}function r(){g.current=!0}return e.addEventListener("blur",t),e.addEventListener("keydown",r,!0),()=>{e.removeEventListener("blur",t),e.removeEventListener("keydown",r,!0)}}),[c,n,s]),u.useEffect((()=>{if(s)return o.on("openchange",e),()=>{o.off("openchange",e)};function e(e){let{reason:t}=e;"reference-press"!==t&&"escape-key"!==t||(m.current=!0)}}),[o,s]),u.useEffect((()=>()=>{clearTimeout(p.current)}),[]),u.useMemo((()=>s?{reference:{onPointerDown(e){x(e.nativeEvent)||(g.current=!1)},onMouseLeave(){m.current=!1},onFocus(e){if(m.current)return;const t=T(e.nativeEvent);if(f&&d(t))try{if(R()&&k())throw Error();if(!t.matches(":focus-visible"))return}catch(e){if(!g.current&&!P(t))return}r(!0,e.nativeEvent,"focus")},onBlur(e){m.current=!1;const t=e.relatedTarget,n=d(t)&&t.hasAttribute(be("focus-guard"))&&"outside"===t.getAttribute("data-type");p.current=window.setTimeout((()=>{const o=h(c?c.ownerDocument:document);(t||o!==c)&&(y(i.floating.current,t)||y(c,t)||n||r(!1,e.nativeEvent,"focus"))}))}}}:{}),[s,f,c,i,r])},e.useHover=function(e,t){void 0===t&&(t={});const{open:n,onOpenChange:r,dataRef:o,events:i,elements:{domReference:l,floating:c},refs:s}=e,{enabled:a=!0,delay:f=0,handleClose:v=null,mouseOnly:m=!1,restMs:p=0,move:g=!0}=t,h=ye(),b=he(),E=Ee(v),w=Ee(f),x=u.useRef(),R=u.useRef(),I=u.useRef(),k=u.useRef(),M=u.useRef(!0),T=u.useRef(!1),S=u.useRef((()=>{})),P=u.useCallback((()=>{var e;const t=null==(e=o.current.openEvent)?void 0:e.type;return(null==t?void 0:t.includes("mouse"))&&"mousedown"!==t}),[o]);u.useEffect((()=>{if(a)return i.on("openchange",e),()=>{i.off("openchange",e)};function e(e){let{open:t}=e;t||(clearTimeout(R.current),clearTimeout(k.current),M.current=!0)}}),[a,i]),u.useEffect((()=>{if(!a||!E.current||!n)return;function e(e){P()&&r(!1,e,"hover")}const t=C(c).documentElement;return t.addEventListener("mouseleave",e),()=>{t.removeEventListener("mouseleave",e)}}),[c,n,r,a,E,P]);const L=u.useCallback((function(e,t,n){void 0===t&&(t=!0),void 0===n&&(n="hover");const o=xe(w.current,"close",x.current);o&&!I.current?(clearTimeout(R.current),R.current=setTimeout((()=>r(!1,e,n)),o)):t&&(clearTimeout(R.current),r(!1,e,n))}),[w,r]),A=u.useCallback((()=>{S.current(),I.current=void 0}),[]),D=u.useCallback((()=>{if(T.current){const e=C(s.floating.current).body;e.style.pointerEvents="",e.removeAttribute(we),T.current=!1}}),[s]);return u.useEffect((()=>{if(a&&d(l)){const e=l;return n&&e.addEventListener("mouseleave",s),null==c||c.addEventListener("mouseleave",s),g&&e.addEventListener("mousemove",u,{once:!0}),e.addEventListener("mouseenter",u),e.addEventListener("mouseleave",i),()=>{n&&e.removeEventListener("mouseleave",s),null==c||c.removeEventListener("mouseleave",s),g&&e.removeEventListener("mousemove",u),e.removeEventListener("mouseenter",u),e.removeEventListener("mouseleave",i)}}function t(){return!!o.current.openEvent&&["click","mousedown"].includes(o.current.openEvent.type)}function u(e){if(clearTimeout(R.current),M.current=!1,m&&!O(x.current)||p>0&&0===xe(w.current,"open"))return;const t=xe(w.current,"open",x.current);t?R.current=setTimeout((()=>{r(!0,e,"hover")}),t):r(!0,e,"hover")}function i(r){if(t())return;S.current();const o=C(c);if(clearTimeout(k.current),E.current){n||clearTimeout(R.current),I.current=E.current({...e,tree:h,x:r.clientX,y:r.clientY,onClose(){D(),A(),L(r,!0,"safe-polygon")}});const t=I.current;return o.addEventListener("mousemove",t),void(S.current=()=>{o.removeEventListener("mousemove",t)})}("touch"!==x.current||!y(c,r.relatedTarget))&&L(r)}function s(n){t()||null==E.current||E.current({...e,tree:h,x:n.clientX,y:n.clientY,onClose(){D(),A(),L(n)}})(n)}}),[l,c,a,e,m,p,g,L,A,D,r,n,h,w,E,o]),Z((()=>{var e;if(a&&n&&null!=(e=E.current)&&e.__options.blockPointerEvents&&P()){const e=C(c).body;if(e.setAttribute(we,""),e.style.pointerEvents="none",T.current=!0,d(l)&&c){var t;const e=l,n=null==h||null==(t=h.nodesRef.current.find((e=>e.id===b)))||null==(t=t.context)?void 0:t.elements.floating;return n&&(n.style.pointerEvents=""),e.style.pointerEvents="auto",c.style.pointerEvents="auto",()=>{e.style.pointerEvents="",c.style.pointerEvents=""}}}}),[a,n,b,c,l,h,E,P]),Z((()=>{n||(x.current=void 0,A(),D())}),[n,A,D]),u.useEffect((()=>()=>{A(),clearTimeout(R.current),clearTimeout(k.current),D()}),[a,l,A,D]),u.useMemo((()=>{if(!a)return{};function e(e){x.current=e.pointerType}return{reference:{onPointerDown:e,onPointerEnter:e,onMouseMove(e){n||0===p||(clearTimeout(k.current),k.current=setTimeout((()=>{M.current||r(!0,e.nativeEvent,"hover")}),p))}},floating:{onMouseEnter(){clearTimeout(R.current)},onMouseLeave(e){L(e.nativeEvent,!1)}}}}),[a,p,n,r,L])},e.useId=de,e.useInnerOffset=function(e,t){const{open:n,elements:o}=e,{enabled:i=!0,overflowRef:l,scrollRef:s,onChange:a}=t,f=c(a),d=u.useRef(!1),v=u.useRef(null),m=u.useRef(null);return u.useEffect((()=>{if(!i)return;function e(e){if(e.ctrlKey||!t||null==l.current)return;const n=e.deltaY,o=l.current.top>=-.5,u=l.current.bottom>=-.5,i=t.scrollHeight-t.clientHeight,c=n<0?-1:1,s=n<0?"max":"min";t.scrollHeight<=t.clientHeight||(!o&&n>0||!u&&n<0?(e.preventDefault(),r.flushSync((()=>{f((e=>e+Math[s](n,i*c)))}))):/firefox/i.test(E())&&(t.scrollTop+=n))}const t=(null==s?void 0:s.current)||o.floating;return n&&t?(t.addEventListener("wheel",e),requestAnimationFrame((()=>{v.current=t.scrollTop,null!=l.current&&(m.current={...l.current})})),()=>{v.current=null,m.current=null,t.removeEventListener("wheel",e)}):void 0}),[i,n,o.floating,l,s,f]),u.useMemo((()=>i?{floating:{onKeyDown(){d.current=!0},onWheel(){d.current=!1},onPointerMove(){d.current=!1},onScroll(){const e=(null==s?void 0:s.current)||o.floating;if(l.current&&e&&d.current){if(null!==v.current){const t=e.scrollTop-v.current;(l.current.bottom<-.5&&t<-1||l.current.top<-.5&&t>1)&&r.flushSync((()=>f((e=>e+t))))}requestAnimationFrame((()=>{v.current=e.scrollTop}))}}}}:{}),[i,l,o.floating,s,f])},e.useInteractions=function(e){void 0===e&&(e=[]);const t=e,n=u.useCallback((t=>kt(t,e,"reference")),t),r=u.useCallback((t=>kt(t,e,"floating")),t),o=u.useCallback((t=>kt(t,e,"item")),e.map((e=>null==e?void 0:e.item)));return u.useMemo((()=>({getReferenceProps:n,getFloatingProps:r,getItemProps:o})),[n,r,o])},e.useListItem=ee,e.useListNavigation=function(e,t){const{open:n,onOpenChange:r,refs:o,elements:{domReference:i,floating:l}}=e,{listRef:s,activeIndex:a,onNavigate:f=(()=>{}),enabled:d=!0,selectedIndex:m=null,allowEscape:p=!1,loop:g=!1,nested:b=!1,rtl:E=!1,virtual:I=!1,focusItemOnOpen:O="auto",focusItemOnHover:M=!0,openOnArrowKeyDown:T=!0,disabledIndices:S,orientation:P="vertical",cols:D=1,scrollItemIntoView:N=!0,virtualItemRef:H,itemSizes:V,dense:$=!1}=t,Q=he(),J=ye(),ee=c(f),te=u.useRef(O),ne=u.useRef(null!=m?m:-1),re=u.useRef(null),oe=u.useRef(!0),ue=u.useRef(ee),ie=u.useRef(!!l),le=u.useRef(!1),ce=u.useRef(!1),se=Ee(S),ae=Ee(n),fe=Ee(N),[de,ve]=u.useState(),[me,pe]=u.useState(),ge=c((function(e,t,n){void 0===n&&(n=!1);const r=e.current[t.current];r&&(I?(ve(r.id),null==J||J.events.emit("virtualfocus",r),H&&(H.current=r)):G(r,{preventScroll:!0,sync:!(!k()||!R())&&(Ot||le.current)}),requestAnimationFrame((()=>{const e=fe.current;e&&r&&(n||!oe.current)&&(null==r.scrollIntoView||r.scrollIntoView("boolean"==typeof e?{block:"nearest",inline:"nearest"}:e))})))}));Z((()=>{document.createElement("div").focus({get preventScroll(){return Ot=!0,!1}})}),[]),Z((()=>{d&&(n&&l?te.current&&null!=m&&(ce.current=!0,ne.current=m,ee(m)):ie.current&&(ne.current=-1,ue.current(null)))}),[d,n,l,m,ee]),Z((()=>{if(d&&n&&l)if(null==a){if(le.current=!1,null!=m)return;if(ie.current&&(ne.current=-1,ge(s,ne)),!ie.current&&te.current&&(null!=re.current||!0===te.current&&null==re.current)){let e=0;const t=()=>{if(null==s.current[0]){if(e<2){(e?requestAnimationFrame:queueMicrotask)(t)}e++}else ne.current=null==re.current||Tt(re.current,P,E)||b?_(s,se.current):B(s,se.current),re.current=null,ee(ne.current)};t()}}else q(s,a)||(ne.current=a,ge(s,ne,ce.current),ce.current=!1)}),[d,n,l,a,m,b,s,P,E,ee,ge,se]),Z((()=>{var e;if(!d||l||!J||I||!ie.current)return;const t=J.nodesRef.current,n=null==(e=t.find((e=>e.id===Q)))||null==(e=e.context)?void 0:e.elements.floating,r=h(C(l)),o=t.some((e=>e.context&&y(e.context.elements.floating,r)));n&&!o&&oe.current&&n.focus({preventScroll:!0})}),[d,l,J,Q,I]),Z((()=>{if(d&&J&&I&&!Q)return J.events.on("virtualfocus",e),()=>{J.events.off("virtualfocus",e)};function e(e){pe(e.id),H&&(H.current=e)}}),[d,J,I,Q,H]),Z((()=>{ue.current=ee,ie.current=!!l})),Z((()=>{n||(re.current=null)}),[n]);const be=null!=a,we=u.useMemo((()=>{function e(e){if(!n)return;const t=s.current.indexOf(e);-1!==t&&ee(t)}return{onFocus(t){let{currentTarget:n}=t;e(n)},onClick:e=>{let{currentTarget:t}=e;return t.focus({preventScroll:!0})},...M&&{onMouseMove(t){let{currentTarget:n}=t;e(n)},onPointerLeave(e){let{pointerType:t}=e;oe.current&&"touch"!==t&&(ne.current=-1,ge(s,ne),ee(null),I||G(o.floating.current,{preventScroll:!0}))}}}}),[n,o,ge,M,s,ee,I]);return u.useMemo((()=>{if(!d)return{};const e=se.current;function t(t){if(oe.current=!1,le.current=!0,!ae.current&&t.currentTarget===o.floating.current)return;if(b&&St(t.key,P,E))return L(t),r(!1,t.nativeEvent,"list-navigation"),void(v(i)&&!I&&i.focus());const u=ne.current,l=_(s,e),c=B(s,e);if("Home"===t.key&&(L(t),ne.current=l,ee(ne.current)),"End"===t.key&&(L(t),ne.current=c,ee(ne.current)),D>1){const n=V||Array.from({length:s.current.length},(()=>({width:1,height:1}))),r=z(n,D,$),o=r.findIndex((t=>null!=t&&!(null!=e&&e.includes(t)))),u=r.reduce(((t,n,r)=>null==n||null!=e&&e.includes(n)?t:r),-1);if(ne.current=r[U({current:r.map((e=>null!=e?s.current[e]:null))},{event:t,orientation:P,loop:g,cols:D,disabledIndices:Y([...e||[],void 0],r),minIndex:o,maxIndex:u,prevIndex:X(ne.current,n,r,D,t.key===F?"bl":t.key===K?"tr":"tl"),stopEvent:!0})],ee(ne.current),"both"===P)return}if(Mt(t.key,P)){if(L(t),n&&!I&&h(t.currentTarget.ownerDocument)===t.currentTarget)return ne.current=Tt(t.key,P,E)?l:c,void ee(ne.current);Tt(t.key,P,E)?ne.current=g?u>=c?p&&u!==s.current.length?-1:l:W(s,{startingIndex:u,disabledIndices:e}):Math.min(c,W(s,{startingIndex:u,disabledIndices:e})):ne.current=g?u<=l?p&&-1!==u?s.current.length:c:W(s,{startingIndex:u,decrement:!0,disabledIndices:e}):Math.max(l,W(s,{startingIndex:u,decrement:!0,disabledIndices:e})),q(s,ne.current)?ee(null):ee(ne.current)}}function u(e){"auto"===O&&w(e.nativeEvent)&&(te.current=!0)}const l=I&&n&&be&&{"aria-activedescendant":me||de},c=s.current.find((e=>(null==e?void 0:e.id)===de));return{reference:{...l,onKeyDown(o){oe.current=!1;const u=0===o.key.indexOf("Arrow"),i=function(e,t,n){return Ct(t,n?e===j:e===K,e===F)}(o.key,P,E),l=St(o.key,P,E),a=Mt(o.key,P),f=(b?i:a)||"Enter"===o.key||""===o.key.trim();if(I&&n){const e=null==J?void 0:J.nodesRef.current.find((e=>null==e.parentId)),n=J&&e?function(e,t){let n,r=-1;return function t(o,u){u>r&&(n=o,r=u),We(e,o).forEach((e=>{t(e.id,u+1)}))}(t,0),e.find((e=>e.id===n))}(J.nodesRef.current,e.id):null;if(u&&n&&H){const e=new KeyboardEvent("keydown",{key:o.key,bubbles:!0});if(i||l){var d,v;const t=(null==(d=n.context)?void 0:d.elements.domReference)===o.currentTarget,r=l&&!t?null==(v=n.context)?void 0:v.elements.domReference:i?c:null;r&&(L(o),r.dispatchEvent(e),pe(void 0))}var p;if(a&&n.context)if(n.context.open&&n.parentId&&o.currentTarget!==n.context.elements.domReference)return L(o),void(null==(p=n.context.elements.domReference)||p.dispatchEvent(e))}return t(o)}(n||T||!u)&&(f&&(re.current=b&&a?null:o.key),b?i&&(L(o),n?(ne.current=_(s,e),ee(ne.current)):r(!0,o.nativeEvent,"list-navigation")):a&&(null!=m&&(ne.current=m),L(o),!n&&T?r(!0,o.nativeEvent,"list-navigation"):t(o),n&&ee(ne.current)))},onFocus(){n&&ee(null)},onPointerDown:function(e){te.current=O,"auto"===O&&x(e.nativeEvent)&&(te.current=!0)},onMouseDown:u,onClick:u},floating:{"aria-orientation":"both"===P?void 0:P,...!A(i)&&l,onKeyDown:t,onPointerMove(){oe.current=!0}},item:we}}),[i,o,de,me,se,ae,s,d,P,E,I,n,be,b,m,T,p,D,g,O,ee,r,we,J,H,V,$])},e.useMergeRefs=i,e.useRole=function(e,t){var n;void 0===t&&(t={});const{open:r,floatingId:o}=e,{enabled:i=!0,role:l="dialog"}=t,c=null!=(n=Pt.get(l))?n:l,s=de(),a=null!=he();return u.useMemo((()=>{if(!i)return{};const e={id:o,...c&&{role:c}};return"tooltip"===c||"label"===l?{reference:{["aria-"+("label"===l?"labelledby":"describedby")]:r?o:void 0},floating:e}:{reference:{"aria-expanded":r?"true":"false","aria-haspopup":"alertdialog"===c?"dialog":c,"aria-controls":r?o:void 0,..."listbox"===c&&{role:"combobox"},..."menu"===c&&{id:s},..."menu"===c&&a&&{role:"menuitem"},..."select"===l&&{"aria-autocomplete":"none"},..."combobox"===l&&{"aria-autocomplete":"list"}},floating:{...e,..."menu"===c&&{"aria-labelledby":s}},item(e){let{active:t,selected:n}=e;const r={role:"option",...t&&{id:o+"-option"}};switch(l){case"select":return{...r,"aria-selected":t&&n};case"combobox":return{...r,...t&&{"aria-selected":!0}}}return{}}}}),[i,l,c,r,o,s,a])},e.useTransitionStatus=Dt,e.useTransitionStyles=function(e,t){void 0===t&&(t={});const{initial:n={opacity:0},open:r,close:o,common:i,duration:l=250}=t,c=e.placement,s=c.split("-")[0],a=u.useMemo((()=>({side:s,placement:c})),[s,c]),f="number"==typeof l,d=(f?l:l.open)||0,v=(f?l:l.close)||0,[m,p]=u.useState((()=>({...At(i,a),...At(n,a)}))),{isMounted:g,status:h}=Dt(e,{duration:l}),y=Ee(n),b=Ee(r),E=Ee(o),w=Ee(i);return Z((()=>{const e=At(y.current,a),t=At(E.current,a),n=At(w.current,a),r=At(b.current,a)||Object.keys(e).reduce(((e,t)=>(e[t]="",e)),{});if("initial"===h&&p((t=>({transitionProperty:t.transitionProperty,...n,...e}))),"open"===h&&p({transitionProperty:Object.keys(r).map(Lt).join(","),transitionDuration:d+"ms",...n,...r}),"close"===h){const r=t||e;p({transitionProperty:Object.keys(r).map(Lt).join(","),transitionDuration:v+"ms",...n,...r})}}),[v,E,y,b,w,d,h,a]),{isMounted:g,styles:m}},e.useTypeahead=function(e,t){var n;const{open:r,dataRef:o}=e,{listRef:i,activeIndex:l,onMatch:s,onTypingChange:a,enabled:f=!0,findMatch:d=null,resetMs:v=750,ignoreKeys:m=[],selectedIndex:p=null}=t,g=u.useRef(),h=u.useRef(""),y=u.useRef(null!=(n=null!=p?p:l)?n:-1),b=u.useRef(null),E=c(s),w=c(a),x=Ee(d),R=Ee(m);return Z((()=>{r&&(clearTimeout(g.current),b.current=null,h.current="")}),[r]),Z((()=>{var e;r&&""===h.current&&(y.current=null!=(e=null!=p?p:l)?e:-1)}),[r,p,l]),u.useMemo((()=>{if(!f)return{};function e(e){e?o.current.typing||(o.current.typing=e,w(e)):o.current.typing&&(o.current.typing=e,w(e))}function t(e,t,n){const r=x.current?x.current(t,n):t.find((e=>0===(null==e?void 0:e.toLocaleLowerCase().indexOf(n.toLocaleLowerCase()))));return r?e.indexOf(r):-1}function n(n){const o=i.current;if(h.current.length>0&&" "!==h.current[0]&&(-1===t(o,o,h.current)?e(!1):" "===n.key&&L(n)),null==o||R.current.includes(n.key)||1!==n.key.length||n.ctrlKey||n.metaKey||n.altKey)return;r&&" "!==n.key&&(L(n),e(!0));o.every((e=>{var t,n;return!e||(null==(t=e[0])?void 0:t.toLocaleLowerCase())!==(null==(n=e[1])?void 0:n.toLocaleLowerCase())}))&&h.current===n.key&&(h.current="",y.current=b.current),h.current+=n.key,clearTimeout(g.current),g.current=setTimeout((()=>{h.current="",y.current=b.current,e(!1)}),v);const u=y.current,l=t(o,[...o.slice((u||0)+1),...o.slice(0,(u||0)+1)],h.current);-1!==l?(E(l),b.current=l):" "!==n.key&&(h.current="",e(!1))}return{reference:{onKeyDown:n},floating:{onKeyDown:n,onKeyUp(t){" "===t.key&&e(!1)}}}}),[f,r,o,i,v,R,x,E,w])}}));
diff --git a/node_modules/@floating-ui/react/dist/floating-ui.react.utils.d.mts b/node_modules/@floating-ui/react/dist/floating-ui.react.utils.d.mts
index c951454..5a185a1 100644
--- a/node_modules/@floating-ui/react/dist/floating-ui.react.utils.d.mts
+++ b/node_modules/@floating-ui/react/dist/floating-ui.react.utils.d.mts
@@ -1,4 +1,4 @@
-import type * as React from 'react';
+import type * as React_2 from 'react';
 
 export declare function activeElement(doc: Document): Element | null;
 
@@ -22,7 +22,7 @@ export declare function isMac(): boolean;
 
 export declare function isMouseLikePointerType(pointerType: string | undefined, strict?: boolean): boolean;
 
-export declare function isReactEvent(event: any): event is React.SyntheticEvent;
+export declare function isReactEvent(event: any): event is React_2.SyntheticEvent;
 
 export declare function isRootElement(element: Element): boolean;
 
@@ -36,7 +36,7 @@ export declare function isVirtualClick(event: MouseEvent | PointerEvent): boolea
 
 export declare function isVirtualPointerEvent(event: PointerEvent): boolean;
 
-export declare function stopEvent(event: Event | React.SyntheticEvent): void;
+export declare function stopEvent(event: Event | React_2.SyntheticEvent): void;
 
 export declare const TYPEABLE_SELECTOR: string;
 
diff --git a/node_modules/@floating-ui/react/dist/floating-ui.react.utils.d.ts b/node_modules/@floating-ui/react/dist/floating-ui.react.utils.d.ts
index c951454..5a185a1 100644
--- a/node_modules/@floating-ui/react/dist/floating-ui.react.utils.d.ts
+++ b/node_modules/@floating-ui/react/dist/floating-ui.react.utils.d.ts
@@ -1,4 +1,4 @@
-import type * as React from 'react';
+import type * as React_2 from 'react';
 
 export declare function activeElement(doc: Document): Element | null;
 
@@ -22,7 +22,7 @@ export declare function isMac(): boolean;
 
 export declare function isMouseLikePointerType(pointerType: string | undefined, strict?: boolean): boolean;
 
-export declare function isReactEvent(event: any): event is React.SyntheticEvent;
+export declare function isReactEvent(event: any): event is React_2.SyntheticEvent;
 
 export declare function isRootElement(element: Element): boolean;
 
@@ -36,7 +36,7 @@ export declare function isVirtualClick(event: MouseEvent | PointerEvent): boolea
 
 export declare function isVirtualPointerEvent(event: PointerEvent): boolean;
 
-export declare function stopEvent(event: Event | React.SyntheticEvent): void;
+export declare function stopEvent(event: Event | React_2.SyntheticEvent): void;
 
 export declare const TYPEABLE_SELECTOR: string;
 
diff --git a/node_modules/@floating-ui/react/utils/floating-ui.react.utils.d.ts b/node_modules/@floating-ui/react/utils/floating-ui.react.utils.d.ts
index c951454..5a185a1 100644
--- a/node_modules/@floating-ui/react/utils/floating-ui.react.utils.d.ts
+++ b/node_modules/@floating-ui/react/utils/floating-ui.react.utils.d.ts
@@ -1,4 +1,4 @@
-import type * as React from 'react';
+import type * as React_2 from 'react';
 
 export declare function activeElement(doc: Document): Element | null;
 
@@ -22,7 +22,7 @@ export declare function isMac(): boolean;
 
 export declare function isMouseLikePointerType(pointerType: string | undefined, strict?: boolean): boolean;
 
-export declare function isReactEvent(event: any): event is React.SyntheticEvent;
+export declare function isReactEvent(event: any): event is React_2.SyntheticEvent;
 
 export declare function isRootElement(element: Element): boolean;
 
@@ -36,7 +36,7 @@ export declare function isVirtualClick(event: MouseEvent | PointerEvent): boolea
 
 export declare function isVirtualPointerEvent(event: PointerEvent): boolean;
 
-export declare function stopEvent(event: Event | React.SyntheticEvent): void;
+export declare function stopEvent(event: Event | React_2.SyntheticEvent): void;
 
 export declare const TYPEABLE_SELECTOR: string;
 
